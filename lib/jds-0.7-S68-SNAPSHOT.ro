Cache for UNIX^INT^JSON data store 04 Nov 2014^~Format=Cache.S~^RAW
%RO on 04 Nov 2014   12:58 PM
VPRJ^INT^1^63384;42216^0
VPRJ ;SLC/KCM -- Menu for JSON data store utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Menu to run various utilities for the JSON data store:  D ^VPRJ
 ;
MENU ; Allow utilities to be selected from a menu
 G DOMENU^VPRJ1
 ;
START ; Start the HTTP listener
 I $$STATUS^VPRJRCL="running" W !,"Listener is already running.",! Q
 ;
 W !,"Starting listener on port ",$$PORT^VPRJRCL
 D GO^VPRJRCL
 H 1
 W !,"Listener status:  ",$$STATUS^VPRJRCL,!
 Q
STOP ; Stop the HTTP listener
 N X
 I $G(^VPRHTTP(0,"listener"))="stopped" W !,"Listener is already stopped.",! Q
 D STOPW^VPRJRCL
 Q
WAIT ;
 N I,X
 S X=$$STATUS^VPRJRCL
 W !,"Listener status: ",X
 F I=1:1:12 Q:X="stopped"  D
 . H 1
 . S X=$$STATUS^VPRJRCL
 . W "."
 . I X="stopped" W X
 Q
PORT ; Change the listening port number
 N PORT
 W !,"Enter port number: "
 R PORT:300 E  Q
 I '$L(PORT) Q
 I (PORT<1024)!(PORT>65000) W " ??" G PORT
 D STOP
 D SPORT^VPRJRCL(PORT)
 D START
 Q
LOG ; Set the logging level
 N X
 W !,"Log level will be changed on the next connection.",!
 W !,"0: no logging except errors"
 W !,"1: log http errors"
 W !,"2: log requests by pattern"
 W !,"3: log all requests"
 W !,"4: log raw input"
 W !
 W !,"Enter log level: "
 R X:300 E  Q
 I '$L(X) Q
 I X'?1N W " ??" G LOG
 I X>4 W " ??" G LOG
 D SLOG^VPRJRCL(X)
 I X=2 D
 . N PATH,HELP,CURRENT
 . S CURRENT=$G(^VPRHTTP(0,"logging","path"))
 . S HELP="* is wild card, ... matches rest of path.  Example: /vpr/*/index/myidx/..."
 . S PATH=$$PROMPT^VPRJ1("  Path Pattern",CURRENT,"S",HELP)
 . S ^VPRHTTP(0,"logging","path")=PATH
 Q
CLEAR ; Clear the current logs
 W !,"Clearing all logs",!
 D CLEAR^VPRJRCL
 Q
ERROR ; List errors
  N DT,JOB,ID
  S DT=0 F  S DT=$O(^VPRHTTP("log",DT)) Q:'DT  D
  . S JOB=0 F  S JOB=$O(^VPRHTTP("log",DT,JOB)) Q:'JOB  D
  . . S ID=0 F  S ID=$O(^VPRHTTP("log",DT,JOB,ID)) Q:'ID  D
  . . . S X=$G(^VPRHTTP("log",DT,JOB,ID,"error"))
  . . . Q:'$L(X)
  . . . W !,ID,?10,$$HTE^XLFDT(DT),?14,X
  Q
VPRSTAT ; VPR statistics
 D STATUS^VPRJ2P
 Q
PIDSTAT ; PID statistics
 N PID S PID=$$ASKPID^VPRJ2P Q:'$L(PID)
 D STATUS^VPRJ2P(PID)
 Q
RIDXALL ; Re-index entire VPR
 D RIDXALL^VPRJ2P
 Q
RIDXPID ; Re-index by PID
 N PID S PID=$$ASKPID^VPRJ2P Q:'$L(PID)
 D RIDXPID^VPRJ2P(PID)
 Q
RIDXONE ; Build a single index
 Q
RBLDALL ; Re-build entire VPR
 D RBLDALL^VPRJ2P
 Q
RBLDPID ; Re-build by PID
 N PID S PID=$$ASKPID^VPRJ2P Q:'$L(PID)
 D RBLDPID^VPRJ2P(PID)
 Q
LISTPTA ; List patients alphabetically
 D LISTPTS(1)
 Q
LISTPTP ; List patients by PID
 D LISTPTS(0)
 Q
LISTPTS(ALPHA) ; List all the patients in the VPR
 N PID,DFN,UID,NAME,ICN,SSN,LIST,X
 S ALPHA=$G(ALPHA)
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S UID=$O(^VPRPT(PID,"urn:va:patient:"))
 . I $P(UID,":",3)'="patient" W !,"Missing demographics: ",PID Q
 . S NAME=^VPRPT(PID,UID,"fullName"),ICN=$G(^("icn")),SSN=$G(^("ssn"))
 . I ALPHA S LIST(NAME,PID)=SSN_"^"_ICN_"^"_PID Q
 . S LIST(PID,NAME)=SSN_"^"_ICN_"^"_PID
 I ALPHA D
 . W !,"Name",?30,"SSN",?40,"ICN",?60,"DFN/PID"
 . S NAME="" F  S NAME=$O(LIST(NAME)) Q:NAME=""  D
 . . S PID="" F  S PID=$O(LIST(NAME,PID)) Q:'$L(PID)  D
 . . . S X=LIST(NAME,PID)
 . . . W !,NAME,?30,$P(X,"^"),?40,$P(X,"^",2),?60,$P(X,"^",3)
 E  D
 . W !,"Name",?30,"SSN",?40,"ICN",?60,"DFN/PID"
 . S PID="" F  S PID=$O(LIST(PID)) Q:'$L(PID)  D
 . . S NAME="" F  S NAME=$O(LIST(PID,NAME)) Q:NAME=""  D
 . . . S X=LIST(PID,NAME)
 . . . W !,NAME,?30,$P(X,"^"),?40,$P(X,"^",2),?60,$P(X,"^",3)
 Q
DELPID ; Delete a patient from the VPR
 N PID S PID=$$ASKPID^VPRJ2P Q:'$L(PID)
 D CLEARPT^VPRJPS(PID)
 Q
RESET ; Reset the VPR (kill the database an re-initialize)
 I '$$ISYES("Are you sure you want to delete the database? ") Q
 D SUSPEND
 D KILLDB^VPRJ2P
 D RESUME
 Q
 ;
ASKFRBLD ; ask first before rebuilding everything
 I '$$ISYES("Are you sure you want rebuild all data stores? ") Q
 D FULLRBLD
 Q
ASKFRSET ; ask first before deleting all data
 I '$$ISYES("Are you sure you want to delete all data stores? ") Q
 D FULLRSET
 Q
FULLRBLD ; do a full rebuild of VPR and non-patient data
 D SUSPEND
 K ^TMP($J)
 D RBLDALL^VPRJ2P
 D RBLDALL^VPRJ2D
 D RESUME
 Q
FULLRSET ; reset (delete data and re-init) for VPR and non-patient data
 D SUSPEND
 K ^TMP($J)
 D KILLDB^VPRJ2P
 D KILLDB^VPRJ2D
 D RESUME
 Q
SUSPEND ; suspend listener and set updating flag
 S ^VPRHTTP(0,"updating")=1
 I $E($G(^VPRHTTP(0,"listener")),1,4)'="stop" D
 . S ^VPRHTTP(0,"updating","resume")=1
 . W !,"Suspending HTTP Listener..."
 D STOPW^VPRJRCL
 Q
RESUME ; resume listener if it was running before and reset updating flag
 N RESUME
 S RESUME=$G(^VPRHTTP(0,"updating","resume"),0)
 K ^VPRHTTP(0,"updating")
 I RESUME D
 . W !,"Restarting HTTP Listener..."
 . D GO^VPRJRCL
 Q
ISYES(MSG) ; returns 1 if user answers yes to message, otherwise 0
 N X
 W !,MSG
 R X:300 E  Q 0
 I $$UP^XLFSTR($E(X))="Y" Q 1
 Q 0
 ;
LOGMSG(TYPE,MSG) ; log a new message
 N IDX
 W !,MSG,!
 S IDX=$G(^XTMP("VPRJVUP",TYPE,"msg"),0)+1,^XTMP("VPRJVUP",TYPE,"msg")=IDX
 S ^XTMP("VPRJVUP",TYPE,"msg",IDX)=MSG
 Q
LOGCNT(TYPE) ; increment a count
 N CNT
 S CNT=$G(^XTMP("VPRJVUP",TYPE,"count"),0)+1,^XTMP("VPRJVUP",TYPE,"count")=CNT
 I TYPE="odc" W:CNT#100=0 "." Q
 W "."
 Q
RBLDSTS() ; show status
 N DONE,TYPE,X
 S DONE=1
 S TYPE="" F  S TYPE=$O(^XTMP("VPRJVUP",TYPE)) Q:TYPE=""  I '$G(^XTMP("VPRJVUP",TYPE,"complete")) S DONE=0
 S X="Rebuild Status: "_$S(DONE:"done",1:"processing")
 S TYPE="" F  S TYPE=$O(^XTMP("VPRJVUP",TYPE)) Q:TYPE=""  D
 . S X=X_"   "_TYPE_": "_$G(^XTMP("VPRJVUP",TYPE,"count"))_"/"_$G(^XTMP("VPRJVUP",TYPE,"total"))
 Q X

VPRJ1^INT^1^63404;43618^0
VPRJ1 ;SLC/KCM -- Menu Handling for JSON Store Utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
DOMENU ; display menu and execute choice
 N SEL
 D HEADER
 F  D SHOWMENU S SEL=$$CHOICE() Q:SEL=""  D
 . D @SEL
 . D PAUSE
 . I SEL="START^VPRJ" D HEADER
 . I SEL="LOG^VPRJ" D HEADER
 . I SEL="PORT^VPRJ" D HEADER
 . I SEL="DELPID^VPRJ" D HEADER
 Q
HEADER ; display header information
 W !
 W "Listener Port: ",$$PORT^VPRJRCL,"   "
 W "Status: ",$$STATUS^VPRJRCL,"   "
 W "Log Level: ",$$LOG^VPRJRCL,"   "
 W "VPR Patients: ",$G(^VPRPTX("count","patient","patient"))
 W !
 Q
SHOWMENU ; display menu
 N X,I
 S I=0 F  S I=I+1,X=$P($T(MENULST+I),";;",2,99) Q:X="zzzzz"  W !,X
 W !
 Q
CHOICE() ; prompt for menu choice
 N X,I,MENU,DONE
 S I=0 F  S I=I+1,X=$P($T(MENUNUM+I),";;",2,99) Q:X="zzzzz"  S MENU($P(X,";"))=$P(X,";",2)
 F  D  Q:$G(DONE)
 . S X=$$PROMPT("Enter Selection","","N","Enter a number from the menu above")
 . I X="" S DONE=1 Q
 . I '$D(MENU(X)) W !,X," is not a valid selection." Q
 . I $D(MENU(X)) S X=MENU(X),DONE=1
 Q X
 ;
PROMPT(PROMPT,DEFAULT,TYPE,HELP) ; Return value for a prompt
 N X
 S DEFAULT=$G(DEFAULT),HELP=$G(HELP)
RETRY ;
 W !,PROMPT,": ",$S($L(DEFAULT):" "_DEFAULT_"//",1:" ")
 R X:300
 I X="?",$L(HELP) W !,HELP,! G RETRY
 I X="" S X=DEFAULT
 I TYPE="N",$L(X),'X W !,"Numeric input required."
 Q X
 ;
PAUSE ; Pause for a return
 N X
 W !,"Press return to continue"
 R X:300
 Q
MENULST ;; menu display list
 ;;-- Listener --                          -- Logging --
 ;; 1 Start HTTP Listener on Port 9080      4 Change Logging Level
 ;; 2 Stop HTTP Listener                    5 Clear Logs
 ;; 3 Change HTTP Listener Port             6 List Errors
 ;;              
 ;;-- VPR Info --                          -- ODC Info --
 ;;11 List Synced Patients (alpha)         21 List Collections (ODC)
 ;;12 List Synced Patients (by PID)        22 Statistics (ODC)
 ;;13 Statistics for PID                             
 ;;14 Statistics for VPR (may be slow)                                        
 ;;               
 ;;-- VPR Tools --                         -- ODC Tools --
 ;;31 Re-index VPR                         41 Re-index ODC
 ;;32 Rebuild VPR                          42 Rebuild ODC
 ;;33 Delete Patient from VPR              43 Delete Collection       
 ;;34 Reset VPR (deletes VPR data)         44 Reset ODC (deletes data)
 ;;
 ;;50 Rebuild All (VPR and ODC)            70 Reset All (VPR and ODC)
 ;;zzzzz
MENUNUM ;; menu selection numbers
 ;;1;START^VPRJ
 ;;2;STOP^VPRJ
 ;;3;PORT^VPRJ
 ;;4;LOG^VPRJ
 ;;5;CLEAR^VPRJ
 ;;6;ERROR^VPRJ
 ;;11;LISTPTA^VPRJ
 ;;12;LISTPTP^VPRJ
 ;;13;PIDSTAT^VPRJ
 ;;14;STATUS^VPRJ2P
 ;;21;LSTCTN^VPRJ2D
 ;;22;STATUS^VPRJ2D
 ;;31;RIDXALL^VPRJ2P
 ;;32;RBLDALL^VPRJ2P
 ;;33;DELPID^VPRJ
 ;;34;RESET^VPRJ
 ;;41;RIDXALL^VPRJ2D
 ;;42;RBLDALL^VPRJ2D
 ;;43;DELCTN^VPRJ2D
 ;;44;RESET^VPRJ2D
 ;;50;ASKFRBLD^VPRJ
 ;;70;ASKFRSET^VPRJ
 ;;zzzzz
 ;

VPRJ2D^INT^1^63384;42216^0
VPRJ2D ;SLC/KCM -- Management utilities for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
RIDXALL ; Reindex data
 N OK,KEY
 K ^XTMP("VPRJVUP","odc")
 S ^XTMP("VPRJVUP","odc","total")=$$TOTCTNI()
 D LOGMSG^VPRJ("odc","Re-indexing all non-patient data")
 L +^VPRJD:5 E  D LOGMSG^VPRJ("odc","Unable to lock all operational data") Q
 D SUSPEND^VPRJ
 D CLRINDEX(.OK) Q:'OK
 S KEY="" F  S KEY=$O(^VPRJD(KEY)) Q:KEY=""  D
 . D RIDXOBJ(KEY)
 . D LOGCNT^VPRJ("odc")
 D RESUME^VPRJ
 L -^VPRJD
 S ^XTMP("VPRJVUP","odc","complete")=1
 Q
RIDXCTN(CTN) ; Reindex a collection
 ; Can't re-index an object at a time without corrupting the tallys
 ; We don't know which tallies to kill.
 Q
RBLDALL ; Rebuild all objects (includes templates)
 N OK,KEY
 K ^XTMP("VPRJVUP","odc")
 S ^XTMP("VPRJVUP","odc","total")=$$TOTCTNI()
 D LOGMSG^VPRJ("odc","Rebuild ALL non-patient data (including templates)")
 L +^VPRJD:5 E  D LOGMSG^VPRJ("odc","Unable to lock ALL operational data")
 D SUSPEND^VPRJ
 D CLRINDEX(.OK) Q:'OK  ; clears VPRJDX,VPRTMP
 D CLRDATA(.OK) Q:'OK   ; clears VPRJD,VPRJDJ except VPRJDJ("JSON")
 S KEY="" F  S KEY=$O(^VPRJDJ("JSON",KEY)) Q:KEY=""  D
 . D RBLDOBJ(KEY)
 . D LOGCNT^VPRJ("odc")
 D RESUME^VPRJ
 L -^VPRJD
 D LOGMSG^VPRJ("odc","ODC rebuild complete")
 S ^XTMP("VPRJVUP","odc","complete")=1
 Q
RBLDCTN(CTN) ; Rebuild single collection (includes templates)
 ; Can't re-buld an object at a time without corrupting the tallys
 ; We don't know which tallies to kill.
 Q
RIDXOBJ(KEY) ; Re-index a single object
 L +^VPRJD(KEY):2 E  D LOGMSG^VPRJ("odc","Unable to obtain lock for "_KEY) QUIT
 N OBJECT
 M OBJECT=^VPRJD(KEY)
 TSTART
 D INDEX^VPRJDX(KEY,"",.OBJECT)
 TCOMMIT
 L -^VPRJD(KEY)
 Q
RBLDOBJ(KEY) ; Re-build a single object
 L +^VPRJD(KEY):2 E  D LOGMSG^VPRJ("odc","Unable to obtain lock for "_KEY) QUIT
 N LINE,JSON
 ; get the original JSON object without the templates
 S LINE=0 F  S LINE=$O(^VPRJDJ("JSON",KEY,LINE)) Q:'LINE  S JSON(LINE)=^VPRJDJ("JSON",KEY,LINE)
 ; indexes have been killed for whole patient, so remove the original object
 K ^VPRJD(KEY)
 K ^VPRJDJ("JSON",KEY)
 K ^VPRJDJ("TEMPLATE",KEY)
 ; call save the replace the object & reset indexes
 D SAVE^VPRJDS(.JSON)
 L -^VPRJD(KEY)
 Q
CLRINDEX(OK) ; Clear all the indexes
 L +^VPRJD:2 E  D LOGMSG^VPRJ("odc","Unable to get lock for indexes.") S OK=0 Q
 K ^VPRJDX,^VPRTMP
 L -^VPRJD
 D SETUP^VPRJPMD
 S OK=1
 Q
CLRDATA(OK) ; Clear data except for original JSON
 L +^VPRJD:2 E  D LOGMSG^VPRJ("odc","Unable to get lock for data.") S OK=0 Q
 K ^VPRJD,^VPRJDJ("TEMPLATE")
 L -^VPRJD
 S OK=1
 Q
LSTCTN ; List collections
 N CTN
 W !,"Collections   Items     (UIDs) --"
 S CTN="" F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . W !,?2,CTN,?14,$G(^VPRJDX("count","collection",CTN)),?24,"(",$$OBJCTN(CTN),")"
 Q
STATUS ; Show statistics for non-patient data
 W !,"Statistics for non-patient data --"
 W !,?4," Data Nodes: ",$$NODECNT^VPRJ2P("^VPRJD")
 W !,?4,"Index Nodes: ",$$NODECNT^VPRJ2P("^VPRJDX")
 W !,?4,"Collections: ",$$TOTCTN()
 W !,?4,"Total Items: ",$$TOTCTNI()
 W !,?4,"Unique ID's: ",$$OBJCNT()
 Q
TOTCTN() ; Return the number of collections
 N CTN,COUNT
 S COUNT=0,CTN=""
 F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . I $G(^VPRJDX("count","collection",CTN)) S COUNT=COUNT+1
 Q COUNT
 ;
TOTCTNI() ; Return the total number of items in all collections
 N CTN,COUNT
 S COUNT=0,CTN=""
 F  S CTN=$O(^VPRJDX("count","collection",CTN)) Q:CTN=""  D
 . S COUNT=COUNT+$G(^VPRJDX("count","collection",CTN))
 Q COUNT
 ;
OBJCNT() ; Return a count of objects by UID
 N COUNT,UID
 S COUNT=0,UID="urn:" ; to skip "JSON" and "TEMPLATE" nodes
 F  S UID=$O(^VPRJD(UID)) Q:UID=""  S COUNT=COUNT+1
 Q COUNT
 ;
OBJCTN(CTN) ; Return a count of objects by UID for a collection
 N COUNT,PREFIX,UID
 S COUNT=0,PREFIX="urn:va:"_CTN_":",UID=PREFIX
 F  S UID=$O(^VPRJD(UID)) Q:$E(UID,1,$L(PREFIX))'=PREFIX  S COUNT=COUNT+1
 Q COUNT
DELCTN ; Delete a collection
 N HTTPERR,CTN
 S CTN=$$PROMPT^VPRJ1("Collection","","S","Enter string that identifies collection in the UID.")
 Q:CTN=""
 I '$D(^VPRJDX("count","collection",CTN)) W !,"Collection not found." Q
 D DELCTN^VPRJDS(CTN)
 I $G(HTTPERR) W !,"Error while deleting collection: ",HTTPERR
 Q
RESET ; Reset the non-patient data store (kill the data and re-initialize)
 N X
 W !,"Are you sure you want to delete the database? "
 R X:300 E  Q
 I $$UP^XLFSTR($E(X))'="Y" Q
 D SUSPEND^VPRJ
 D KILLDB
 D RESUME^VPRJ
 Q
KILLDB ; -- Delete and reset the globals for the database
 K ^VPRJD
 K ^VPRJDJ
 K ^VPRJDX
 K ^VPRTMP
 D SETUP^VPRJPMD
 Q

VPRJ2P^INT^1^63435;39516^0
VPRJ2P ;SLC/KCM -- Management utilities for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
RIDXALL ; Reindex all patients
 N OK
 K ^XTMP("VPRJVUP","vpr")
 S ^XTMP("VPRJVUP","vpr","total")=$G(^VPRPTX("count","patient","patient"))
 D LOGMSG^VPRJ("vpr","Re-indexing VPR for ALL patients")
 L +^VPRPT:5 E  D LOGMSG^VPRJ("vpr","Unable to lock ALL patient data") Q
 D SUSPEND^VPRJ
 D CLRINDEX(.OK) Q:'OK
 N PID,KEY
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:PID=""  D
 . S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RIDXOBJ(PID,KEY)
 . D LOGCNT^VPRJ("vpr")
 D RESUME^VPRJ
 L -^VPRPT
 S ^XTMP("VPRJVUP","vpr","complete")=1
 Q
RIDXPID(PID) ; Reindex a single patient
 K ^XTMP("VPRJVUP","vpr")
 D LOGMSG^VPRJ("vpr","Re-index VPR for a single patient")
 Q:'$L($G(PID))
 ;
 L +^VPRPT(PID):5 E  D LOGMSG^VPRJ("vpr","Unable to lock patient data") Q
 D CLRCODES(PID),CLREVIEW(PID),CLRCOUNT(PID)
 K ^VPRPTI(PID)
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RIDXOBJ(PID,KEY)
 L -^VPRPT(PID)
 Q
RBLDALL ; Rebuild all patients (includes templates)
 N OK,JPID
 K ^XTMP("VPRJVUP","vpr")
 S ^XTMP("VPRJVUP","vpr","total")=$G(^VPRPTX("count","patient","patient"))
 D LOGMSG^VPRJ("vpr","Re-build VPR (including templates) for ALL patients")
 L +^VPRPT:5 E  D LOGMSG^VPRJ("vpr","Unable to lock ALL patient data") Q
 D SUSPEND^VPRJ
 D CLRINDEX(.OK) Q:'OK  ; clears VPRPTI,VPRPTX,VPRTMP
 D CLRDATA(.OK) Q:'OK   ; clears VPRPT,VPRPTJ except VPRPTJ("JSON")
 S JPID="" F  S JPID=$O(^VPRPTJ("JSON",JPID)) Q:JPID=""  D
 . N PID,KEY
 . S PID=$$MKPID(JPID) I '$L(PID) D LOGMSG^VPRJ("vpr","Error creating PID: "_JPID) Q
 . S KEY="" F  S KEY=$O(^VPRPTJ("JSON",JPID,KEY)) Q:KEY=""  D RBLDOBJ(PID,KEY)
 . D LOGCNT^VPRJ("vpr")
 D RESUME^VPRJ
 L -^VPRPT
 D LOGMSG^VPRJ("vpr","VPR rebuild complete")
 S ^XTMP("VPRJVUP","vpr","complete")=1
 Q
MKPID(PID) ; create PID entries with demographics object
 N KEY,JSON,DEMOG,ERR
 S KEY=$O(^VPRPTJ("JSON",JPID,"urn:va:patient:"))
 I '$L(KEY) D SETERROR^VPRJRER(214) Q ""
 M JSON=^VPRPTJ("JSON",PID,KEY)
 D DECODE^VPRJSON("JSON","DEMOG","ERR")
 I $D(ERR) D SETERROR^VPRJRER(202) Q ""
 Q $$UPDPT^VPRJPR(.DEMOG)
 ;
RBLDPID(PID) ; Rebuild single patient (includes templates)
 K ^XTMP("VPRJVUP","vpr")
 D LOGMSG^VPRJ("vpr","Re-build VPR (including templates) for a single patient")
 Q:'$L($G(PID))
 ;
 L +^VPRPT(PID):5 E  D LOGMSG^VPRJ("vpr","Unable to lock patient data") Q
 D CLRCODES(PID),CLREVIEW(PID),CLRCOUNT(PID)
 K ^VPRPTI(PID)
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D RBLDOBJ(PID,KEY)
 L -^VPRPT(PID)
 Q
RIDXOBJ(PID,KEY) ; Re-index a single object
 L +^VPRPT(PID,KEY):2 E  D LOGMSG^VPRJ("vpr","Unable to obtain lock for "_KEY) QUIT
 N OBJECT
 M OBJECT=^VPRPT(PID,KEY)
 TSTART
 D INDEX^VPRJPX(PID,KEY,"",.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,KEY)
 Q
RBLDOBJ(PID,KEY) ; Re-build a single object
 L +^VPRPT(PID,KEY):2 E  D LOGMSG^VPRJ("vpr","Unable to obtain lock for "_KEY) QUIT
 N LINE,JSON
 ; get the original JSON object without the templates
 S LINE=0 F  S LINE=$O(^VPRPTJ("JSON",PID,KEY,LINE)) Q:'LINE  D
 . S JSON(LINE)=^VPRPTJ("JSON",PID,KEY,LINE)
 ; indexes have been killed for whole patient, so remove the original object
 K ^VPRPT(PID,KEY)
 K ^VPRPTJ("JSON",PID,KEY)
 K ^VPRPTJ("TEMPLATE",PID,KEY)
 K ^VPRPTJ("KEY",KEY,PID)
 ; call save the replace the object & reset indexes
 D SAVE^VPRJPS(PID,.JSON)
 L -^VPRPT(PID,KEY)
 Q
CLRINDEX(OK) ; Clear all the indexes, preserving the "put patient" part
 ; since that is not redone with a reindex
 N PCNT
 L +^VPRPTJ("PID"):2 E  D LOGMSG^VPRJ("vpr","Unable to get lock for indexes.") S OK=0 Q
 S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 K ^VPRPTI,^VPRPTX,^VPRTMP
 S ^VPRPTX("count","patient","patient")=PCNT ; preserve the count
 L -^VPRPTJ("PID")
 D SETUP^VPRJPMD
 S OK=1
 Q
CLRDATA(OK) ; Clear all data except for original JSON
 L +^VPRPTJ("PID"):2 E  D LOGMSG^VPRJ("vpr","Unable to get lock for data.") S OK=0 Q
 K ^VPRPT,^VPRPTJ("TEMPLATE"),^VPRPTJ("KEY"),^VPRPTJ("PID")
 K ^VPRPTX("count","patient","patient")  ; remove since total rebuild
 L -^VPRPTJ("PID")
 S OK=1
 Q
CLRCODES(PID) ; Clear the cross patient indexes for coded values
 ;remove ^VPRPTX("allCodes",code,field,PID)
 ;remove ^VPRPTX("pidCodes",PID)
 N FLD,CODE,KEY
 S FLD="" F  S FLD=$O(^VPRPTX("pidCodes",PID,FLD)) Q:FLD=""  D
 . S CODE="" F  S CODE=$O(^VPRPTX("pidCodes",PID,FLD,CODE)) Q:CODE=""  D
 . . S KEY="" F  S KEY=$O(^VPRPTX("pidCodes",PID,FLD,CODE,KEY)) Q:KEY=""  D
 . . . K ^VPRPTX("allCodes",CODE,FLD,PID,KEY)
 K ^VPRPTX("pidCodes",PID)
 Q
CLREVIEW(PID) ; Clear the cross patient indexes for re-evaluation times
 ;remove ^VPRPTX("review",reviewTime,PID)
 ;remove ^VPRPTX("pidReview",PID)
 N REVTM
 S REVTM="" F  S REVTM=$O(^VPRPTX("pidReview",PID,REVTM)) Q:REVTM=""  D
 . K ^VPRPTX("review",REVTM,PID)
 K ^VPRPTX("pidReview",PID)
 Q
CLRCOUNT(PID) ; Decrement the cross-patient totals for a patient
 ;reduce ^VPRPTX("count","collection",topic)
 ;    by ^VPRPTI(PID,"tally","collection",topic)
 ;reduce ^VPRPTX("count","domain",topic)
 ;    by ^VPRPTI(PID,"tally","domain",topic)
 N GROUP,TOPIC,CNT4PID,CNT4ALL ; decrement the relevant counts
 F GROUP="collection","domain" I $D(^VPRPTI(PID,"tally",GROUP)) D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTI(PID,"tally",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S CNT4PID=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 . . L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRER(502,GROUP_" "_NAME) QUIT
 . . S CNT4ALL=+$G(^VPRPTX("count",GROUP,TOPIC))
 . . S ^VPRPTX("count",GROUP,TOPIC)=CNT4ALL-CNT4PID ; decr count across patients
 . . L -^VPRPTX("count",GROUP,TOPIC)
 Q
CLRXIDX(PID) ; remove cross-patient indexes for a patient
 N KEY,OLDOBJ
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:'$L(KEY)  D
 . L +^VPRPT(PID,KEY):2 E  D SETERROR^VPRJRER(502,PID_">  "_KEY) QUIT
 . M OLDOBJ=^VPRPT(PID,KEY)
 . D CLRXONE(PID,KEY,.OLDOBJ)
 . L -^VPRPT(PID,KEY)
 Q
CLRXONE(PID,KEY,OLDOBJ) ; Clear cross-patient indexes for this key
 N IDXCOLL,IDXNAME,NEWOBJ
 ; Currently assuming UID is urn:va:type:vistaAccount:localId...
 ; For example:  urn:va:med:93EF:34014
 S IDXCOLL=$P(KEY,":",3),NEWOBJ=""
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"index",IDXNAME)) Q:IDXNAME=""  D
 . I ^VPRMETA("index",IDXNAME,"common","method")'="xattr" QUIT
 . N IDXMETA
 . M IDXMETA=^VPRMETA("index",IDXNAME,"collection",IDXCOLL)
 . S IDXMETA("setif")=$G(^VPRMETA("index",IDXNAME,"common","setif"))
 . S IDXMETA("review")=$G(^VPRMETA("index",IDXNAME,"common","review"))
 . S IDXMETA("levels")=$G(^VPRMETA("index",IDXNAME,"common","levels"))
 . S IDXMETA("method")=^VPRMETA("index",IDXNAME,"common","method")
 . D XATTR^VPRJPXA
 Q
STATUS(PID) ; Show VPR status for a patient
 I $L($G(PID)) D
 . W !,"For PID ",PID," --"
 . W !,?4,"Index Nodes: ",$$NODECNT("^VPRPTI("""_PID_""")")
 . W !,?4," Data Nodes: ",$$NODECNT("^VPRPT("""_PID_""")")
 . W !,?4,"Object Counts --"
 . W !,?8,"    Domain: ",$$ITEMCNT("domain",PID)
 . W !,?8,"Collection: ",$$ITEMCNT("collection",PID)
 . W !,?8,"     UID's: ",$$OBJCNT(PID)
 . W !,?4,"Code Refs: ",$$NODECNT("^VPRPTX(""pidCodes"","""_PID_""")")
 E  D
 . W !,"VPR Totals --"
 . W !,?4,"Patients: ",$$PTCNT()
 . W !,?4,"Index Nodes: ",$$NODECNT("^VPRPTI")
 . W !,?4," Data Nodes: ",$$NODECNT("^VPRPT")
 . W !,?4,"Object Counts --"
 . W !,?8,"    Domain: ",$$ITEMCNT("domain")
 . W !,?8,"Collection: ",$$ITEMCNT("collection")
 . W !,?8,"     UID's: ",$$OBJCNT()
 . W !,?4,"  Code Refs: ",$$NODECNT("^VPRPTX(""allCodes"")")
 . W !,?4,"Review Refs: ",$$NODECNT("^VPRPTX(""review"")")
 Q
PTCNT() ; Return the number of patients in the VPR
 N PID,COUNT
 S PID="",COUNT=0
 F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  S COUNT=COUNT+1
 Q COUNT
 ;
NODECNT(ROOT) ; Return the number of nodes for ROOT
 N X,COUNT
 S X=ROOT,COUNT=0
 I $E(ROOT,$L(ROOT))=")" S ROOT=$E(ROOT,1,$L(ROOT)-1)
 F  S X=$Q(@X) Q:$E(X,1,$L(ROOT))'=ROOT  S COUNT=COUNT+1
 Q COUNT
 ;
ITEMCNT(GROUP,PID) ; Return the item count for a group
 ; PID is optional, if absent, entire VPR is counted
 N COUNT,TOPIC
 S COUNT=0
 I $L($G(PID)) D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTI(PID,"tally",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S COUNT=COUNT+^VPRPTI(PID,"tally",GROUP,TOPIC)
 E  D
 . S TOPIC="" F  S TOPIC=$O(^VPRPTX("count",GROUP,TOPIC)) Q:TOPIC=""  D
 . . S COUNT=COUNT+^VPRPTX("count",GROUP,TOPIC)
 Q COUNT
 ;
OBJCNT(PID) ; Return a count of objects by UID
 ; PID is optional, if absent, entire VPR is counted
 N COUNT,UID
 S COUNT=0
 I $L($G(PID)) D
 . S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:UID=""  S COUNT=COUNT+1
 E  D
 . S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . . S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:UID=""  S COUNT=COUNT+1
 Q COUNT
 ;
KILLDB ; -- Delete and reset the globals for the database
 K ^VPRHTTP("log")
 K ^VPRPT
 K ^VPRPTJ
 K ^VPRPTI
 K ^VPRPTX
 K ^VPRTMP
 K ^VPRMETA
 D SETUP^VPRJPMD
 Q
ASKPID() ; Return PID after prompting for it
 N PID,KEY
 S PID=$$PROMPT^VPRJ1("PID","","","Enter the PID for a patient.")
 I '$L(PID) Q ""
 I '$D(^VPRPT(PID)) W !,"PID "_PID_" not found." S PID=""
 Q PID
 ;

VPRJ3^INT^1^63294;58829^0
VPRJ3 ;SLC/KCM -- Display Log Entries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
EN ; enter here -- list today's entries, otherwise prompt date or name
 Q
DATES ; list log entry totals by reverse chronological date
 Q
ENTRIES(DATE) ; list log entries for a selected date
 Q
 ;
 ; KEY is $Hday,$Job,Id  example: 62900,2985,851
 ; if IOM is available, use that as right margin
 ; if ScreenSize or IOSL is available, use that as screen length
 ;  
ENTRY(KEY) ; show log entry for key, prompting for details
 Q
ALL(KEY) ; show all for key
 Q
HEADER(KEY) ; show header for key
 Q
BODY(KEY) ; show body for key
 Q
SYMBOLS(KEY) ; show symbols for key
 Q
STACK(KEY) ; show stack for key
 Q

VPRJAQ^INT^1^63355;64532^0
VPRJAQ ;SLC/KCM -- Query for JSON objects across patients
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
QCOUNT(CNTNM) ; Return a set of counts across patients
 ; return tallies as data:{items:[{"topic":"med","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRER(101) Q
 N BUFFER S BUFFER=""
 K ^TMP($J)
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRPTX("count",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRPTX("count",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJCB(DATA) D STAGE^VPRJCB(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJCB(DATA(DATA))
 D STAGE^VPRJCB("]}}"),OUT^VPRJCB
 Q
QINDEX(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; Query across patients by index
 I $G(INDEX)="pid",($G(TEMPLATE)="pid") D QPID Q
 ;
 I '$L($G(INDEX)) D SETERROR^VPRJRER(101) Q
 N VPRDATA,METHOD,CLAUSES
 S RANGE=$G(RANGE),ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 M INDEX=^VPRMETA("index",INDEX,"common")
 S METHOD=$G(INDEX("method")) I '$L(METHOD) D SETERROR^VPRJRER(102,INDEX) Q
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 D QATTR^VPRJAQA
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
QPID ; Custom query to just return all PID's (/vpr/all/index/pid/pid)
 K ^TMP($J)
 N COUNT,PID,LINE,BUFFER
 S COUNT=0,LINE=2,PID="",BUFFER=""
 F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S COUNT=COUNT+1
 . I $L(BUFFER)>4000 S ^TMP($J,LINE)=BUFFER,LINE=LINE+1,BUFFER=""
 . S BUFFER=BUFFER_$S(COUNT>1:",",1:"")_""""_PID_""""
 S ^TMP($J,LINE)=BUFFER_"]}}"
 S ^TMP($J,1)=$$BLDHEAD^VPRJCB(COUNT)
 Q
QFIND(COLL,ORDER,BAIL,TEMPLATE,FILTER) ; Query across patients using filter criteria
 N VPRDATA,CLAUSES,PREFIX,PID,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S PREFIX="urn:va:"_COLL_":",KEY=PREFIX
 . F  S KEY=$O(^VPRPT(PID,KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJPQA(KEY,0)
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q

VPRJAQA^INT^1^63294;58829^0
VPRJAQA ;SLC/KCM -- Query across patients using attribute indexes for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;defined at the QINDEX level:
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QATTR ; return items where attribute value is in range
 ; Build ^TMP("VPRDATA",$J,sortkey,sortkey,...,key,instances) with keys of objects to return
 ; Expects:  VPRDATA,METHOD,RANGE,INDEX,ORDER,CLAUSES,BAIL
 N START,STOP,DIR,SUB,KEY,INST
 D PARSERNG^VPRJCR
 I $G(IDXLAST)=1 D  ; handle finding last or latest items
 . S DIR(INDEX("levels"))=$S(INDEX("collate",INDEX("levels"))="V":1,1:-1)
 . I INDEX("levels")=0  D L0 Q
 . I INDEX("levels")=1  D L1 Q
 . I INDEX("levels")=2  D L2 Q
 . I INDEX("levels")=3  D L3 Q
 E  D               ; normal search loops
 . I INDEX("levels")=0  D A0 Q
 . I INDEX("levels")=1  D A1 Q
 . I INDEX("levels")=2  D A2 Q
 . I INDEX("levels")=3  D A3 Q
 Q
A0 ; unsorted list
 S KEY="" F  S KEY=$O(^VPRPTX(METHOD,INDEX,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
A1 ; sorted list / attribute only
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY="" F  S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST="" F  S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)=START(3) F  S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY="" F  S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST="" F  S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
NXT1() ;
 I START(1,"collate")="L" S SUB(1)=$O(START(1,"list",SUB(1))) Q SUB(1)
 Q $O(^VPRPTX(METHOD,INDEX,SUB(1)),DIR(1))
 ;
NXT2() ;
 I START(2,"collate")="L" S SUB(2)=$O(START(2,"list",SUB(2))) Q SUB(2)
 Q $O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2)),DIR(2))
 ;
NXT3() ;
 I START(3,"collate")="L" S SUB(3)=$O(START(3,"list",SUB(3))) Q SUB(3)
 Q $O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),SUB(3)),DIR(3))
 ;
L0 ; unsorted list
 S KEY="" S KEY=$O(^VPRPTX(METHOD,INDEX,KEY),-1) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
L1 ; sorted list / attribute only
 S SUB(1)="" S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)="" S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)="" S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST=$O(^VPRPTX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
ADDONE(KEY,INST,SUB) ; add uid, calculating new sort key if necessary
 ; Expects: .ORDER,.CLAUSES
 I $D(CLAUSES) Q:'$$EVALAND^VPRJCF(.CLAUSES,KEY)  ;apply filter, quit if not true
 N I,SORT,KINST
 S I=0 F  S I=$O(ORDER(I)) Q:'I  S SORT(I)=$S(+ORDER(I):SUB(+ORDER(I)),1:$$SORTPID^VPRJPQA(I))
 S VPRDATA=VPRDATA+1
 ; case
 I ORDER(0)=0 S ^TMP("VPRDATA",$J,KEY,INST)="" G X1
 I ORDER(0)=1 S ^TMP("VPRDATA",$J,SORT(1),KEY,INST)="" G X1
 I ORDER(0)=2 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,INST)="" G X1
 I ORDER(0)=3 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,INST)="" G X1
 I ORDER(0)=4 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,INST)="" G X1
 I ORDER(0)=5 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,INST)="" G X1
 I ORDER(0)=6 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,INST)="" G X1
 I ORDER(0)=7 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,INST)="" G X1
X1 ; end case
 Q
 ;

VPRJCB^INT^1^63294;58829^0
VPRJCB ;SLC/KCM -- Common Utilities for building query results
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
BLDHEAD(CNT) ; Build the object header
 N X,UPDATED
 S UPDATED=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"+")
 S X="{""apiVersion"":""1.0"",""data"":{""updated"":"_UPDATED_","
 S X=X_"""totalItems"":"_CNT_",""items"":["
 Q X
 ;
STAGE(X) ; appends to BUFFER until OUT writes it
 S BUFFER=BUFFER_X
 I $L(BUFFER)'<4000 D OUT
 Q
OUT(X) ; write out a frame of data
 S BUFFER("LINES")=$G(BUFFER("LINES"),0)+1
 S ^TMP($J,BUFFER("LINES"))=BUFFER,BUFFER=""
 Q
BUILD ; Build the return records in the proper sort order
 ; Expects:  ORDER, TEMPLATE
 Q:+$G(HTTPERR)>0
 N KEY,KINST,SORT,RECNUM
 ;
 S RECNUM=$G(^TMP($J,"total"))-1 ; ^TMP($J,"total") exists for index queries
 ; case
 I ORDER(0)=0 D  G X0
 . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,KEY)) Q:KEY=""  D
 . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=1 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),KEY)) Q:KEY=""  D
 . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=2 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY)) Q:KEY=""  D
 . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=3 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY)) Q:KEY=""  D
 . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=4 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY)) Q:KEY=""  D
 . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=5 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY)) Q:KEY=""  D
 . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=6 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S SORT(6)="" F  S SORT(6)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6)),ORDER(6,"dir")) Q:SORT(6)=""  D
 . . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY)) Q:KEY=""  D
 . . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
 I ORDER(0)=7 D  G X0
 . S SORT(1)="" F  S SORT(1)=$O(^TMP("VPRDATA",$J,SORT(1)),ORDER(1,"dir")) Q:SORT(1)=""  D
 . . S SORT(2)="" F  S SORT(2)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2)),ORDER(2,"dir")) Q:SORT(2)=""  D
 . . . S SORT(3)="" F  S SORT(3)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3)),ORDER(3,"dir")) Q:SORT(3)=""  D
 . . . . S SORT(4)="" F  S SORT(4)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4)),ORDER(4,"dir")) Q:SORT(4)=""  D
 . . . . . S SORT(5)="" F  S SORT(5)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5)),ORDER(5,"dir")) Q:SORT(5)=""  D
 . . . . . . S SORT(6)="" F  S SORT(6)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6)),ORDER(6,"dir")) Q:SORT(6)=""  D
 . . . . . . . S SORT(7)="" F  S SORT(7)=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7)),ORDER(7,"dir")) Q:SORT(7)=""  D
 . . . . . . . . S KEY="" F  S KEY=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY)) Q:KEY=""  D
 . . . . . . . . . S KINST="" F  S KINST=$O(^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,KINST)) Q:KINST=""  D ADDOBJ(^(KINST))
X0 ; end case
 S ^TMP($J,"total")=RECNUM+1 ; add 1 since RECNUM is 0 based
 S ^TMP($J,"template")=TEMPLATE
 Q
ADDOBJ(VAL) ; add object/template in sequence to the return list
 S RECNUM=RECNUM+1
 S ^TMP($J,"data",RECNUM,KEY,KINST)=VAL ; right now the VAL is just the PID
 Q
 ;

VPRJCD^INT^1^63396;54290^0
VPRJCD ;SLC/KCM -- Build meta data (general)
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
BLDMETA(METATYPE,TAG,RTN) ; build meta data
 N I,X,METADATA,METACLTN,LINES
 S I=0 F  S I=I+1,X=$P($T(@TAG+I^@RTN),";;",2,99) D  Q:X="zzzzz"
 . I $E(X)]" ",$D(LINES) D                          ; -- new template name
 . . D BLDSPEC(METATYPE,.LINES,.METADATA,.METACLTN) ; build it
 . . K LINES                                        ; clean up for next template
 . . I $D(METADATA("errors","errors")) D SHOWERR(.METADATA) Q  ; bail if errors
 . . M ^VPRMETA($P(METATYPE,":"))=METADATA          ; save it
 . . M ^VPRMETA("collection")=METACLTN              ; map collections to it
 . S LINES=$G(LINES)+1,LINES(LINES)=X
 Q
BLDSPEC(METATYPE,LINES,METADATA,METACLTN) ; build specification
 ; METATYPE: index, link, or template
 ;.LINES(n): contains a set of lines to parse into a specification
 ;.METADATA: contains the spec to be merged into ^VPRMETA(metatype)
 ;.METACLTN: contains the collection names to be merged into ^VPRMETA("collection")
 ;
 ; CLTNS(name)=""          ;name of each collection
 ; FIELDS(0,seq#)=field    ;general field descriptor
 ; FIELDS(ctn,seq#)=field  ;override field descriptor for collection
 ; ATTR(name)=value        ;value for attribute
 ; MATCH(name)=""          ;name used for matching in MATCH type index  l
 ;
 K METADATA,METACLTN
 N I,X,SPECNAME,GROUP,LINE,CLTN,CLTNS,FIELD,FIELDS,ATTR,MATCH,STYLE,ERRORS
 S SPECNAME=$$TRIM^XLFSTR($P(LINES(1)," "))
 S STYLE=$P(METATYPE,":",2),METATYPE=$P(METATYPE,":")
 D ADDATTR("metatype",METATYPE),ADDATTR("style",STYLE),ADDATTR("name",SPECNAME)
 ; parse out collections, attributes, fields
 S (CLTNS,FIELDS)=0
 F LINE=2:1 Q:'$D(LINES(LINE))  S X=$$TRIM^XLFSTR(LINES(LINE)) D
 . S GROUP=$P(X,":"),X=$$TRIM^XLFSTR($P(X,":",2,99))
 . I GROUP="collections" D SPLIT^VPRJCU(X,.CLTNS) Q  ;all
 . I $E(GROUP,1,6)="fields" D  Q                     ;all
 . . F I=1:1:$L(X,",") S FIELD=$$TRIM^XLFSTR($P(X,",",I)) D
 . . . Q:FIELD="<none>"
 . . . I '$L($P(FIELD,"/")) D SETERR("Missing Field Name") Q
 . . . S CLTN=$P(GROUP,".",2) S:'$L(CLTN) CLTN=0
 . . . I METATYPE="template" S FIELDS(CLTN,$$GETTGT(FIELD))=FIELD I 1
 . . . E  S FIELDS(CLTN,I)=FIELD
 . I GROUP="directives" D  Q                         ;templates
 . . N DIR
 . . D SPLIT^VPRJCU(X,.DIR)
 . . S DIR="" F  S DIR=$O(DIR(DIR)) Q:DIR=""  D
 . . . I $$LOW^XLFSTR(DIR)="applyonsave" D ADDATTR("applyOn","S")
 . . . I $$LOW^XLFSTR(DIR)="applyonquery" D ADDATTR("applyOn","Q")
 . . . I $$LOW^XLFSTR(DIR)="exclude" D ADDATTR("exclude",1)
 . . . I $$LOW^XLFSTR(DIR)="include" D ADDATTR("exclude",0)
 . I $E(GROUP,1,3)="ref" D  Q                        ;links
 . . S CLTN=$P(GROUP,".",2) S:'$L(CLTN) CLTN=0
 . . S FIELDS(CLTN,1)=X
 . I GROUP="rev" D ADDATTR("rev",X) Q                ;links
 . I GROUP="setif" D ADDATTR("setif",X) Q            ;index
 . I GROUP="review" D ADDATTR("review",X) Q          ;index
 . I GROUP="sort" D ADDATTR("sort",X) Q              ;index
 . I GROUP="values" D  Q                             ;index
 . . F I=1:1:$L(X,",") S MATCH=$$TRIM^XLFSTR($P(X,",",I)) S:$L(MATCH) MATCH(MATCH)=""
 ;
 ; map collections to specification name
 I $D(CLTNS)<10 D SETERR("No collections specified for "_SPECNAME) Q
 S CLTN="" F  S CLTN=$O(CLTNS(CLTN)) Q:CLTN=""  S METACLTN(CLTN,METATYPE,SPECNAME)=""
 ;
 ; build SPEC based on METATYPE (index, link, template)
 N SPEC
 I METATYPE="index" D IDXSPEC^VPRJCD1(.CLTNS,.FIELDS,.ATTR,.SPEC)
 I METATYPE="link" D LINKSPEC^VPRJCD1(.CLTNS,.FIELDS,.ATTR,.SPEC)
 I METATYPE="template" D TLTSPEC^VPRJCD1(.CLTNS,.FIELDS,.ATTR,.SPEC)
 ; need errors on second node in case spec is named "errors"
 I $G(ERRORS) M METADATA("errors","errors")=ERRORS QUIT
 M METADATA(SPECNAME)=SPEC
 Q
FLDSPEC(FLD,SPEC,TYPE) ; convert field assignment descriptor to .SPEC
 ; defines ERRORS if parsing errors are encountered
 ;.SPEC("xxxArrays")=1                             ;array levels in path
 ;.SPEC("xxxArrays",1)=items                       ;name of array
 ;.SPEC("xxxArrays",1,"collect")=""                ;empty or collect delimiter
 ;.SPEC("xxxArrays",1,"dir")=1                     ;direction for $O, 0 for #
 ;.SPEC("xxxArrays",1,"max")=999999                ;max for $O
 ;.SPEC("xxxArrays",1,"path")=items                ;instance path
 ;.SPEC("xxxArrays",1,"ref")=OBJECT("items",I(n))  ;$O(@(REF(level))
 ;.SPEC("xxxArrayPath")=items                      ;concatenation of all arrays
 ;.SPEC("xxxMethod")=1                             ;method for assigning value
 ;.SPEC("xxxPath")=items[].name                    ;for reference info
 ;.SPEC("xxxPath",n)=items                         ;subscript names for full path
 ;.SPEC("xxxRef")=OBJECT("items",I(1),"name")      ;leaf level reference
 ;.SPEC("xxxTemplate")="summary"                   ;optional expanded value template
 ;
 N I,X,ISARY,ARYCNT,OREF,NODE,COLLECT,TMPLT
 S ARYCNT=0,COLLECT=""
 S OREF=$S(TYPE="tgt":"TARGET(",1:"OBJECT(")
 I TYPE="vpr" S TYPE="src",OREF="^VPRPT(PID,KEY,"
 I TYPE="data" S TYPE="src",OREF="^VPRJD(KEY,"
 S SPEC("merge")=0
 S TMPLT=$P(FLD,";",2),FLD=$P(FLD,";")
 F I=1:1:$L(FLD,".") D
 . S NODE=$P(FLD,".",I),ISARY=(NODE["["),X=$P(NODE,"[")
 . I X="*",(I=$L(FLD,".")) D  Q
 . . I $L(COLLECT) D SETERR("can't combine collect and merge: "_X) Q
 . . S SPEC("merge")=1
 . I '$$NAMEOK(X) D SETERR("bad name: "_X) Q
 . S SPEC(TYPE_"Path",I)=X
 . Q:'ISARY
 . I '$$ARYOK(NODE) D SETERR("bad array specifier") Q
 . S ARYCNT=ARYCNT+1
 . S SPEC(TYPE_"Arrays")=ARYCNT
 . S SPEC(TYPE_"Arrays",ARYCNT)=X
 . S SPEC(TYPE_"Arrays",ARYCNT,"path")=$$BLDIPATH($P(FLD,".",1,I))
 . S SPEC(TYPE_"Arrays",ARYCNT,"ref")=$$BLDREF($P(FLD,".",1,I),OREF)
 . ; for templates
 . I '$L(COLLECT) S COLLECT=$$ARYCLCT(NODE) ; once collect, stay collect
 . S SPEC(TYPE_"Arrays",ARYCNT,"collect")=COLLECT
 . S SPEC(TYPE_"Arrays",ARYCNT,"dir")=$$ARYDIR(NODE)
 . S SPEC(TYPE_"Arrays",ARYCNT,"max")=$$ARYMAX(NODE)
 I $$LASTARY(FLD,"#") S SPEC(TYPE_"InstancePath")=$P(FLD,".",1,$$LASTARY(FLD,"#"))
 S SPEC(TYPE_"ArrayPath")=$S(ARYCNT:$$BLDIPATH($P(FLD,".",1,$$LASTARY(FLD))),1:"")
 S SPEC(TYPE_"Path")=FLD
 S SPEC(TYPE_"Ref")=$$BLDREF(FLD,OREF)
 S SPEC(TYPE_"Method")=$$GETMTHD(FLD)
 I $L(TMPLT) S SPEC(TYPE_"Template")=TMPLT
 Q
BLDREF(FLD,VARNM) ; build a reference for use with indirection
 N I,OREF,ARYCNT,LASTARY
 S OREF="",ARYCNT=0,LASTARY=0
 S VARNM=$G(VARNM,"OBJECT(")
 F I=1:1:$L(FLD,".") I $P(FLD,".",I)["[" S LASTARY=LASTARY+1
 F I=1:1:$L(FLD,".") D
 . I $P(FLD,".",I)="*" Q  ; skip merge indicator
 . S OREF=OREF_$S(I=1:"",1:",")_""""_$P($P(FLD,".",I),"[")_""""
 . I $P(FLD,".",I)["[" S ARYCNT=ARYCNT+1 D
 . . I VARNM="TARGET(",(ARYCNT=LASTARY) S OREF=OREF_",J"
 . . E  S OREF=OREF_",I("_ARYCNT_")"
 Q VARNM_OREF_")"
 ;
BLDIPATH(FLD) ; build the instance path for nested arrays
 N INODE,NODE,IPATH
 S IPATH=""
 F INODE=1:1:$L(FLD,".") D
 . S NODE=$P(FLD,".",INODE)
 . S IPATH=IPATH_$S($L(IPATH):".",1:"")_$P(NODE,"[")
 Q IPATH
 ;
LASTARY(FLD,MOD) ; return the piece number of the last array
 N I,LAST
 S LAST=0,MOD=$G(MOD)
 F I=1:1:$L(FLD,".") I $P(FLD,".",I)[("["_MOD) S LAST=I
 Q LAST
 ;
ARYMOD(NODE) ; return array modifier for node
 N X
 S X=$P(NODE,"[",2),X=$E(X,1,$L(X)-1)
 Q X
 ;
ARYCLCT(NODE) ; return collection delimiter for node, if any
 N X
 S X=$$ARYMOD(NODE)
 I $E(X)="*" S X=$E(X,2,99) S:'$L(X) X="," Q X
 Q ""
 ;
ARYDIR(NODE) ; return $O direction for node, 0 for instance
 N X
 S X=$$ARYMOD(NODE)
 I X="#" Q 0
 I $E(X)="-" Q -1
 Q 1
 ;
ARYMAX(NODE) ; return max number of array items to return
 N X
 S X=$$ARYMOD(NODE)
 I $E(X)="-" S X=$E(X,2,$L(X))
 I X="#" Q 1
 S X=+X
 I X=0 Q 999999
 Q X
ARYOK(NODE) ; return true if valid array specifier
 N X
 S X=$$ARYMOD(NODE)
 I X="" Q 1       ;full array
 I X="#" Q 1      ;current instance
 I $E(X)="*" Q 1  ;collect
 I +X,(+X=X) Q 1  ;+n or -n elements
 Q 0
 ;
GETMTHD(FLD,INST) ; return "get value" method
 N I,X,FLDPAT
 S FLDPAT="",INST=$G(INST)
 F I=1:1:$L(FLD,".") S FLDPAT=FLDPAT_$S($P(FLD,".",I)["[":"A",1:"N")
 I FLDPAT="N" Q 0
 I FLDPAT="AN" Q 1
 I FLDPAT="AAN" Q 2
 I INST,(FLDPAT="A") Q 1
 I INST,(FLDPAT="AA") Q 2
 Q 99
 ;
VALSPEC(POS,CNT,SPEC) ; set up value spec based on position and array levels
 I 'CNT S SPEC("valRef")="VALS("_$S(+POS=POS:POS,1:""""_POS_"""")_")" Q
 N I,J,X
 F I=1:1:CNT D
 . S X="VALS("_$S(+POS=POS:POS,1:""""_POS_"""")_","  ; always +POS??
 . F J=1:1:I S X=X_$S(J=1:"",1:",")_"I("_J_")"
 . S X=X_")",SPEC("valArrays")=I,SPEC("valArrays",I)=X
 S SPEC("valRef")=SPEC("valArrays",CNT)
 Q
GETTGT(FLD) ; return the target name for a field spec
 N I,X,Y
 S X=$S(FLD["=":$P(FLD,"="),FLD[">":$P(FLD,">"),1:FLD)
 S X=$P(X,".*"),Y=""
 F I=1:1:$L(X,".") D
 . S Y=Y_$S($L(Y):".",1:"")_$P($P(X,".",I),"[")
 . I $P(X,".",I)["[" S Y=Y_"[]"
 Q Y
 ;
ADDATTR(NAME,VALUE) ; add attribute name and value
 ;expects ATTR, from BLDSPEC
 S ATTR(NAME)=$$TRIM^XLFSTR(VALUE)
 Q
NAMEOK(X) ; Return true if valid Java variable name
 N I,OK
 I '$L(X) Q 0
 S X=$$LOW^XLFSTR(X),OK=1
 F I=1:1:$L(X) I "abcdefghijklmnopqrstuvwxyz1234567890_$"'[$E(X,I) S OK=0
 Q OK
 ;
SHOWERR(METADATA) ; display error
 ; TODO: put something here to return error info if being called by service
 W !,"Errors encountered while creating meta-data"
 N I
 S I=0 F  S I=$O(METADATA("errors","errors",I)) Q:'I  D
 . W !,$J(I,3)
 . W ?5,$G(METADATA("errors","errors",I,"name"))_" "
 . W "("_$G(METADATA("errors","errors",I,"type"))_")"
 . W ?40,$G(METADATA("errors","errors",I))
 Q
SETERR(MSG) ; Record error parsing template info
 S ERRORS=$G(ERRORS)+1
 S ERRORS(ERRORS)=MSG
 S ERRORS(ERRORS,"name")=$G(ATTR("name"))
 S ERRORS(ERRORS,"type")=$G(ATTR("metatype"))
 Q

VPRJCD1^INT^1^63396;54290^0
VPRJCD1 ;SLC/KCM -- Build meta data (specific)
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
IDXSPEC(CLTNS,FIELDS,ATTR,SPEC) ; Build SPEC for index type
 ;.CLTNS(CLTN): set of collections
 ;.FIELDS(0,SEQ): default field specifier in subscript order of index
 ;.FIELDS(CLTN,SEQ): field specifiers that override default per collection 
 ;.ATTR: index attributes such as style and sort
 ;.SPEC("common","method")=attr,time,tally,etc.
 ;.SPEC("common","order")=default sort expression
 ;.SPEC("common","alias",SEQ)=default fields for index (names used for order, filter, etc.)
 ;.SPEC("common","collate",SEQ)=collation for each subscript in index
 ;.SPEC("common","levels")=number of subscripts in index
 ;.SPEC("collection",CLTN,"method")=attr,time,tally,etc.
 ;.SPEC("collection",CLTN,"review")=function to determine review data for this index
 ;.SPEC("collection",CLTN,"setif")=function to determine if index should be set
 ;.SPEC("collection",CLTN,POS,"method")=assignment method (see below)
 ;.SPEC("collection",CLTN,POS,"collate")=collation type for this field
 ;.SPEC("collection",CLTN,POS,"ifNull")=optional value to use if there is no value
 ;.SPEC("collection",CLTN,POS,"combine")=strategy to combine instances at this level
 ;.SPEC("collection",CLTN,POS,"srcXXX",...)=source field specification
 ;.SPEC("collection",CLTN,POS,"valXXX",...)=values array specification
 ;
 ; TODO: add support for MATCH and CODES (pass thru in ATTR?)
 ;
 N POS,CLTN,USED,FLDNUM,COMBINE
 I '$L($G(ATTR("style"))) D SETERR^VPRJCD("Index style missing") Q
 S SPEC("common","method")=ATTR("style")
 I $L($G(ATTR("sort"))),(ATTR("sort")'="<none>") S SPEC("common","order")=ATTR("sort")
 ;
 S SPEC("common","levels")=0
 S POS=0 F  S POS=$O(FIELDS(0,POS)) Q:'POS  D  Q:$G(ERRORS)
 . I FIELDS(0,POS)="<none>",(POS>1) D SETERR^VPRJCD("<none> must be only field name") Q
 . I FIELDS(0,POS)="<none>" Q
 . N COLLATE
 . S COLLATE=$$TRIM^XLFSTR($P(FIELDS(0,POS),"/",2))
 . I '$L(COLLATE) S COLLATE=$S(ATTR("style")="tally":"p",1:"s")
 . S SPEC("common","collate",POS)=COLLATE
 . S SPEC("common","alias",$P($P(FIELDS(0,POS),"/"),"|"))=POS
 . S SPEC("common","levels")=POS
 ;
 S CLTN="" F  S CLTN=$O(CLTNS(CLTN)) Q:CLTN=""  D  Q:$G(ERRORS)
 . S SPEC("collection",CLTN,"method")=ATTR("style")
 . S SPEC("collection",CLTN,"setif")=$G(ATTR("setif"))
 . S SPEC("collection",CLTN,"review")=$G(ATTR("review"))
 . S SPEC("collection",CLTN,"metatype")=$G(ATTR("metatype"))
 . S SPEC("collection",CLTN,"levels")=SPEC("common","levels")
 . S POS=0 F  S POS=$O(FIELDS(0,POS)) Q:'POS  D  Q:$G(ERRORS)
 . . Q:FIELDS(0,POS)="<none>"
 . . I $D(FIELDS(CLTN)),'$D(FIELDS(CLTN,POS)) D  QUIT
 . . . I ATTR("style")="time",(POS=2) Q  ; missing stop time allowed
 . . . ; otherwise error --
 . . . D SETERR^VPRJCD("All fields must be named for collection override.")
 . . N COLLATE,IFNULL,FIELD,FLDSPEC,VALSPEC
 . . S COLLATE=$$TRIM^XLFSTR($P(FIELDS(0,POS),"/",2))
 . . S IFNULL=$$TRIM^XLFSTR($P(FIELDS(0,POS),"/",3))
 . . I '$L(COLLATE) S COLLATE=$S(ATTR("style")="tally":"p",1:"s")
 . . S SPEC("collection",CLTN,POS,"collate")=SPEC("common","collate",POS)
 . . S SPEC("collection",CLTN,POS,"ifNull")=IFNULL
 . . S FIELD=$P($G(FIELDS(CLTN,POS)),"/") S:'$L(FIELD) FIELD=$P(FIELDS(0,POS),"/")
 . . I '$L(FIELD) D SETERR^VPRJCD("Bad field name.") Q
 . . F FLDNUM=1:1:$L(FIELD,"|") D  ; allow multiple fields in the same position
 . . . D FLDSPEC^VPRJCD($P(FIELD,"|",FLDNUM),.FLDSPEC,"src")
 . . . S SPEC("collection",CLTN,POS,"merge")=FLDSPEC("merge") K FLDSPEC("merge")
 . . . M SPEC("collection",CLTN,POS,FLDNUM)=FLDSPEC
 . . ;
 . . ; if multiple fields, everything will be based on the value of the LAST field
 . . ; move merge "up" a subscript -- kind of jury-rigged at the moment
 . . D VALSPEC^VPRJCD(POS,+$G(FLDSPEC("srcArrays")),.VALSPEC)
 . . M SPEC("collection",CLTN,POS)=VALSPEC
 . . ;
 . . ; default 0 means no arrays in this field spec
 . . ; if there were arrays, 1 means instance path previously used
 . . ;                       2 means new instance path
 . . S COMBINE=0                                           ;all fwd
 . . I $L(FLDSPEC("srcArrayPath")) D
 . . . I $D(USED(FLDSPEC("srcArrayPath"))) S COMBINE=1 I 1 ;same instance
 . . . E  S USED(FLDSPEC("srcArrayPath"))="",COMBINE=2     ;combine
 . . S SPEC("collection",CLTN,POS,"combine")=COMBINE
 Q
COMBINE(PATH,USED) ; Return method for combining with previous values
 ; 0: no change in instance, bring all preceding forward
 ; 1: bring only same instance forward
 ; 2: bring foward all instances and combine with this new one
 ; 3: bring foward same instance parent and combine with this one
 Q:'$L(PATH) 0
 Q:$D(USED(PATH)) 1
 ;
 N X,LEN,SAME
 S SAME=1
 S X="" F  S X=$O(USED(X)) Q:X=""  D  Q:'SAME
 . S LEN=$S($L(PATH)>$L(X):$L(X),1:$L(PATH))
 . S SAME=($E(PATH,1,LEN)=$E(X,1,LEN))
 S USED(PATH)=""
 Q $S(SAME:3,1:2)
 ;
LINKSPEC(CLTNS,FIELDS,ATTR,SPEC) ; build .SPEC info for link relationship
 ;.CLTNS(CLTN)="" ;set of collections
 ;.FIELDS(CLTN,1)=field specifier ;{target>}source{;template} 
 ;.ATTR(name)=value ;attributes (like rev field name) for the relationship
 ;.SPEC("common","rel")=relName ; relation (link) name
 ;.SPEC("common","rev")=fldName ; name of field to add for reverse links
 ;.SPEC("collection",collection,1,1,"srcXXX",...)=source field specification
 ;.SPEC("collection",collection,1,"tgtXXX",...)=target field specification
 ;.SPEC("collection",collection,1,"valXXX",...)=values array specification
 ;
 ; note: 3rd subscript is "position", always 1 for links
 ;       subscript preceding "srcXXX" is field number, always 1 for links
 ;
 ; Assignment Methods:  0: x=a  1: x[].y=a[].b  2: x[].y[].z=a[].b[].c
 ;                     99: all others
 ;
 N CLTN,FIELD
 S SPEC("common","rel")=ATTR("name")
 I $L($G(ATTR("rev"))) D
 . S SPEC("common","rev")=$P(ATTR("rev"),";")
 . S SPEC("common","revTemplate")=$P(ATTR("rev"),";",2)
 S CLTN="" F  S CLTN=$O(CLTNS(CLTN)) Q:CLTN=""  D
 . S FIELD=$G(FIELDS(CLTN,1)) S:'$L(FIELD) FIELD=$G(FIELDS(0,1))
 . I '$L(FIELD) D SETERR^VPRJCD("Missing field ref for collection: "_CLTN) Q
 . ;
 . N SRCFLD,SRCSPEC,TGTFLD,TGTSPEC,VALSPEC,ERRORS
 . S TGTFLD=$P(FIELD,">"),SRCFLD=$P(FIELD,">",2)
 . I '$L(SRCFLD) S SRCFLD=TGTFLD
 . D FLDSPEC^VPRJCD(SRCFLD,.SRCSPEC,"src") Q:$G(ERRORS)
 . M SPEC("collection",CLTN,1,1)=SRCSPEC
 . D FLDSPEC^VPRJCD(TGTFLD,.TGTSPEC,"tgt") Q:$G(ERRORS)
 . ; override method from TGTSPEC since if it differs from SRCSPEC
 . I TGTSPEC("tgtMethod")'=SRCSPEC("srcMethod") S TGTSPEC("tgtMethod")=99
 . M SPEC("collection",CLTN,1)=TGTSPEC
 . D VALSPEC^VPRJCD(1,+$G(SRCSPEC("srcArrays")),.VALSPEC)
 . M SPEC("collection",CLTN,1)=VALSPEC
 . S SPEC("collection",CLTN,"metatype")=ATTR("metatype")
 Q
TLTSPEC(CLTNS,FIELDS,ATTR,SPEC) ; build .SPEC info for template
 ;.CLTNS(CLTN)=""                 ;set of collections
 ;.FIELDS(CLTN,#)=field specifier ;{target=}source, may include [qualifiers] and/or * 
 ;.ATTR(name)=value               ;attributes (exclude, applyOn)
 ;.SPEC("common","applyOn")=S|Q   ; applyOnSave or applyOnQuery
 ;.SPEC("common","exclude")=1     ; true if this is an exclude template
 ;.SPEC("collection",collection,0,"applyOn")=Q for query, S for save
 ;.SPEC("collection",collection,0,"exclude")=1 if excluding fields
 ;.SPEC("collection",collection,0,"instance",srcFld,"srcXXX",...)=instance specification
 ;.SPEC("collection",collection,tgtFld,"srcXXX",...)=source field specification
 ;.SPEC("collection",collection,tgtFld,"tgtXXX",...)=target field specification
 ;.SPEC("collection",collection,tdtFld,"valXXX",...)=values array specification
 ;
 N CLTN
 S SPEC("common","applyOn")=$G(ATTR("applyOn"),"Q")
 S SPEC("common","exclude")=$G(ATTR("exclude"),0)
 S CLTN="" F  S CLTN=$O(CLTNS(CLTN)) Q:CLTN=""  D  Q:$G(ERRORS)
 . S SPEC("collection",CLTN,0,"applyOn")=SPEC("common","applyOn")
 . S SPEC("collection",CLTN,0,"exclude")=SPEC("common","exclude")
 . N FLD,ALLFLDS,INST
 . S FLD="" F  S FLD=$O(FIELDS(0,FLD)) Q:FLD=""  S ALLFLDS(FLD)=FIELDS(0,FLD)
 . S FLD="" F  S FLD=$O(FIELDS(CLTN,FLD)) Q:FLD=""  S ALLFLDS(FLD)=FIELDS(CLTN,FLD)
 . S FLD="" F  S FLD=$O(ALLFLDS(FLD)) Q:FLD=""  D
 . . N SRCFLD,SRCSPEC,TGTFLD,TGTSPEC,DELIM
 . . S DELIM=$S(ALLFLDS(FLD)[">"&(ALLFLDS(FLD)'["<none>"):">",1:"=")
 . . S TGTFLD=$P(ALLFLDS(FLD),DELIM)
 . . S SRCFLD=$P(ALLFLDS(FLD),DELIM,2)
 . . I '$L(SRCFLD) S SRCFLD=TGTFLD
 . . I SRCFLD="<none>" Q
 . . D FLDSPEC^VPRJCD(SRCFLD,.SRCSPEC,"src") Q:$G(ERRORS)
 . . D FLDSPEC^VPRJCD(TGTFLD,.TGTSPEC,"tgt") Q:$G(ERRORS)
 . . D CHKARYS(.SRCSPEC,.TGTSPEC) Q:$G(ERRORS)
 . . M SPEC("collection",CLTN,FLD)=SRCSPEC
 . . M SPEC("collection",CLTN,FLD)=TGTSPEC
 . . S SPEC("collection",CLTN,FLD,"addType")=$S(DELIM=">":2,1:+$G(SRCSPEC("merge")))
 . . S SPEC("collection",CLTN,FLD,"assign")=$$GETMTHD(SRCFLD,TGTFLD,DELIM)
 . . I SPEC("collection",CLTN,0,"exclude") D
 . . . I ",0,20,21,"'[(","_SPEC("collection",CLTN,FLD,"assign")_",") Q
 . . . I $P($P(TGTFLD,"[",2),"]")'="" Q
 . . . S SPEC("collection",CLTN,FLD,"assign")=80 ; top level delete
 . . I $L($G(SRCSPEC("srcInstancePath"))) S INST(SRCSPEC("srcInstancePath"))=""
 . ; after build spec for each field, do spec for any instance paths
 . S FLD="" F  S FLD=$O(INST(FLD)) Q:'$L(FLD)  D
 . . N INSTSPEC
 . . D FLDSPEC^VPRJCD(FLD,.INSTSPEC,"src") Q:$G(ERRORS)
 . . S INSTSPEC("srcMethod")=$$GETMTHD^VPRJCD(FLD,1) ; special case for instances
 . . M SPEC("collection",CLTN,0,"instance",INSTSPEC("srcArrayPath"))=INSTSPEC
 Q
CHKARYS(SRC,TGT) ; check array assignments and set error if necessary
 N TGTCNT,SRCCNT
 S TGTCNT=+$G(TGT("tgtArrays"))
 S SRCCNT=+$G(SRC("srcArrays"))
 I TGTCNT>SRCCNT D SETERR^VPRJCD("too many arrays in target: "_TGT("tgtPath")) Q
 I TGTCNT=0,(SRCCNT>0) D
 . N I S I=0
 . F  S I=$O(SRC("srcArrays",I)) Q:'I  D
 . . I SRC("srcArrays",I,"max")=1 Q
 . . I $L(SRC("srcArrays",I,"collect")) Q
 . . D SETERR^VPRJCD("can't assign array to single value: "_SRC("srcPath"))
 Q
GETMTHD(SRC,TGT,DELIM) ; return method based on source and target fields
 N SRCPAT,TGTPAT
 S SRCPAT=$$GETPTRN(SRC),TGTPAT=$$GETPTRN(TGT)
 I SRCPAT="N",(TGTPAT="N") Q $S($G(DELIM)=">":30,1:0)
 I SRCPAT="AN",(TGTPAT="AN") Q 1
 I SRCPAT="AAN",(TGTPAT="AAN") Q 2
 I SRCPAT="#N",(TGTPAT="N") Q 10
 I SRCPAT="#N",((TGTPAT="#N")!(TGTPAT="AN")) Q 11
 I SRCPAT="#M",((TGTPAT="N")!(TGTPAT="NM")) Q 12
 I SRCPAT="NM",((TGTPAT="N")!(TGTPAT="NM")) Q 20
 I SRCPAT="AM",((TGTPAT="A")!(TGTPAT="AM")) Q 21
 I SRCPAT="AAM",((TGTPAT="AA")!(TGTPAT="AAM")) Q 22
 I SRCPAT="AN",(TGTPAT="A"),($G(DELIM)=">") Q 31
 I SRCPAT="*N",(TGTPAT="N") Q 50
 Q 99
 ;
GETPTRN(FLD) ; return pattern for field
 N PATTERN,NAME,ARRAY,I
 S PATTERN=""
 F I=1:1:$L(FLD,".") D
 . S NAME=$P($P(FLD,".",I),"[")
 . S ARRAY=$P($P(FLD,".",I),"[",2)
 . I '$L(ARRAY) S PATTERN=PATTERN_$S(NAME="*":"M",1:"N") Q
 . I ARRAY="]" S PATTERN=PATTERN_"A" Q
 . I $E(ARRAY)="#" S PATTERN=PATTERN_"#" Q
 . I $E(ARRAY)="*" S PATTERN=PATTERN_"*" Q
 . I +ARRAY S PATTERN=PATTERN_"A" Q
 . S PATTERN=PATTERN_"?"
 Q PATTERN
 ;

VPRJCF^INT^1^63294;58829^0
VPRJCF ;SLC/KCM -- query filter
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; EVALAND is always called first since the default is to 'and'
 ; clauses together, so ERROR is newed in EVALAND.
 ;
EVALAND(CLAUSES,UID) ; evaluate object at UID against filter
 ; AND -- return true if ALL clauses are true
 N SEQ,RESULT,CLAUSE,ERROR
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:'RESULT  K CLAUSE
 Q RESULT
 ;
EVALOR(CLAUSES,UID) ; evaluate object at UID against filter
 ; OR -- return true if ANY clause is true
 N SEQ,RESULT,CLAUSE
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:RESULT  K CLAUSE
 Q RESULT
 ;
EVALNOT(CLAUSES,UID) ; evaluate object at UID against filter
 ; NOT -- return true if none of the clauses are true
 N SEQ,RESULT,CLAUSE
 S SEQ=0,RESULT=1 ;default true in case there are no clauses to evaluate
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S RESULT=$$EVALEXPR(.CLAUSE,UID) Q:RESULT  K CLAUSE
 Q 'RESULT
 ;
EVALEXPR(CLAUSE,UID) ; evaluate expression in a clause
 ; handle conjunctions / disjunctions
 I CLAUSE="and" Q $$EVALAND(.CLAUSE,UID)
 I CLAUSE="or" Q $$EVALOR(.CLAUSE,UID)
 I CLAUSE="not" Q $$EVALNOT(.CLAUSE,UID)
 ;
 I $G(HTTPREQ("store"))="data" G EVALEXJD ; jump to different for non-patient globals
 I $G(HTTPREQ("store"))="xvpr" N PID S PID=$O(^VPRPTJ("KEY",UID,""))
 ;
 ; get the value or values to be evaluated & go to appropriate evaluator
 N VALUE
 ; case TYPE begin
 I CLAUSE("type")=1 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("field"))) Q $$EVALONE
 I CLAUSE("type")=2 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("field"),CLAUSE("sub"))) Q $$EVALONE
 N INST,RSLT
 S INST="",RSLT=0
 ; return try if -any- of the values evaluate to true
 F  S INST=$O(^VPRPT(PID,UID,CLAUSE("mult"),INST)) Q:'INST  D  Q:RSLT
 . I CLAUSE("type")=3 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("mult"),INST,CLAUSE("field"))) S RSLT=$$EVALONE Q
 . I CLAUSE("type")=4 S VALUE=$G(^VPRPT(PID,UID,CLAUSE("mult"),INST,CLAUSE("field"),CLAUSE("sub"))) S RSLT=$$EVALONE Q
 Q RSLT
 ;
EVALEXJD ; come here to evaluate non-patient data
 ; get the value or values to be evaluated & go to appropriate evaluator
 N VALUE
 ; case TYPE begin
 I CLAUSE("type")=1 S VALUE=$G(^VPRJD(UID,CLAUSE("field"))) Q $$EVALONE
 I CLAUSE("type")=2 S VALUE=$G(^VPRJD(UID,CLAUSE("field"),CLAUSE("sub"))) Q $$EVALONE
 N INST,RSLT
 S INST="",RSLT=0
 ; return try if -any- of the values evaluate to true
 F  S INST=$O(^VPRJD(UID,CLAUSE("mult"),INST)) Q:'INST  D  Q:RSLT
 . I CLAUSE("type")=3 S VALUE=$G(^VPRJD(UID,CLAUSE("mult"),INST,CLAUSE("field"))) S RSLT=$$EVALONE Q
 . I CLAUSE("type")=4 S VALUE=$G(^VPRJD(UID,CLAUSE("mult"),INST,CLAUSE("field"),CLAUSE("sub"))) S RSLT=$$EVALONE Q
 Q RSLT
 ;
EVALONE() ; perform operation on a single value
 I CLAUSE="eq" Q (VALUE=CLAUSE("value"))
 I CLAUSE="in" Q:'$L(VALUE) 0  Q $D(CLAUSE("list",VALUE))
 I CLAUSE="ne" Q (VALUE'=CLAUSE("value"))
 I CLAUSE="exists" Q (($L(VALUE)>0)=$G(CLAUSE("value"),1))
 I CLAUSE="nin" Q:'$L(VALUE) 0  Q '$D(CLAUSE("list",VALUE))
 ;
 I $L(VALUE),(+VALUE=VALUE),'$D(CLAUSE("asString")) G EVALNUM
EVALSTR ; use ] to evaluate string values
 I CLAUSE="gt" Q (VALUE]CLAUSE("value"))
 I CLAUSE="lt" Q (CLAUSE("value")]VALUE)
 I CLAUSE="gte" Q:VALUE=CLAUSE("value") 1  Q (VALUE]CLAUSE("value"))
 I CLAUSE="lte" Q:VALUE=CLAUSE("value") 1  Q (CLAUSE("value")]VALUE)
 I CLAUSE="between" Q:(CLAUSE("low")]VALUE) 0 Q:(VALUE]CLAUSE("high")) 0 Q 1
 I CLAUSE="like" Q VALUE?@CLAUSE("pattern")
 I CLAUSE="ilike" Q $$LOW^XLFSTR(VALUE)?@CLAUSE("pattern")
 D SETERR(106,"unsupported operator")
 Q 0
 ;
EVALNUM ; use >,< to evaluate numeric values
 I CLAUSE="gt" Q (VALUE>CLAUSE("value"))
 I CLAUSE="lt" Q (VALUE<CLAUSE("value"))
 I CLAUSE="gte" Q (VALUE'<CLAUSE("value"))
 I CLAUSE="lte" Q (VALUE'>CLAUSE("value"))
 I CLAUSE="between" Q:(VALUE<CLAUSE("low")) 0 Q:(VALUE>CLAUSE("high")) 0 Q 1
 D SETERR(106,"unsupported operator")
 Q 0
 ;
 ;
PARSE(IN,OUT) ; parse filter syntax
 ; A:argument,C:conjunction,O:operation,L:list
 N LEVEL,STACK,PTR,TOKEN,ITEM,ERROR
 S LEVEL=1,PTR=1,STACK(LEVEL)=1,STACK(LEVEL,"mode")="O",ERROR=0
 F  Q:PTR>$L(IN)  S TOKEN=$E(IN,PTR) D  Q:ERROR
 . I TOKEN="(" D PUSH("A") Q
 . I TOKEN=")" D POP Q
 . I TOKEN="{" D PUSH("C") Q  ; deprecated -- use paranthesis
 . I TOKEN="}" D POP Q        ; deprecated -- use paranthesis
 . I TOKEN="[" D PUSH("L") Q
 . I TOKEN="]" D POP Q
 . I TOKEN="," S STACK(LEVEL)=STACK(LEVEL)+1,PTR=PTR+1 D LTRIM^VPRJCU(.IN,.PTR) Q
 . I TOKEN=" " S STACK(LEVEL)=STACK(LEVEL)+1,PTR=PTR+1 D LTRIM^VPRJCU(.IN,.PTR) Q
 . S ITEM=$S(TOKEN="""":$$NXTSTRF,1:$$NXTVALF) Q:ERROR  ;increment PTR to next token
 . I '$L(ITEM) D SETERR(106,"empty value") Q
 . I STACK(LEVEL,"mode")="O"!(STACK(LEVEL,"mode")="C") D SETOPER(ITEM) Q
 . I STACK(LEVEL,"mode")="A" D  Q
 . . I STACK(LEVEL)=1 D SETFLD(ITEM) Q
 . . I STACK(LEVEL)=2 D
 . . . I TOKEN="""" S @$$CURREF(LEVEL-1,"asString")=""
 . . . I @$$CURREF(LEVEL-1)="between" S @$$CURREF(LEVEL-1,"low")=ITEM Q
 . . . I @$$CURREF(LEVEL-1)="like" S @$$CURREF(LEVEL-1,"pattern")=$$MAKEPAT(ITEM,0) Q
 . . . I @$$CURREF(LEVEL-1)="ilike" S @$$CURREF(LEVEL-1,"pattern")=$$MAKEPAT(ITEM,1) Q
 . . . I @$$CURREF(LEVEL-1)="exists" S @$$CURREF(LEVEL-1,"value")=$S(ITEM="false":0,1:1) Q
 . . . E  S @$$CURREF(LEVEL-1,"value")=ITEM
 . . I STACK(LEVEL)=3 S @$$CURREF(LEVEL-1,"high")=ITEM
 . I STACK(LEVEL,"mode")="L" S @$$CURREF(LEVEL-2,"list",ITEM)="" Q
 I LEVEL'=1,'ERROR D SETERR(106,"mismatch of braces")
 I '$$CHKOUT(.OUT) Q
 Q
PUSH(MODE) ; new stack level
 I ",or,and,not,"[(","_$G(ITEM)_",") S MODE="C" ; conjunction, otherwise leave as A
 S LEVEL=LEVEL+1,STACK(LEVEL)=1,STACK(LEVEL,"mode")=MODE,PTR=PTR+1
 Q
POP ; remove stack level
 K STACK(LEVEL) S LEVEL=LEVEL-1,PTR=PTR+1
 Q
CURREF(TO,PROP,ITEM) ; Set current global reference based on stack
 N LEVEL,REF
 S REF="",LEVEL=1
 F  Q:LEVEL>TO  S REF=REF_$S(LEVEL=1:"",1:",")_STACK(LEVEL),LEVEL=LEVEL+1
 I $L($G(PROP)) S REF=REF_","""_PROP_""""
 I $L($G(ITEM)) S REF=REF_","""_ITEM_""""
 Q "OUT("_REF_")"
 ;
SETOPER(ITEM) ; Set operation
 S ITEM=$$LOW^XLFSTR(ITEM)
 I ",or,and,not,eq,ne,gt,lt,gte,lte,in,between,like,ilike,exists,nin,"[(","_ITEM_",") S @$$CURREF(LEVEL)=ITEM I 1
 E  D SETERR(106,"unsupported operator")
 Q
SETFLD(FIELD) ; Classify the field into its type and parts
 N PARTS
 ; TODO: consider supporting "_" in names
 ; case begin
 I FIELD?1A.AN D  G XSETFLD
 . S PARTS("type")=1,PARTS("field")=FIELD
 I FIELD?1A.AN1"."1A.AN D  G XSETFLD
 . S PARTS("type")=2,PARTS("field")=$P(FIELD,"."),PARTS("sub")=$P(FIELD,".",2)
 I FIELD?1A.AN1"[]."1A.AN D  G XSETFLD
 . S PARTS("type")=3,PARTS("mult")=$P(FIELD,"[]."),PARTS("field")=$P(FIELD,".",2)
 I FIELD?1A.AN1"[]."1A.AN1"."1A.AN D  G XSETFLD
 . S PARTS("type")=4,PARTS("mult")=$P(FIELD,"[]."),PARTS("field")=$P(FIELD,".",2),PARTS("sub")=$P(FIELD,".",3)
 ; else
 D SETERR(107,"unsupported field type")
 ; case end
XSETFLD ;
 Q:ERROR
 M @$$CURREF(LEVEL-1)=PARTS
 Q
NXTSTRF() ; function returns the next string from IN based on PTR
 ; expects: IN,PTR
 ; may set: ERROR
 N STR
 D NXTSTR^VPRJCU(.IN,.PTR,.STR)
 Q STR
 ;
NXTVALF() ; function returns the next value from IN based on PTR
 ; expects IN,PTR
 N VAL
 D NXTVAL^VPRJCU(.IN,.PTR,.VAL," ,(){}[]")
 Q VAL
 ;
MAKEPAT(MATCH,CI) ; switch LIKE pattern into M pattern match
 I '$L(MATCH) D SETERR(106,"missing LIKE argument") Q ""
 ;
 I $G(CI) S MATCH=$$LOW^XLFSTR(MATCH) ; case insensitive match
 N I,X,LAST,PATTERN
 S PATTERN="",LAST=1
 F  S I=$F(MATCH,"%",LAST) D  Q:'I  Q:I>$L(MATCH)
 . S X=$E(MATCH,LAST,$S(I:I-2,1:$L(MATCH))),LAST=I
 . I $L(X) S PATTERN=PATTERN_"1"""_X_""""
 . I $E(MATCH,I-1)="%" S PATTERN=PATTERN_".E"
 Q PATTERN
 ;
CHKOUT(CLAUSES) ; check the output of parse for errors in initial statement
 N SEQ,OK,CLAUSE
 S SEQ=0,OK=1
 F  S SEQ=$O(CLAUSES(SEQ)) Q:'SEQ  M CLAUSE=CLAUSES(SEQ) S OK=$$CHKONE(.CLAUSE) Q:'OK  K CLAUSE
 Q OK
 ;
CHKONE(CLAUSE) ; check and individual clause for errors
 I ",and,or,not,"[(","_CLAUSE_",")  Q $$CHKOUT(.CLAUSE)
 I ",or,and,not,eq,ne,gt,lt,gte,lte,in,between,like,ilike,exists,nin,"'[(","_CLAUSE_",") D SETERR(106,"unsupported operator") Q 0
 I CLAUSE="between",('$D(CLAUSE("low"))!'$D(CLAUSE("high"))) D SETERR(106,"missing low or high") Q 0
 I (CLAUSE="in"!(CLAUSE="nin")),($D(CLAUSE("list"))'>1) D SETERR(106,"missing list for in operation") Q 0
 I ",eq,ne,gt,lt,gte,lte,"[(","_CLAUSE_","),'$D(CLAUSE("value")) D SETERR(106,"missing value") Q 0
 I (CLAUSE="like"!(CLAUSE="ilike")),'$D(CLAUSE("pattern")) D SETERR(106,"missing like pattern") Q 0
 I '$D(CLAUSE("field")) D SETERR(106,"missing field") Q 0
 I CLAUSE("type")=2,'$D(CLAUSE("sub")) D SETERR(106,"missing sub-field") Q 0
 I CLAUSE("type")=3,'$D(CLAUSE("mult")) D SETERR(106,"missing multiple") Q 0
 I CLAUSE("type")=4,('$D(CLAUSE("mult"))!'$D(CLAUSE("sub"))) D SETERR(106,"incomplete field name") Q 0
 Q 1
 ;
SETERR(ERR,MSG) ; set error state
 S ERROR=ERR
 D SETERROR^VPRJRER(ERR,$G(MSG))
 Q

VPRJCO^INT^1^63294;58829^0
VPRJCO ;SLC/KCM -- Common Utilities for handling sorting (order parameter)
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETORDER(ORDER) ; set up the order subscripts
 ; expects INDEX for /index/indexname queries, otherwise INDEX undefined
 ; expects TEMPLATE (may be empty)
 ; INDEX, if defined, is from ^VPRMETA("index",name,"common")
 ; returns:
 ;   ORDER(0)=#                ; sort levels
 ;   ORDER(#)=#|name           ; level # or field name
 ;   ORDER(#,"dir")=1 or -1    ; asc or desc
 ;   ; if the field is not part of the subscripts
 ;   ORDER(#,0,fieldSpecInfo)
 ;   ORDER(#,collection,fieldSpecInfo)
 ;   ORDER(#,"ftype")=1|2|3|4  ; field name structure
 ;   ORDER(#,"field")=name     ; field name
 ;   ORDER(#,"mult")=name      ; multiple name
 ;   ORDER(#,"sub")=name       ; subfield name
 ;   ORDER(#,"instance")=level ; which field to use for multiple instance
 ;
 N I,X,F,D,S                             ; F=field, D=direction
 S S=0                                   ; S=number of sort levels
 S X=$$LOW^XLFSTR($$TRIM^XLFSTR(ORDER))  ; if only "asc" or "desc" passed
 I X="asc"!(X="desc") S ORDER=$P($G(INDEX("order"))," ")_" "_X
 S X=$P(ORDER," ")
 I X="asc"!(X="desc") D SETERROR^VPRJRER(110) Q  ; missing order field
 I '$L(ORDER) S ORDER=$G(INDEX("order")) ; use default if no ORDER parameter
 I '$L(ORDER) S ORDER(0)=0 Q             ; no sorting
 ; loop through the sorting levels (delimited by commas)
 F I=1:1:$L(ORDER,",") S X=$$TRIM^XLFSTR($P(ORDER,",",I)) Q:'$L(X)  D  Q:$G(HTTPERR)
 . S S=S+1
 . S F=$$TRIM^XLFSTR($P(X," "))
 . S D=$$LOW^XLFSTR($$TRIM^XLFSTR($P(X," ",2))) S:'$L(D) D="asc"
 . ; if sorting on something already in the index, use the index value
 . S ORDER(I)=$S($D(INDEX("alias",F)):INDEX("alias",F),1:F)
 . I +ORDER(I),$G(INDEX("collate",ORDER(I)))="V" S D=$S(D="asc":"desc",1:"asc")
 . S ORDER(I,"dir")=$S(D="desc":-1,1:1)
 . Q:+ORDER(I)
 . I F["[" D SETERROR^VPRJRER(109,F) Q  ; arrays have to be indexed for sorting
 . N SPEC
 . D FLDSPEC^VPRJCD(F,.SPEC,$S(HTTPREQ("store")="data":"data",1:"vpr"))
 . M ORDER(I,0)=SPEC
 . Q:'$L(TEMPLATE)
 . ; TODO: iterate through template aliases and build a spec for each collection
 S ORDER(0)=S
 Q
 ;

VPRJCR^INT^1^63294;58829^0
VPRJCR ;SLC/KCM -- Parse values from range parameter
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PARSERNG ; Parse range value
 ; expects: INDEX, RANGE
 ; updates: START, STOP, DIR
 ; returned structures:
 ;   START(level)=beginning of range    ;defaults to ""
 ;   START(level,#)="value"             ;for comma delimited range
 ;   START(level,"collation")=V|S|s...  ;"L" for list
 ;   STOP(level)=end of range           ;defaults to $C(255)
 ;   DIR(level)=1                       ;direction to traverse subscript
 ;
 ; @see unit test in PARSERNG^VPRJTQX
 N I,CLTN,RANGES
 D XRANGES(.RANGE,.RANGES)
 F I=1:1:INDEX("levels") D
 . N TMPSTRT,TMPSTOP
 . S CLTN=INDEX("collate",I) S:'$L(CLTN) CLTN="P"
 . D RNG2VAL(.RANGES,I,.TMPSTRT,.TMPSTOP,CLTN)
 . M START(I)=TMPSTRT,STOP(I)=TMPSTOP
 . S START(I,"collate")=CLTN,DIR(I)=1
 . I $D(START(I,"list")) S START(I,"collate")="L"
 Q
XRANGES(RANGE,RANGES) ; extract values for each level by parsing RANGE
 ; returns
 ; .RANGES(level,#)     :  string or value for each item in a specific range
 ; .RANGES(level,"type"):  R if a range or L if a list of items
 ; .RANGES(level,"ends"):  inclusive/exclusive endpoints for range
 N TOKEN,LEVEL,IDX,ITEM,S,ERROR
 S LEVEL=0,IDX=1,ERROR=0
 D NEWLVL
 F  Q:IDX>$L(RANGE)  S TOKEN=$E(RANGE,IDX) D  Q:ERROR
 . I TOKEN=">" D NEWLVL S IDX=IDX+1 Q
 . I TOKEN="," S RANGES(LEVEL,"type")="L",IDX=IDX+1 Q
 . I TOKEN=".",($E(RANGE,IDX+1)=".") S RANGES(LEVEL,"type")="R",IDX=IDX+2 Q
 . I TOKEN="[" S:ITEM>1 $E(RANGES(LEVEL,"ends"),2)=")" S IDX=IDX+1 Q
 . I TOKEN="]" S:ITEM=1 $E(RANGES(LEVEL,"ends"),1)="(" S IDX=IDX+1 Q
 . I TOKEN="*" S $E(RANGES(LEVEL,"ends"),2)="*" S IDX=IDX+1 Q
 . I TOKEN="""" D NXTSTR^VPRJCU(.RANGE,.IDX,.S) S RANGES(LEVEL,ITEM)=S,ITEM=ITEM+1 Q
 . I TOKEN="'" D NXTSTR^VPRJCU(.RANGE,.IDX,.S,"'") S RANGES(LEVEL,ITEM)=S,ITEM=ITEM+1 Q
 . ;otherwise
 . D NXTVAL^VPRJCU(.RANGE,.IDX,.S,",>.[]()*") S RANGES(LEVEL,ITEM)=S,ITEM=ITEM+1
 Q
NEWLVL ; initializes new level in RANGES
 ;expects: RANGE,LEVEL  from: PRNG
 S LEVEL=LEVEL+1,ITEM=1
 S RANGES(LEVEL,"type")="R"
 S RANGES(LEVEL,"ends")="[]"
 Q
RNG2VAL(RANGES,LEVEL,START,STOP,CTYPE) ; Parse start and stop from range
 ;@see unit tests in RNG2VAL^VPRJTQU and RNG2VAL2^VPRJTQU
 ;RANGE is a single ">" part of the range parameter
 ; .START              start value modified for $O
 ; .START("list",item) list of items if range is comma delimited
 ; .STOP               stop value modified for $O
 ; 
 S START="",STOP=$C(255,255,255)
 I '$D(RANGES(LEVEL,1)) Q
 I $A(CTYPE)>96 D   ; lowercase for case-insensitive
 . N I S I=0
 . F  S I=$O(RANGES(LEVEL,I)) Q:'I  S RANGES(LEVEL,I)=$$LOW^XLFSTR(RANGES(LEVEL,I))
 S CTYPE=$$UP^XLFSTR(CTYPE)
 I RANGES(LEVEL,"type")="L" D  Q  ; build list of search items and return
 . N I,S
 . S I=0 F  S I=$O(RANGES(LEVEL,I)) Q:'I  D
 . . S S=$$TRIM^XLFSTR(RANGES(LEVEL,I))
 . . I CTYPE="V" S S=S_"="
 . . I CTYPE="T" S S=S_" "
 . . I CTYPE="S"!(CTYPE="s") S S=S_" "
 . . I CTYPE="N" S S=+S
 . . S START("list",S)=""
 ;
 N ENDPOINT,NUMERIC,X
 ; figure out the endpoints (include, exclusive, startswith)
 S ENDPOINT=RANGES(LEVEL,"ends")
 ; get start, stop and make sure stop is after start
 S START=$G(RANGES(LEVEL,1)),STOP=$G(RANGES(LEVEL,2)),NUMERIC=$$NUMERIC^VPRJSONE(START)
 I STOP="" S STOP=START
 I (NUMERIC&(START>STOP))!('NUMERIC&(START]STOP)) S X=STOP,STOP=START,START=X
 ;
 ; adjust start/stop for String and Time indexes
 I (CTYPE="S")!(CTYPE="T") D  Q
 . I ENDPOINT["[",+START,(CTYPE="S"),(+START=START) S START=$$ADJSTR(START,"-")
 . I ENDPOINT["(" S START=START_" "
 . I ENDPOINT["*" S STOP=STOP_$C(255)
 . I ENDPOINT["]" S STOP=STOP_" "
 . I ENDPOINT[")",+STOP,(CTYPE="S"),(+STOP=STOP) S STOP=$$ADJSTR(STOP,"-")
 ; adjust start/stop for Inverse Time index
 I CTYPE="V" D  Q
 . ; get complement for each time and swap the times
 . S START=$TR(START,"0123456789","9876543210"),STOP=$TR(STOP,"0123456789","9876543210")
 . S X=STOP,STOP=START,START=X
 . I ENDPOINT["[" S STOP=STOP_"="
 . I ENDPOINT["(" S STOP=STOP_":"
 . I ENDPOINT["*" S START=START_" "
 . I ENDPOINT["]" S START=START_":"
 . I ENDPOINT[")" S START=START_"="
 ; adjust start/stop for Numeric index
 I CTYPE="N" D  Q
 . I ENDPOINT["[" S START=$$ADJNUM(START,"-")
 . I ENDPOINT[")" S STOP=$$ADJNUM(STOP,"-")
 Q
ADJNUM(N,SIGN) ; adjusted a number in a positive or negative direction
 ;@see unit test in ADJNUM^VPRJTQU
 I N'=+N Q N              ; not a number, leave it as is
 N P S P=$L($P(N,".",2))  ; get precision
 N D S D=$S('P:1,1:"."_$E("000000000000000",1,P-1)_"1")
 S D=$S($G(SIGN)="-":-D,1:D)
 Q N+D
 ;
ADJSTR(S,SIGN) ; bump a string ahead or behind in collation sequence
 ;@see unit test in ADJSTR^VPRJTQU
 I S="" Q S
 I $G(SIGN)="-" S $E(S,$L(S))=$C($A($E(S,$L(S)))-1),S=S_$C(255) Q S
 Q S_$C(255)
 ;

VPRJCRC^INT^1^63294;58829^0
VPRJCRC ;SLC/AGP -- Calculate Checksum values
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 Q
ALL() ;
 Q "problem;allergy;consult;vital;lab;procedure;obs;order;treatment;med;ptf;factor;immunization;exam;cpt;education;pov;skin;image;appointment;surgery;document;visit;mh"
 ;
ATTR(X) ; -- return list of attributes needed for collection X
 N Y S Y=""
 I X="vital"        S Y="^observed^typeName^result^"
 I X="problem"      S Y="^onset^problemText^statusName^"
 I X="allergy"      S Y="^entered^summary^"
 I X="order"        S Y="^start^name^statusName^"
 I X="treatment"    S Y="^start^name^statusName^"
 I X="med"          S Y="^overallstart^name^vaStatus^"
 I X="consult"      S Y="^startDate^typeName^statusName^"
 I X="procedure"    S Y="^dateTime^name^statusName^"
 I X="obs"          S Y="^observed^typeName^result^"
 I X="lab"          S Y="^observed^typeName^"
 I X="image"        S Y="^dateTime^name^statusName^"
 I X="surgery"      S Y="^dateTime^typeName^statusName^"
 I X="document"     S Y="^referenceDateTime^localTitle^statusName^"
 I X="mh"           S Y="^administeredDateTime^name^"
 I X="immunization" S Y="^administeredDateTime^name^"
 I X="pov"          S Y="^entered^name^"
 I X="skin"         S Y="^entered^name^result^"
 I X="exam"         S Y="^entered^name^result^"
 I X="cpt"          S Y="^entered^name^"
 I X="education"    S Y="^entered^name^result^"
 I X="factor"       S Y="^entered^name^"
 I X="appointment"  S Y="^dateTime^typeName^appointmentStatus^"
 I X="visit"        S Y="^dateTime^typeName^"
 I X="ptf"          S Y="^arrivalDateTime^icdCode^"
 Q Y
 ;
CRC(FLDVAL,CRC) ;
 S CRC=$$CRC32^XLFCRC(FLDVAL,CRC)
 Q
 ;
DATA(PID,UID,DOMAIN,ARRAY,CRC) ;
 N FIELD,VALUE
 S FIELD="" F  S FIELD=$O(ARRAY(DOMAIN,FIELD)) Q:FIELD=""  D
 . I $D(^VPRPT(PID,UID,FIELD)) S VALUE=$G(^VPRPT(PID,UID,FIELD)) D CRC(FIELD_":"_VALUE,.CRC)
 Q
 ;
PATCRC(DOMARRY) ;
 N CRC,DOM,VALUE
 S CRC=0,DOM=""
 F  S DOM=$O(DOMARRY(DOM)) Q:DOM=""  D CRC(DOM_":"_DOMARRY(DOM),.CRC)
 Q CRC
 ;
EN(RESULT,SYS,PID) ;
 N ARRAY,CNT,CRC,DOMARRY,ERROR,FIELDS,TEMP,TYPE,U,UID,UIDCRC,VPRP,VPRTYPE
 S U="^"
 S VPRTYPE=$$ALL
 F VPRP=1:1:$L(VPRTYPE,";") S TYPE=$P(VPRTYPE,";",VPRP) I $L(TYPE) D
 .S ARRAY(TYPE)=""
 .S FIELDS=$$ATTR(TYPE)
 .S NUM=$L(FIELDS,U)
 .S FCNT=0
 .F X=1:1:NUM D
 ..I $P(FIELDS,U,X)="" Q
 ..S ARRAY(TYPE,$P(FIELDS,U,X))=""
 ;D ENCODE^VPRJSON("ARRAY","TEST","ERROR")
 S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:UID=""  D
 .I $P(UID,":",4)'=SYS Q
 .S DOMAIN=$P(UID,":",3),UIDCRC="" I '$D(ARRAY(DOMAIN)) Q
 .D DATA(PID,UID,DOMAIN,.ARRAY,.UIDCRC)
 .S DOMARRY(DOMAIN,UID)=UIDCRC
 D CALDOM(.DOMARRY)
 S DOMARRY("patient")=$$PATCRC(.DOMARRY)
 ;M RESULT=DOMARRY
 D PREP(.DOMARRY,.TEMP)
 D ENCODE^VPRJSON("TEMP","RESULT","ERROR")
 Q
 ;
CALDOM(DOMARRY) ;
 N CRC,TYPE,UID,VALUE
 S TYPE="" F  S TYPE=$O(DOMARRY(TYPE)) Q:TYPE=""  D
 .S CRC=0,UID="" F  S UID=$O(DOMARRY(TYPE,UID)) Q:UID=""  D
 ..S VALUE=DOMARRY(TYPE,UID) D CRC(UID_":"_VALUE,.CRC)
 ..S DOMARRY(TYPE)=CRC
 Q
 ;
PREP(DOMARRY,TEMP) ;
 N DCNT,DOMAIN,UID,UCNT
 S DOMAIN="",DCNT=0
 F  S DOMAIN=$O(DOMARRY(DOMAIN)) Q:DOMAIN=""  D
 .S TEMP(DOMAIN,"crc")=DOMARRY(DOMAIN)
 .S UCNT=0,UID="" F  S UID=$O(DOMARRY(DOMAIN,UID)) Q:UID=""  D
 ..S UCNT=UCNT+1,TEMP(DOMAIN,"uids",UCNT,UID)=DOMARRY(DOMAIN,UID)
 ..;S TEMP(DOMAIN,"uids",UCNT,"uid")=UID,TEMP(DOMAIN,"uids",UCNT,"crc")=DOMARRY(DOMAIN,UID)
 Q
 ;
TEST(TEST) ;
 N FIELDS,NUM,FCNT,VPRTYPE,VPRP
 K ARRAY,TEST
 S VPRTYPE=$$ALL
 F VPRP=1:1:$L(VPRTYPE,";") S TYPE=$P(VPRTYPE,";",VPRP) I $L(TYPE) D
 .S ARRAY(TYPE)=""
 .S FIELDS=$$ATTR(TYPE)
 .S NUM=$L(FIELDS,U)
 .S FCNT=0
 .F X=1:1:NUM D
 ..I $P(FIELDS,U,X)="" Q
 ..S FCNT=FCNT+1,ARRAY(TYPE,"fields",FCNT,$P(FIELDS,U,X))=""
 D ENCODE^VPRJSON("ARRAY","TEST","ERROR")
 Q

VPRJCT^INT^1^63294;58829^0
VPRJCT ;SLC/KCM -- Apply Templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
APPLY(SPEC,OBJECT,JSON,INST) ; Apply template to object resulting in .JSON
 ;.SPEC:   the spec for this template (at the collection level)   
 ;.OBJECT: object
 ;.JSON:   the returned JSON object
 ; INST:   the combined instance string for this template
 N TARGET,TINST,FLD,JSONERR
 I $D(SPEC)<10 D SETERROR^VPRJRER(105,SPEC) Q
 I $L($G(INST)) D EXPINST^VPRJCU(INST,.TINST)
 I SPEC(0,"exclude") D  ; exclude fields
 . M TARGET=OBJECT
 . S FLD=0 F  S FLD=$O(SPEC(FLD)) Q:FLD=""  D DELFLD(FLD)
 E  D                ; include fields
 . S FLD=0 F  S FLD=$O(SPEC(FLD)) Q:FLD=""  D ADDFLD(FLD,.TINST)
 D ENCODE^VPRJSON("TARGET","JSON","JSONERR")
 I $D(JSONERR) D SETERROR^VPRJRER(218,SPEC)
 Q
ADDFLD(LEVEL,TINST) ; Add node to TOBJ based on
 ; NOTE: merge is used for setting values so that the "\s" node is included
 N ASSIGN,SRC
 S ASSIGN=SPEC(LEVEL,"assign")
 I ASSIGN=0  G SETVAL0  ;   set x=a                    n=n
 I ASSIGN=1  G SETVAL1  ;   set x[].y=a[].b            an=an
 I ASSIGN=2  G SETVAL2  ;   set x[].y[].z=a[].b[].c    aan=aan
 ;
 I ASSIGN=10 G SETVAL10 ;   set x=a[#].b               n=#n
 I ASSIGN=11 G SETVAL11 ;   set x[].y=a[#].b           an=#n  or #n=#n
 I ASSIGN=12 G SETVAL12 ; merge x=a[#].*               n=#m   or nm=#m   (n=# +merge)
 ;
 I ASSIGN=20 G SETVAL20 ; merge x=a.*                  n=nm   or nm=nm   (n=n +merge)
 I ASSIGN=21 G SETVAL21 ; merge x[]=a[].*              a=am   or am=am   (a=a +merge)
 I ASSIGN=22 G SETVAL22 ; merge x[].y[]=a[].b[].*      aa=aam or aam=aam (aa=aa +merge)
 ;
 I ASSIGN=30 G SETVAL30 ; expand x>a
 I ASSIGN=31 G SETVAL31 ; expand x[]>a[].b
 ;
 I ASSIGN=50 G SETVAL50 ; collect x from a[].b         n=*n
 ;
 I ASSIGN=70 ; handle query
 I ASSIGN=71 ; handle function
 I ASSIGN=72 ; handle list procedure
 ;
 ;otherwise process recursively
 G SETVALUE
 Q
 ;
SETVAL0 ; set a single value with no arrays
 I '($D(OBJECT(SPEC(LEVEL,"srcPath",1)))#2) QUIT
 M TARGET(SPEC(LEVEL,"tgtPath",1))=OBJECT(SPEC(LEVEL,"srcPath",1))
 Q
SETVAL1 ; set a list of values with optional maximum and direction
 ; accomodates [], [n], [-n]
 N I,C
 S I="",C=0
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1
 . Q:'$L($G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))))
 . M TARGET(SPEC(LEVEL,"tgtPath",1),C,SPEC(LEVEL,"tgtPath",2))=OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))
 Q
SETVAL2 ; set double nested list of values with optional maximum and direction
 N I,J,C,D
 S I="",C=0
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1,J="",D=0
 . F  S J=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2),J),SPEC(LEVEL,"srcArrays",2,"dir")) Q:'J  D  Q:D'<SPEC(LEVEL,"srcArrays",2,"max")
 . . S D=D+1
 . . Q:'$L($G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2),J,SPEC(LEVEL,"srcPath",3))))
 . . M TARGET(SPEC(LEVEL,"tgtPath",1),C,SPEC(LEVEL,"tgtPath",2),D,SPEC(LEVEL,"tgtPath",3))=OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2),J,SPEC(LEVEL,"srcPath",3))
 Q
 ;
SETVAL10 ; set a single value to an instance
 N I
 S I=$G(TINST(SPEC(LEVEL,"srcArrays",1,"path"))) Q:'I
 Q:'$L($G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))))
 M TARGET(SPEC(LEVEL,"tgtPath",1))=OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))
 Q
SETVAL11 ; set a list value to an instance
 N I
 S I=$G(TINST(SPEC(LEVEL,"srcArrays",1,"path"))) Q:'I
 Q:'$L($G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))))
 M TARGET(SPEC(LEVEL,"tgtPath",1),I,SPEC(LEVEL,"tgtPath",2))=OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))
 Q
SETVAL12 ; merge a single value to an instance
 N I S I=$G(TINST(SPEC(LEVEL,"srcArrays",1,"path"))) Q:'I
 M TARGET(SPEC(LEVEL,"tgtPath",1))=OBJECT(SPEC(LEVEL,"srcPath",1),I)
 Q
 ;
SETVAL20 ; merge a single value with no arrays
 M TARGET(SPEC(LEVEL,"tgtPath",1))=OBJECT(SPEC(LEVEL,"srcPath",1))
 Q
SETVAL21 ; merge a list of values with optional maximum and direction
 ; accomodates [], [n], [-n]
 N I,C
 S I="",C=0
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1
 . M TARGET(SPEC(LEVEL,"tgtPath",1),C)=OBJECT(SPEC(LEVEL,"srcPath",1),I)
 Q
SETVAL22 ; set double nested list of values with optional maximum and direction
 N I,J,C,D
 S I="",C=0
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1,J="",D=0
 . F  S J=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2),J),SPEC(LEVEL,"srcArrays",2,"dir")) Q:'J  D  Q:D'<SPEC(LEVEL,"srcArrays",2,"max")
 . . S D=D+1
 . . M TARGET(SPEC(LEVEL,"tgtPath",1),C,SPEC(LEVEL,"tgtPath",2),D)=OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2),J)
 Q
 ;
SETVAL30 ; expand a single value
 N X,JSON
 S X=$G(OBJECT(SPEC(LEVEL,"srcPath",1))) Q:'$L(X)
 D UID2JSN^VPRJCV1(X,.JSON,$G(SPEC(LEVEL,"srcTemplate")))
 M TARGET(SPEC(LEVEL,"tgtPath",1),":")=JSON
 Q
SETVAL31 ; expand a list of values with optional maximum and direction
 ; accomodates [], [n], [-n]
 N I,C,X,JSON
 S I="",C=0
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1
 . S X=$G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2))) Q:'$L(X)
 . D UID2JSN^VPRJCV1(X,.JSON,$G(SPEC(LEVEL,"srcTemplate")))
 . M TARGET(SPEC(LEVEL,"tgtPath",1),C,":")=JSON
 Q
SETVAL50 ; set a collection from a list into a value
 N I,X,C,V
 S I="",C=0,V=""
 F  S I=$O(OBJECT(SPEC(LEVEL,"srcPath",1),I),SPEC(LEVEL,"srcArrays",1,"dir")) Q:'I  D  Q:C'<SPEC(LEVEL,"srcArrays",1,"max")
 . S C=C+1
 . S X=$G(OBJECT(SPEC(LEVEL,"srcPath",1),I,SPEC(LEVEL,"srcPath",2)))
 . I $L(X) S V=V_$S($L(V):SPEC(LEVEL,"srcArrays",1,"collect"),1:"")_X
 I $L(V) S TARGET(SPEC(LEVEL,"tgtPath",1))=V
 Q
 ;
SETVALUE ; set values in TARGET based on SPEC
 N J S J=0
 ; assign top level fields
 I $G(SPEC(LEVEL,"srcArrays"),0)=0 D  Q
 . I SPEC(LEVEL,"addType")=0 G ADDVALUE
 . I SPEC(LEVEL,"addType")=1 G MRGVALUE
 . I SPEC(LEVEL,"addType")=2 G EXPVALUE
 ; otherwise recursively iterate each array position
 N I,C
 D NXTNODE(1)
 Q
NXTNODE(N) ; iterate array at position N
 ; from SETVALSR, NXTNODR
 I SPEC(LEVEL,"srcArrays",N,"dir")=0 D  Q        ; just one instance
 . S I(N)=$G(TINST(SPEC(LEVEL,"srcArrays",N,"path"))) Q:'I(N)
 . D CHKNODE
 ;
 S I(N)="",C(N)=0                                ; multiple instances 
 F  S I(N)=$O(@SPEC(LEVEL,"srcArrays",N,"ref"),SPEC(LEVEL,"srcArrays",N,"dir")) Q:'I(N)  D  Q:C(N)'<SPEC(LEVEL,"srcArrays",N,"max")
 . S C(N)=C(N)+1
 . D CHKNODE
 Q
CHKNODE ; recurse to next position if not last
 I N<SPEC(LEVEL,"srcArrays") D NXTNODE(N+1) Q    ; recurse to next array position
 I SPEC(LEVEL,"addType")=0 G ADDVALUE
 I SPEC(LEVEL,"addType")=1 G MRGVALUE
 I SPEC(LEVEL,"addType")=2 G EXPVALUE
 Q
ADDVALUE ; add single value if last position
 S J=J+1                                         ; J used for last array position (if any)
 N VALUE                                         ; otherwise assign value
 M VALUE=@SPEC(LEVEL,"srcRef")
 Q:'$L($G(VALUE))
 ; if collecting, keep appending to value using delimiter stored in "collect" node
 ; N is only present if there are arrays to collect from
 I $G(N),$L(SPEC(LEVEL,"srcArrays",N,"collect")) D
 . N X
 . S X=$G(@SPEC(LEVEL,"tgtRef"))
 . S VALUE=X_$S($L(X):SPEC(LEVEL,"srcArrays",N,"collect"),1:"")_VALUE
 ;
 M @SPEC(LEVEL,"tgtRef")=VALUE                   ; arrays are I(1)..I(N),J
 Q
MRGVALUE ; merge value if last position
 S J=J+1
 M @SPEC(LEVEL,"tgtRef")=@SPEC(LEVEL,"srcRef")
 Q
EXPVALUE ; expand value if last position
 S J=J+1
 N VALUE,JSON
 S VALUE=$G(@SPEC(LEVEL,"srcRef"))
 Q:'$L(VALUE)
 D UID2JSN^VPRJCV1(VALUE,.JSON,$G(SPEC(LEVEL,"srcTemplate")))
 M @SPEC(LEVEL,"tgtRef")@(":")=JSON
 Q
 ;
DELFLD(LEVEL) ; delete fields from TARGET
 I SPEC(LEVEL,"assign")=80 K TARGET(SPEC(LEVEL,"tgtPath",1)) QUIT
 ; kill top level field
 I $G(SPEC(LEVEL,"srcArrays"),0)=0 K @SPEC(LEVEL,"tgtRef") QUIT
 ; otherwise recursively iterate each array position
 N I,C,J
 D NXTNODD(1)
 Q
NXTNODD(N) ; iterate array at position N
 ; from MRGVALSR, NXTNODM
 I SPEC(LEVEL,"srcArrays",N,"dir")=0 D  Q        ; just one instance
 . S I(N)=$G(TINST(SPEC(LEVEL,"srcArrays",N,"path"))) Q:'I(N)
 . D DELVAL
 ;
 S I(N)="",C(N)=0                                ; multiple instances
 F  S I(N)=$O(@SPEC(LEVEL,"srcArrays",N,"ref"),SPEC(LEVEL,"srcArrays",N,"dir")) Q:'I(N)  D  Q:C(N)'<SPEC(LEVEL,"srcArrays",N,"max")
 . S C(N)=C(N)+1
 . D DELVAL
 Q
DELVAL ; delete value if last position, otherwise recurse to next
 I N<SPEC(LEVEL,"srcArrays") D NXTNODD(N+1) Q  ; recurse to next
 S J=I(N) ; incase were at the last level and J is used instead of I(N)
 K @SPEC(LEVEL,"tgtRef")
 Q

VPRJCT1^INT^1^63396;54290^0
VPRJCT1 ;SLC/KCM -- Apply Rel and Rev Templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
RELTLTP(ROOT,KEY,TLT,PID) ; apply rel template for VPR and put in ROOT
 N CTN,OBJECT
 ; TODO: check to see if PID is defined here for xvpr queries
 S CTN=$P(KEY,":",3) M OBJECT=^VPRPT(PID,KEY)
 G RELTLT
 ;
RELTLTD(ROOT,KEY,TLT) ; apply rel template for DATA and put in ROOT
 N CTN,OBJECT
 S CTN=$P(KEY,":",3) M OBJECT=^VPRJD(KEY)
 G RELTLT
 ;
RELTLT ; common entry point for rel template
 ; from: RELTLTP, RELTLTD  expects: CTN, OBJECT
 ; ROOT: closed global reference like ^TMP($J)
 ; ITEM: item or record number
 ; KEY: KEY in the ^VPRPT or ^VPRJD
 ; .TLT: rel,relname
 ; .TLT(collection,...): information for template based on collection
 N SPEC,VALS,ERRS
 M SPEC=TLT("collection",CTN)
 ; just return UID if there is not template defined for this collection
 I '$D(SPEC) S @ROOT@(1)="{""uid"":"""_$G(OBJECT("uid"))_"""}" Q
 D GETVALS^VPRJCV1(.OBJECT,.VALS,.SPEC,1)
 D SETJSON^VPRJCV1(.OBJECT,.VALS,.SPEC,1)
 D ENCODE^VPRJSON("OBJECT",ROOT,"ERRS")
 ; TODO: figure out how to throw an error at this point (writing out response)
 Q
 ;
REVTLTP(ROOT,KEY,TLT,PID) ; add multiple for rev template and put in ROOT
 N OBJECT,REVFLD,REL,UID,CNT
 S REVFLD=TLT("common","rev"),REL=TLT("common","rel"),CNT=0
 ; TODO: check to see if PID is defined here for xvpr queries
 M OBJECT=^VPRPT(PID,KEY)
 S UID="" F  S UID=$O(^VPRPTI(PID,"rev",KEY,REL,UID)) Q:UID=""  D REVTLT
 D ENCODE^VPRJSON("OBJECT",ROOT,"ERRS")
 ; TODO: figure out how to throw an error at this point (writing out response)
 Q
 ;
REVTLTD(ROOT,KEY,TLT) ; apply rev template for DATA and put in ROOT
 N OBJECT,REVFLD,REL,UID,CNT
 S REVFLD=TLT("common","rev"),REL=TLT("common","rel"),CNT=0
 M OBJECT=^VPRJD(KEY)
 S UID="" F  S UID=$O(^VPRJDX("rev",KEY,REL,UID)) Q:UID=""  D REVTLT
 D ENCODE^VPRJSON("OBJECT",ROOT,"ERRS")
 ; TODO: figure out how to throw an error at this point (writing out response)
 Q
 ;
REVTLT ; common entry point for rev template
 ; from: REVTLTP, REVTLTD  expects: CTN, OBJECT
 S CNT=CNT+1
 I $G(TLT("common","revTemplate"))="uid" S OBJECT(REVFLD,CNT,"uid")=UID Q
 ; otherwise apply template
 N JSON
 D UID2JSN^VPRJCV1(UID,.JSON,TLT("common","revTemplate"))
 M OBJECT(REVFLD,CNT,":")=JSON
 Q
 ;
BLDTLT(CLTN,OBJECT,TLTARY) ; Build JSON objects for associated templates
 ; from: ^VPRJDS, ^VPRJPS
 ; CLTN identifies the collection
 ; OBJECT is the decoded JSON object as a MUMPS array
 ; TLTARY is the array of JSON objects that get built based on templates
 N TLTNM,TJSON
 S TLTNM="" F  S TLTNM=$O(^VPRMETA("collection",CLTN,"template",TLTNM)) Q:TLTNM=""  D  Q:$G(HTTPERR)
 . I $D(^VPRMETA("template",TLTNM,"collection",CLTN))<10 D SETERROR^VPRJRER(219,TLTNM) Q
 . I $G(^VPRMETA("template",TLTNM,"common","applyOn"))'="S" Q  ; skip applyOnQuery
 . N SPEC
 . S SPEC=TLTNM
 . M SPEC=^VPRMETA("template",TLTNM,"collection",CLTN)
 . D APPLY^VPRJCT(.SPEC,.OBJECT,.TJSON) Q:$G(HTTPERR)
 . M TLTARY(TLTNM)=TJSON
 Q
QRYTLT(ROOT,KEY,TLT,PID,INST) ; apply template at query time and put in ROOT
 Q
LOADSPEC(TEMPLATE) ; load the specification for a template
 ;  TEMPLATE contains the template name
 ; .TEMPLATE(collection,...): returned information
 Q:TEMPLATE="uid"  ; special case - uid is hard coded template
 N TYPE,NAME,RELTLT
 S TYPE="template",NAME=TEMPLATE
 I $E(TEMPLATE,1,4)="rel;" S TYPE="link",NAME=$P(TEMPLATE,";",2),RELTLT=$P(TEMPLATE,";",3)
 I $E(TEMPLATE,1,4)="rev;" S TYPE="link",NAME=$P(TEMPLATE,";",2),RELTLT=$P(TEMPLATE,";",3)
 I '$D(^VPRMETA(TYPE,NAME)) D SETERROR^VPRJRER(105,NAME) Q
 I TYPE="template",($G(^VPRMETA("template",NAME,"common","applyOn"))'="Q") Q  ; only merge query type
 M TEMPLATE=^VPRMETA(TYPE,NAME)
 I $P(TEMPLATE,";")="rev",'$L($G(TEMPLATE("common","rev"))) D SETERROR^VPRJRER(113,TEMPLATE) Q
 I $L($G(RELTLT)) D
 . I $P(TEMPLATE,";")="rev" S TEMPLATE("common","revTemplate")=RELTLT Q
 . N CTN
 . S CTN="" F  S CTN=$O(TEMPLATE("collection",CTN)) Q:'$L(CTN)  S TEMPLATE("collection",CTN,1,1,"srcTemplate")=RELTLT
 Q

VPRJCU^INT^1^63294;58829^0
VPRJCU ;SLC/KCM -- Common Utilities for Patient and Non-Patient Stores
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
EXPINST(S,INST) ; expand instance string into instance array
 N I,J,X,Y
 F I=1:1:$L(S,"|") S X=$P(S,"|",I) F J=1:1:$L(X,">") S Y=$P(X,">",J),INST($P(Y,"#"))=$P(Y,"#",2)
 Q
 ;
UNKARGS(ARGS,LIST) ; returns true if any argument is unknown
 N X,UNKNOWN
 S UNKNOWN=0,LIST=","_LIST_",start,limit,"
 S X="" F  S X=$O(ARGS(X)) Q:X=""  I LIST'[(","_X_",") D
 . S UNKNOWN=1
 . D SETERROR^VPRJRER(111,X)
 Q UNKNOWN
 ;
SPC(S,PIECE) ; return the piece delimited by 1..n spaces
 N I,X,T
 S S=$TR(S,$C(9)," "),T="",PIECE=$G(PIECE,1)
 F I=1:1 D  Q:$L(T)  Q:'$L(S)
 . S S=$$TRIM^XLFSTR(S,"L")
 . S X=$P(S," ") I PIECE=I S T=X Q
 . S S=$E(S,$L(X)+1,$L(S))
 Q T
 ;
SPLIT(X,LIST,D) ; split string into sorted array, trimming each element
 N I,Y
 S D=$G(D,",")
 F I=1:1:$L(X,D) S Y=$$TRIM^XLFSTR($P(X,D,I)) I $L(Y) S LIST(Y)=""
 Q
NSPLIT(X,LIST,D) ; split string into ordered array, trimming each element
 N I,Y,C
 S D=$G(D,","),C=0
 F I=1:1:$L(X,D) S Y=$$TRIM^XLFSTR($P(X,D,I)) I $L(Y) S C=C+1,LIST(C)=Y
 Q
LTRIM(SRC,IDX) ; trim whitespace from left advancing index
 ; .SRC: source string
 ; .IDX: index of starting character, gets set to first non-space character
 F  Q:IDX>$L(SRC)  Q:$A(SRC,IDX)>32  S IDX=IDX+1  ; trim left whitespace
 Q
NXTSTR(SRC,IDX,STR,QUOTE) ; procedure to parse next string and advance index
 ;  .SRC: the source string
 ;  .IDX: points to the quote that begins the string, will be set 1 past end
 ;  .STR: will contain the parsed string (with unescaped quotes)
 ; QUOTE: defaults to ", but may be any other character (like ')
 ; may set: ERROR
 N TIDX,DONE,END
 S DONE=0,IDX=IDX+1,TIDX=IDX,QUOTE=$G(QUOTE,"""")
 F  D  Q:DONE  Q:$G(HTTPERR)
 . S END=$F(SRC,QUOTE,TIDX) I END=0 D SETERROR^VPRJRER(106,"unexpected end") Q
 . I $E(SRC,END)'=QUOTE S DONE=1 Q
 . S TIDX=END+1 ; advance past second quote and try again
 S STR=$E(SRC,IDX,END-2)
 S IDX=END
 I STR[QUOTE N SPEC S SPEC(QUOTE_QUOTE)=QUOTE,STR=$$REPLACE^XLFSTR(STR,.SPEC)
 Q
NXTVAL(SRC,IDX,VAL,TOKENS) ; return next value
 ;   .SRC: the source string
 ;   .IDX: index of current starting character, gets set 1 past end of value
 ;   .VAL: will contain the parsed value
 ; TOKENS: is a string of terminating characters (the next value)
 ;         "." is a special case and looks for ".."
 D LTRIM(.SRC,.IDX)
 N END,DOTS,DONE
 S END=IDX,DOTS=0,DONE=0
 I TOKENS["." S DOTS=1,TOKENS=$TR(TOKENS,".","")
 F  D  Q:DONE
 . I END>$L(SRC) S DONE=1 Q
 . I TOKENS[$E(SRC,END) S DONE=1 Q
 . I DOTS,$E(SRC,END)=".",$E(SRC,END+1)="." S DONE=1 Q
 . S END=END+1
 S VAL=$$TRIM^XLFSTR($E(SRC,IDX,END-1)),IDX=END
 Q

VPRJCV^INT^1^63435;39516^0
VPRJCV ;SLC/KCM -- Extract Values and Compute Combinations
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
IDXVALS(OBJECT,VALUES,IDXSPEC) ; return values for indexing
 ; .VALUES(instanceString,subscriptPosition)=value
 ;
 N POSITION,IDXVALS,IDXNAMED
 ; if value at any subscript position is empty string, return no values
 ; IDXVALS(subscript position, instance...)=VALUE
 S POSITION=0 F  S POSITION=$O(IDXSPEC(POSITION)) Q:'POSITION  D GETVALS(.OBJECT,.IDXVALS,.IDXSPEC,POSITION) I '$D(IDXVALS(POSITION)) K IDXVALS Q
 Q:'$D(IDXVALS)
 ;W ! ZW IDXVALS
 ;
 ; VALUES(combined instance string, subscript position)=VALUE
 D COMBINE(.IDXVALS,.VALUES,.IDXSPEC)
 ;W ! ZW VALUES
 Q
 ;
 ;
GETVALS(OBJECT,VALS,SPEC,POS) ; put values defined by SPEC into VALS
 ;.VALS(POS,F)=top level value
 ;.VALS(POS,inst,inst,...)=value inside array(s)
 ; POS may be a subscript position (for indexes)
 ; F is field number when multiple fields are in same position
 N F
 S F=0 F  S F=$O(SPEC(POS,F)) Q:'F  D
 . I SPEC(POS,F,"srcMethod")=0  D IVAL0
 . I SPEC(POS,F,"srcMethod")=1  D IVAL1
 . I SPEC(POS,F,"srcMethod")=2  D IVAL2
 . I SPEC(POS,F,"srcMethod")=99 D GETVALR
 Q
 ;
IVAL0 ; get single value with no arrays
 N X
 S X=$G(OBJECT(SPEC(POS,F,"srcPath",1)))
 I X="" S X=$G(SPEC(POS,"ifNull")) Q:X=""
 S X=$$COLLATE(X,$G(SPEC(POS,"collate")))
 S VALS(POS,F)=X
 Q
IVAL1 ; build VALS(n) for x[].y
 N I,X
 S I=0 F  S I=$O(OBJECT(SPEC(POS,F,"srcPath",1),I)) Q:'I  D
 . S X=$G(OBJECT(SPEC(POS,F,"srcPath",1),I,SPEC(POS,F,"srcPath",2)))
 . I X="" S X=$G(SPEC(POS,"ifNull")) Q:X=""
 . S X=$$COLLATE(X,$G(SPEC(POS,"collate")))
 . S VALS(POS,SPEC(POS,F,"srcArrays",1,"path")_"#"_I)=X
 Q
IVAL2 ; build VALS(n) for x[].y[].z
 N I,J,X
 S I=0 F  S I=$O(OBJECT(SPEC(POS,F,"srcPath",1),I)) Q:'I  D
 . S J=0 F  S J=$O(OBJECT(SPEC(POS,F,"srcPath",1),I,SPEC(POS,F,"srcPath",2),J)) Q:'J  D
 . . S X=$G(OBJECT(SPEC(POS,F,"srcPath",1),I,SPEC(POS,F,"srcPath",2),J,SPEC(POS,F,"srcPath",3)))
 . . I X="" S X=$G(SPEC(POS,"ifNull")) Q:X=""
 . . S X=$$COLLATE(X,$G(SPEC(POS,"collate")))
 . . S VALS(POS,SPEC(POS,F,"srcArrays",1,"path")_"#"_I_">"_SPEC(POS,F,"srcArrays",2,"path")_"#"_J)=X
 Q
GETVALR ; build VALS(n) based on .SPEC
 ; VALS(n{,o,p,...})=values subscripted by path of instances
 N I,N,ISTR
 I +$G(SPEC(POS,F,"srcArrays"))=0 S ISTR=F D SET1VAL($G(@SPEC(POS,F,"srcRef"))) Q
 S ISTR=""
 D NXTNODE(1)
 Q
NXTNODE(N) ; loop on the next node
 ; recursive, initially from GETVALR where I,N are newed
 S I(N)=0
 F  S I(N)=$O(@SPEC(POS,F,"srcArrays",N,"ref")) Q:'I(N)  D
 . S ISTR=$P(ISTR,">",1,N),$P(ISTR,">",N)=SPEC(POS,F,"srcArrays",N,"path")_"#"_I(N)
 . I N<SPEC(POS,F,"srcArrays") D NXTNODE(N+1) Q  ; not last array level
 . D SET1VAL($G(@SPEC(POS,F,"srcRef")))
 Q
SET1VAL(VALUE) ; use indirection to set value
 I VALUE="" S VALUE=$G(SPEC(POS,"ifNull")) Q:VALUE=""
 S VALS(POS,ISTR)=$$COLLATE(VALUE,$G(SPEC(POS,"collate")))
 Q
COLLATE(VALUE,CTYPE) ; return value of field for collation
 ; Used by SET1VAL
 ; force times to always be a string rather than a numeric
 ; terminate inverse time with "=" so ":" can used to avoid endpoints when going backwards
 ; terminate strings with "!" so space can be used to include initial string
 ; ASCII order is " ","!",numerals,":","="
 S VALUE=$E(VALUE,1,250) ; to ensure fit into subscript
 I CTYPE=""  Q VALUE
 I CTYPE="P" Q VALUE
 I CTYPE="p" Q $$LOW^XLFSTR(VALUE)
 I CTYPE="V" Q $TR(VALUE,"0123456789","9876543210")_"="
 I CTYPE="S" Q VALUE_" "
 I CTYPE="s" Q $$LOW^XLFSTR(VALUE)_" "
 I CTYPE="T" Q VALUE_" "
 I CTYPE="N" Q +VALUE
 Q VALUE_" "  ; default to string
 ;
COMBINE(NAMED,COMBINED,SPEC) ; return all the combinations in NAMED as COMBINED
 ;.NAMED(sequence,instanceName)=value
 ; WORKING(pass#,instanceNameCombo,seq#)=value
 N PASS,INAME,LAST,WORKING,SEQ,FINAL
 S PASS=0 F  S PASS=$O(NAMED(PASS)) Q:'PASS  S FINAL=PASS D
 . S INAME="" F  S INAME=$O(NAMED(PASS,INAME)) Q:INAME=""  D
 . . ; handle first level (no previous level to bring forward)
 . . I PASS=1 S WORKING(1,INAME,1)=NAMED(1,INAME) Q
 . . ; otherwise iterate previous level and pull forward if appropriate
 . . S LAST="" F  S LAST=$O(WORKING(PASS-1,LAST)) Q:LAST=""  D
 . . . ; combine=0: pull forward all instances using last instance string
 . . . I SPEC(PASS,"combine")=0 D  Q
 . . . . S SEQ=0 F  S SEQ=$O(WORKING(PASS-1,LAST,SEQ)) Q:'SEQ  S WORKING(PASS,LAST,SEQ)=WORKING(PASS-1,LAST,SEQ)
 . . . . S WORKING(PASS,LAST,PASS)=NAMED(PASS,INAME)
 . . . ; combine=1: pull forward the same instance only
 . . . I SPEC(PASS,"combine")=1,(INAME=LAST) D  Q
 . . . . S SEQ=0 F  S SEQ=$O(WORKING(PASS-1,INAME,SEQ)) Q:'SEQ  S WORKING(PASS,INAME,SEQ)=WORKING(PASS-1,INAME,SEQ)
 . . . . S WORKING(PASS,INAME,PASS)=NAMED(PASS,INAME)
 . . . ; combine=2: pull forward all instances combined with this
 . . . I SPEC(PASS,"combine")=2 D  Q
 . . . . N NNAME S NNAME=LAST_"|"_INAME
 . . . . S SEQ=0 F  S SEQ=$O(WORKING(PASS-1,LAST,SEQ)) Q:'SEQ  S WORKING(PASS,NNAME,SEQ)=WORKING(PASS-1,LAST,SEQ)
 . . . . S WORKING(PASS,NNAME,PASS)=NAMED(PASS,INAME)
 M COMBINED=WORKING(FINAL)
 Q

VPRJCV1^INT^1^63396;54290^0
VPRJCV1 ;SLC/KCM -- Set values into objects for expanded links
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETJSON(TARGET,VALS,SPEC,LEVEL) ; using UID's in VALS, put JSON in TARGET
 ; expects PID if retrieving from patient globals
 ; switch
 I SPEC(LEVEL,"tgtMethod")=0  G SETJSON0
 I SPEC(LEVEL,"tgtMethod")=1  G SETJSON1
 I SPEC(LEVEL,"tgtMethod")=2  G SETJSON2
 I SPEC(LEVEL,"tgtMethod")=99 G SETJSONR
 Q
SETJSON0 ; add JSON from VALS(1)
 Q:'$L($G(VALS(LEVEL)))
 N JSON
 D UID2JSN(VALS(LEVEL),.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 M TARGET(SPEC(LEVEL,"tgtPath",1),":")=JSON
 Q
SETJSON1 ; add JSON from VALS(n) as .TARGET(x,i,y)
 N I
 S I=0 F  S I=$O(VALS(LEVEL,I)) Q:'I  I $L(VALS(LEVEL,I)) D
 . N JSON
 . D UID2JSN(VALS(LEVEL,I),.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 . K TARGET(SPEC(LEVEL,"tgtPath",1),I,SPEC(LEVEL,"tgtPath",2))
 . M TARGET(SPEC(LEVEL,"tgtPath",1),I,SPEC(LEVEL,"tgtPath",2),":")=JSON
 Q
SETJSON2 ; add JSON from VALS(n) as .TARGET(x,i,y,j,z)
 N I,J
 S I=0 F  S I=$O(VALS(LEVEL,I)) Q:'I  D
 . S J=0 F  S J=$O(VALS(LEVEL,I,J)) Q:'J  I $L(VALS(LEVEL,I,J)) D
 . . N JSON
 . . D UID2JSN(VALS(LEVEL,I,J),.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 . . K TARGET(SPEC(LEVEL,"tgtPath",1),I,SPEC(LEVEL,"tgtPath",2),J,SPEC(LEVEL,"tgtPath",3))
 . . M TARGET(SPEC(LEVEL,"tgtPath",1),I,SPEC(LEVEL,"tgtPath",2),J,SPEC(LEVEL,"tgtPath",3),":")=JSON
 Q
SETJSONR ; add JSON from VALS(n) into .TARGET based on .SPEC
 I +$G(SPEC(LEVEL,"tgtArrays"))=0,$L(VALS(LEVEL)) D  Q  ;no arrays
 . N JSON
 . D UID2JSN(VALS(LEVEL),.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 . M @SPEC(LEVEL,"tgtRef")@(":")=JSON
 ; otherwise start iterating the arrays
 N I,J,N
 D SJNXTLVL(1)
 Q
SJNXTLVL(N) ; loop on the next node
 ; expects SPEC and LEVEL
 ; recursive, initially from SETJSON where I and N are newed
 ; if more arrays in VALS than in target, use $QUERY
 I (N=SPEC(LEVEL,"tgtArrays")),(N<SPEC(LEVEL,"valArrays")) D SJQUERY(N) QUIT
 ;
 ;otherwise handle next array level normally
 S I(N)=0 F  S I(N)=$O(@SPEC(LEVEL,"valArrays",N)) Q:'I(N)  D
 . I N<SPEC(LEVEL,"valArrays") D SJNXTLVL(N+1) Q  ; not last array level
 . N JSON
 . D UID2JSN(@SPEC(LEVEL,"valRef"),.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 . S J=I(N)
 . M @SPEC(LEVEL,"tgtRef")@(":")=JSON
 Q
SJQUERY(N) ; use $QUERY to get the rest of the levels
 ; expects SPEC and LEVEL
 N ROOT,X
 S J=0
 S I(N)=0 F  S I(N)=$O(@SPEC(LEVEL,"valArrays",N)) Q:'I(N)  D
 . S ROOT=$NA(@SPEC(LEVEL,"valArrays",N)),X=ROOT,ROOT=$E(X,1,$L(X)-1)
 . F  S X=$Q(@X) Q:$E(X,1,$L(ROOT))'=ROOT  S J=J+1 D
 . . N JSON
 . . D UID2JSN(@X,.JSON,$G(SPEC(LEVEL,1,"srcTemplate")))
 . . M @SPEC(LEVEL,"tgtRef")@(":")=JSON  ; inside tgtRef I(N) is array index
 Q
UID2JSN(UID,JSON,TLTNM) ; get JSON for object using optional template
 ; expects PID for patient data
 ;
 I $G(HTTPREQ("store"))="data" G UID2JSND ; jump to use non-patient globals
 ;
 I '$L($G(TLTNM)) M JSON=^VPRPTJ("JSON",PID,UID) I 1
 E  M JSON=^VPRPTJ("TEMPLATE",PID,UID,TLTNM) ; save-time template
 I '$D(JSON) S JSON="{""unknownUid"":"""_UID_"""}"
 ;TODO: handle query time templates here
 Q
UID2JSND ; branch here to use non-patient globals
 I '$L($G(TLTNM)) M JSON=^VPRJDJ("JSON",UID) I 1
 E  M JSON=^VPRJDJ("TEMPLATE",UID,TLTNM) ; save-time template
 I '$D(JSON) S JSON="{""unknownUid"":"""_UID_"""}"
 ;TODO: handle query time templates here
 Q
 ;
 ; based on GETVALS^VPRJCV
 ;
GETVALS(OBJECT,VALS,SPEC,FLD) ; put values defined by SPEC into VALS
 ;.VALS(FLD)=top level value
 ;.VALS(FLD,inst,inst,...)=value inside array(s)
 ;
 ; switch begin
 I SPEC(FLD,1,"srcMethod")=0  G IVAL0
 I SPEC(FLD,1,"srcMethod")=1  G IVAL1
 I SPEC(FLD,1,"srcMethod")=2  G IVAL2
 I SPEC(FLD,1,"srcMethod")=99 G GETVALR
 ; switch end
 Q
 ;
IVAL0 ; get single value with no arrays
 N X
 S X=$G(OBJECT(SPEC(FLD,1,"srcPath",1)))
 S VALS(FLD)=X
 Q
IVAL1 ; build VALS(n) for x[].y
 N I,X
 S I=0 F  S I=$O(OBJECT(SPEC(FLD,1,"srcPath",1),I)) Q:'I  D
 . S X=$G(OBJECT(SPEC(FLD,1,"srcPath",1),I,SPEC(FLD,1,"srcPath",2)))
 . Q:'$L(X)  S VALS(FLD,I)=X
 Q
IVAL2 ; build VALS(n) for x[].y[].z
 N I,J,X
 S I=0 F  S I=$O(OBJECT(SPEC(FLD,1,"srcPath",1),I)) Q:'I  D
 . S J=0 F  S J=$O(OBJECT(SPEC(FLD,1,"srcPath",1),I,SPEC(FLD,1,"srcPath",2),J)) Q:'J  D
 . . S X=$G(OBJECT(SPEC(FLD,1,"srcPath",1),I,SPEC(FLD,1,"srcPath",2),J,SPEC(FLD,1,"srcPath",3)))
 . . Q:'$L(X)  S VALS(FLD,I,J)=X
 Q
GETVALR ; build VALS(n) based on .SPEC
 ; VALS(n{,o,p,...})=values subscripted by path of instances
 N I,N
 I +$G(SPEC(FLD,1,"srcArrays"))=0 S VALS(FLD,1)=$G(@SPEC(FLD,1,"srcRef")) Q
 D NXTNODE(1)
 Q
NXTNODE(N) ; loop on the next node
 ; recursive, initially from GETVALR where I,N are newed
 S I(N)=0
 F  S I(N)=$O(@SPEC(FLD,1,"srcArrays",N,"ref")) Q:'I(N)  D
 . I N<SPEC(FLD,1,"srcArrays") D NXTNODE(N+1) Q  ; not last array level
 . S @SPEC(FLD,"valRef")=$G(@SPEC(FLD,1,"srcRef"))
 Q

VPRJDMT^INT^1^63294;58829^0
VPRJDMT ;SLC/KCM -- Meta data for ODS JSON templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
TLT ;;
 ;;unit-test-ods-expand
 ;;  collections: utestods
 ;;  directives: include, applyOnQuery
 ;;  fields: uid, name, fullItems[]>items[].uid
 ;;unit-test-ods-summary
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: uid, name
 ;;zzzzz
 ;

VPRJDMX^INT^1^63315;47129^0
VPRJDMX ;SLC/KCM -- Meta data for JSON indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Types of collation:
 ;       V: Inverse HL7 Time (appends "=" after complementing time)
 ;       T: Forward HL7 Time (appends " " to time)
 ;       N: Numeric          (+value)
 ;       S: String           (appends " " to ensure string)
 ;       s: String           (case insensitive, appends " " to ensure string)
 ;       P: Plain            (uses value as is)
 ;       p: Plain            (case insensitive, use value as is)
 ;
 ; --------------------------------------------------------
 ; Tally time indexes maintain counts of each value a field takes on
 ; The definition structure is:
 ;
 ;;indexName
 ;;    fields.{collection}: {tallyField}
IDXTALLY ; tally type indexes
 ;;test-name-count
 ;;    collections: test
 ;;    fields: name
 ;;syncstatus-pid-count
 ;;    collections: syncstatus
 ;;    fields: pid
 ;;syncerror-pid-count
 ;;    collections: syncerror
 ;;    fields: pid
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Attribute type indexes index first by field, then by sort
 ; The first collation is the field collation, followed by the sort collation.
 ; The default is s,s (both case-insensitive strings) if no other collation
 ; is defined.
IDXATTR ;
 ;;test-name
 ;;    collections: test
 ;;    fields: name/s, updated/V/0
 ;;    sort: updated desc
 ;;utest-name
 ;;    collections: test, testb, utestods
 ;;    fields: name/s
 ;;    sort: name asc
 ;;vprupdate
 ;;    collections: vprupdate
 ;;person
 ;;    collections: user
 ;;    fields: name
 ;;    sort: name asc
 ;;    setif: $$ACT^VPRJFD
 ;;personphoto
 ;;    collections: personphoto
 ;;    fields: personUid
 ;;team-membership
 ;;    collections: team
 ;;    fields: staff[].personUid
 ;;    sort: displayName asc
 ;;team-categories
 ;;    collections: teamcategory
 ;;    fields: name
 ;;    sort: name asc
 ;;teams
 ;;    collections: team
 ;;    fields: displayName
 ;;    sort: displayName asc
 ;;team-positions
 ;;    collections: teamposition
 ;;    fields: name
 ;;    sort: name asc
 ;;categories
 ;;    collections: category
 ;;    fields: name,domain
 ;;    sort: name asc
 ;;orderable-types
 ;;    collections: orderable
 ;;    fields: types[].type,name
 ;;    sort: name asc
 ;;clioterminology
 ;;    collections: clioterminology
 ;;    fields: term, termType
 ;;    sort: term asc
 ;;rosters
 ;;    collections: roster
 ;;    fields: localId
 ;;syncstatus
 ;;    collections: syncstatus
 ;;    fields: pid
 ;;rosterpats
 ;;    collections: roster
 ;;    fields: patients[].pid, name, localId
 ;;locations-wards
 ;;    collections: location
 ;;    fields: name
 ;;    sort: name asc
 ;;    setif: $$WARDLOC^VPRJFPS
 ;;locations-clinics
 ;;    collections: location
 ;;    fields: name
 ;;    sort: name asc
 ;;    setif: $$CLINLOC^VPRJFPS
 ;;status-pt
 ;;    collections: syncstatus
 ;;    fields: pid
 ;;    setif: $$PTSYNCSTATUS^VPRJFPS
 ;;status-loading
 ;;    collections: syncstatus
 ;;    fields: pid
 ;;    setif: $$PTLOADNG^VPRJFPS
 ;;status-loaded
 ;;    collections: syncstatus
 ;;    fields: pid
 ;;    setif: $$PTLOADED^VPRJFPS
 ;;syncerror
 ;;    collections: syncerror
 ;;    fields: id
 ;;syncerror-pid
 ;;    collections: syncerror
 ;;    fields: pid
 ;;pt-select-pid
 ;;    collections: pt-select
 ;;    fields: pid/s
 ;;    sort: fullName asc
 ;;pt-select-icn
 ;;    collections: pt-select
 ;;    fields: icn/s
 ;;    sort: fullName asc
 ;;pt-select-name
 ;;    collections: pt-select
 ;;    fields: fullName/s
 ;;    sort: fullName asc
 ;;pt-select-ssn
 ;;    collections: pt-select
 ;;    fields: ssn/s
 ;;    sort: fullName asc
 ;;pt-select-last4
 ;;    collections: pt-select
 ;;    fields: last4/s
 ;;    sort: fullName asc
 ;;pt-select-last5
 ;;    collections: pt-select
 ;;    fields: last5/s
 ;;    sort: fullName asc
 ;;zzzzz
 ;

VPRJDQ^INT^1^63294;58829^0
VPRJDQ ;SLC/KCM -- Query for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
QKEY(KEY,TEMPLATE) ; Return an object given the key (i.e., urn:va:fresh:93EF:10076)
 N VPRDATA,ORDER
 S TEMPLATE=$G(TEMPLATE)
 I '$D(^VPRJDJ("JSON",KEY)) D SETERROR^VPRJRER(104,"UID:"_KEY) Q
 K ^TMP("VPRDATA",$J)
 S ^TMP("VPRDATA",$J,KEY,0)="",VPRDATA=1,ORDER(0)=0
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
 ;
QCOUNT(CNTNM) ; Return a set of counts across patients
 ; return tallies as data:{items:[{"topic":"med","count":4}
 N BUFFER S BUFFER=""
 K ^TMP($J)
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRJDX("count",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRJDX("count",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJCB(DATA) D STAGE^VPRJCB(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJCB(DATA(DATA))
 D STAGE^VPRJCB("]}}"),OUT^VPRJCB
 Q
QTALLY(CNTNM) ; Return a set of counts
 ; return tallies as data:{items:[{"topic":"MEDICATION,INPT","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRER(101) Q
 N BUFFER S BUFFER=""
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRJDX("tally",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRJDX("tally",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJCB(DATA) D STAGE^VPRJCB(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJCB(DATA(DATA))
 D STAGE^VPRJCB("]}}"),OUT^VPRJCB
 Q
 ;
 ;defined at the QINDEX level:
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QINDEX(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; query based on index
 I '$L($G(INDEX)) D SETERROR^VPRJRER(101) Q
 N VPRDATA,METHOD,CLAUSES
 S RANGE=$G(RANGE),ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 M INDEX=^VPRMETA("index",INDEX,"common")
 S METHOD=$G(INDEX("method")) I '$L(METHOD) D SETERROR^VPRJRER(102,INDEX) Q
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 I METHOD="attr" D QATTR^VPRJDQA
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
QLAST(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; return most recent item in the list
 N IDXLAST S IDXLAST=1
 D QINDEX(INDEX,$G(RANGE),$G(ORDER),$G(BAIL),$G(TEMPLATE),$G(FILTER))
 Q
QFIND(COLL,ORDER,BAIL,TEMPLATE,FILTER) ; return items from collection without index
 N VPRDATA,CLAUSES,PREFIX,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=0 S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S PREFIX="urn:va:"_COLL_":",KEY=PREFIX
 F  S KEY=$O(^VPRJD(KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJDQA(KEY,0)
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q

VPRJDQA^INT^1^63363;56099^0
VPRJDQA ;SLC/KCM -- Query using attribute indexes for JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;defined at the QINDEX level:
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequence of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QATTR ; return items where attribute value is in range
 ; Build ^TMP("VPRDATA",$J,sortkey,sortkey,...,key,instances) with keys of objects to return
 ; Expects:  VPRDATA,METHOD,RANGE,INDEX,ORDER,CLAUSES,BAIL
 N START,STOP,DIR,SUB,KEY,INST
 D PARSERNG^VPRJCR
 I $G(IDXLAST)=1 D  ; handle finding last or latest items
 . S DIR(INDEX("levels"))=$S(INDEX("collate",INDEX("levels"))="V":1,1:-1)
 . I INDEX("levels")=0  D L0 Q
 . I INDEX("levels")=1  D L1 Q
 . I INDEX("levels")=2  D L2 Q
 . I INDEX("levels")=3  D L3 Q
 E  D               ; normal search loops
 . I INDEX("levels")=0  D A0 Q
 . I INDEX("levels")=1  D A1 Q
 . I INDEX("levels")=2  D A2 Q
 . I INDEX("levels")=3  D A3 Q
 Q
A0 ; unsorted list
 S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
A1 ; sorted list / attribute only
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)=START(3) F  S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY="" F  S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST="" F  S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
NXT1() ;
 I START(1,"collate")="L" S SUB(1)=$O(START(1,"list",SUB(1))) Q SUB(1)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1)),DIR(1))
 ;
NXT2() ;
 I START(2,"collate")="L" S SUB(2)=$O(START(2,"list",SUB(2))) Q SUB(2)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2)),DIR(2))
 ;
NXT3() ;
 I START(3,"collate")="L" S SUB(3)=$O(START(3,"list",SUB(3))) Q SUB(3)
 Q $O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3)),DIR(3))
 ;
L0 ; unsorted list
 S KEY="" S KEY=$O(^VPRJDX(METHOD,INDEX,KEY),-1) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
L1 ; sorted list / attribute only
 S SUB(1)="" S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)="" S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)="" S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST=$O(^VPRJDX(METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
ADDONE(KEY,INST,SUB) ; add uid, calculating new sort key if necessary
 ; Expects: .ORDER,.CLAUSES
 I $D(CLAUSES) Q:'$$EVALAND^VPRJCF(.CLAUSES,KEY)  ;apply filter, quit if not true
 N I,SORT,KINST
 S I=0 F  S I=$O(ORDER(I)) Q:'I  S SORT(I)=$S(+ORDER(I):SUB(+ORDER(I)),1:$$SORTVAL(I))
 S VPRDATA=VPRDATA+1
 ; case
 I ORDER(0)=0 S ^TMP("VPRDATA",$J,KEY,INST)="" G X1
 I ORDER(0)=1 S ^TMP("VPRDATA",$J,SORT(1),KEY,INST)="" G X1
 I ORDER(0)=2 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,INST)="" G X1
 I ORDER(0)=3 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,INST)="" G X1
 I ORDER(0)=4 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,INST)="" G X1
 I ORDER(0)=5 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,INST)="" G X1
 I ORDER(0)=6 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,INST)="" G X1
 I ORDER(0)=7 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,INST)="" G X1
X1 ; end case
 Q
 ;
SORTVAL(LEVEL) ; return a value or 0 from data gbl for sorting
 ; Expects: KEY,INST,.ORDER   derived from GETVALS^VPRJCV
 ; LEVEL is the subscript position of the sort key
 ; ORDER(LEVEL) described the value in the format returned by FLDSPEC^VPRJCD
 ; if there is no value, a 0 is used so the sort subscript remains non-null
 N CLTN
 S CLTN=0
 I ORDER(LEVEL,CLTN,"srcMethod")=0 Q $$SRTVAL0
 N IARY
 D EXPINST^VPRJCU(INST,IARY)  ; INST=a#1|b#2>b.c#3 to IARY(arrayPath)=number
 I ORDER(LEVEL,CLTN,"srcMethod")=1 Q $$SRTVAL1
 I ORDER(LEVEL,CLTN,"srcMethod")=2 Q $$SRTVAL2
 I ORDER(LEVEL,CLTN,"srcMethod")=99 Q $$SRTVALR
 Q 0
 ;
SRTVAL0() ; return value for x
 N X
 S X=$G(^VPRJD(KEY,ORDER(LEVEL,CLTN,"srcPath",1)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",1),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVAL1() ; return value for x[instance].y
 N I,X
 S I=$G(IARY(ORDER(LEVEL,CLTN,"srcArrays",1,"path"))) Q:'I ""
 S X=$G(^VPRJD(KEY,ORDER(LEVEL,CLTN,"srcPath",1),I,ORDER(LEVEL,CLTN,"srcPath",2)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",2),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVAL2() ; return value for x[instance].y[instance].z
 N I,J,X
 S I=$G(IARY(ORDER(LEVEL,"srcArrays",1,"path"))) Q:'I ""
 S J=$G(IARY(ORDER(LEVEL,"srcArrays",2,"path"))) Q:'J ""
 S X=$G(^VPRJD(KEY,ORDER(LEVEL,CLTN,"srcPath",1),I,ORDER(LEVEL,CLTN,"srcPath",2),J,ORDER(LEVEL,CLTN,"srcPath",3)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",3),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVALR() ; return value using indirection
 I +$G(ORDER(LEVEL,CLTN,"srcArrays"))=0 Q $G(@ORDER(LEVEL,CLTN,"srcRef"))
 N I,N,X
 D NXTNODE(1)
 Q X
NXTNODE(N) ; loop on the next node given instance
 ; FROM: GETVALR  traverse nodes using recursion
 S I(N)=$G(IARY(ORDER(LEVEL,CLTN,"srcArrays",N,"path"))) I 'I(N) S X=0 QUIT
 I N<ORDER(LEVEL,CLTN,"srcArrays") D NXTNODE(N+1) Q
 S X=$G(@ORDER(LEVEL,CLTN,"srcRef"),0) I $D(@ORDER(LEVEL,CLTN,"srcRef")@("\s")) S X=X_" "
 S:X="" X=0
 Q
 ;

VPRJDR^INT^1^63398;51312^0
VPRJDR ;SLC/KCM -- Handle RESTful operations for data objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PUTOBJ(ARGS,BODY) ; PUTs an object into the database
 Q "/data/"_$$SAVE^VPRJDS(.BODY)
 ;
NEWOBJ(ARGS,BODY) ; PUTs an object into the database, returning UID
 N OBJECT,ERR,UID,CTN
 S CTN=ARGS("collectionName")
 I '$L(CTN) D SETERROR^VPRJRER(215) QUIT ""
 D DECODE^VPRJSON("BODY","OBJECT","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 I $G(OBJECT("uid"))="" S OBJECT("uid")=$$BLDUID(CTN) I '$L(OBJECT("uid")) QUIT ""
 K BODY
 D ENCODE^VPRJSON("OBJECT","BODY","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 Q "/data/"_$$SAVE^VPRJDS(.BODY)
 ;
BLDUID(CTN) ; build the uid for a new item in a collection
 N UID
 I '$L(CTN) Q ""
 L +^VPRJD("COLLECTION",CTN):2 E  D SETERROR^VPRJRER(502) Q ""
 S UID=$G(^VPRJD("COLLECTION",CTN))+1,^VPRJD("COLLECTION",CTN)=UID
 L -^VPRJD("COLLECTION",CTN)
 Q "urn:va:"_CTN_":"_$G(^VPRMETA("system"))_":"_UID
 ;
GETOBJ(RESULT,ARGS) ; gets an object given a UID
 I $$UNKARGS^VPRJCU(.ARGS,"uid,template") Q
 D QKEY^VPRJDQ($G(ARGS("uid")),$G(ARGS("template")))
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
INDEX(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter,start") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$D(^VPRMETA("index",INDEX)) D SETERROR^VPRJRER(102,INDEX) Q
 ;
 ; check to see if we can return a cached result
 N HASHSTR,HASHTS,HASH
 S HASHSTR="data/index/"_INDEX_"/"_RANGE_"/"_ORDER_"/"_TEMPLATE_"/"_FILTER
 I $$CACHED(INDEX,HASHSTR,.HASH,.HASHTS) D  Q
 . S RESULT=$NA(^VPRTMP(HASH)),RESULT("pageable")=""
 ;
 ; otherwise prepare cache and do the regular query
 S ^TMP($J,"query")=HASHSTR,^TMP($J,"timestamp")=HASHTS
 S ^TMP($J,"index")=INDEX,^TMP($J,"hash")=HASH
 D QINDEX^VPRJDQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CACHED(INDEX,HASHSTR,HASH,HASHTS) ; return TRUE if query cached and the cache is current
 ; .HASH returns the hashed value of HASHSTR
 ; .HASHTS returns the current $H of the index used
 Q:'$L(INDEX) 0
 N MTHD
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 S HASHTS=$G(^VPRJDX(MTHD,INDEX))
 S HASH=$$HASH^VPRJRUT(HASHSTR)
 I '$D(^VPRTMP(HASH,"query"))!'$D(^VPRTMP(HASH,"timestamp")) Q 0  ; no cached data
 I ^VPRTMP(HASH,"query")'=HASHSTR Q 0    ; hash matched, but not original string
 I ^VPRTMP(HASH,"timestamp")=HASHTS Q 1  ; timestamps match, quit true
 Q 0                                     ; default to no cached data
 ;
LAST(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QLAST^VPRJDQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
FIND(RESULT,ARGS) ; GET for objects using 'where' criteria
 I $$UNKARGS^VPRJCU(.ARGS,"collection,order,bail,template,filter") Q
 N COLL,ORDER,BAIL,TEMPLATE,FILTER
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QFIND^VPRJDQ(COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
ALLCOUNT(RESULT,ARGS) ; GET for count of objects across patients
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QCOUNT^VPRJDQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
COUNT(RESULT,ARGS) ; GET for count of domain objects
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QTALLY^VPRJDQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
DELUID(RESULT,ARGS) ; DELETE an object
 I $$UNKARGS^VPRJCU(.ARGS,"uid") Q
 D DELETE^VPRJDS(ARGS("uid"))
 S RESULT=$NA(^TMP($J))
 Q
DELCTN(RESULT,ARGS) ; DELETE an entire collection
 I $$UNKARGS^VPRJCU(.ARGS,"collectionName,system") Q
 D DELCTN^VPRJDS(ARGS("collectionName"),$G(ARGS("system")))
 S RESULT=$NA(^TMP($J))
 Q
DELALL(RESULT,ARGS) ; DELETE the entire non-patient data store
 I $$UNKARGS^VPRJCU(.ARGS,"confirm") Q
 I $G(ARGS("confirm"))'="true" D SETERROR^VPRJRER(405) Q
 D KILLDB^VPRJ2D
 S RESULT=""
 Q

VPRJDS^INT^1^63400;42551^0
VPRJDS ;SLC/KCM -- Save JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SAVE(JSON) ; Save a JSON encoded object
 N UID,COLL,KEY,OBJECT,OLDOBJ,VPRJERR,INDEXER,TLTARY
 ;
 ; decode JSON into object and extract required fields
 D DECODE^VPRJSON("JSON","OBJECT","VPRJERR")
 I $L($G(VPRJERR)) D SETERROR^VPRJRER(202,VPRJERR) QUIT ""
 S UID=$G(OBJECT("uid")) I '$L(UID) D SETERROR^VPRJRER(207) QUIT ""
 ;
 ; Parse out the collection, and key from the UID
 ; Currently assuming UID is urn:va:type:vistaAccount...
 ; For example:  urn:va:fresh:93EF
 N COLL S COLL=$P(UID,":",3)
 I '$L(COLL) D SETERROR^VPRJRER(210,UID) QUIT ""
 ;
 L +^VPRJD(UID):2 E  D SETERROR^VPRJRER(502) QUIT ""
 ; kill the old indexes and object
 S OLDOBJ="" M OLDOBJ=^VPRJD(UID)
 D BLDTLT^VPRJCT1(COLL,.OBJECT,.TLTARY) Q:$G(HTTPERR) ""
 TSTART
 K ^VPRJD(UID)
 K ^VPRJDJ("JSON",UID)
 ;
 M ^VPRJDJ("JSON",UID)=JSON
 M ^VPRJDJ("TEMPLATE",UID)=TLTARY
 M ^VPRJD(UID)=OBJECT
 D INDEX^VPRJDX(UID,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRJD(UID)
 ;
 Q $$URLENC^VPRJRUT(UID)  ; no errors
 ;
DELETE(KEY) ; Delete an object given its UID
 N OLDOBJ,OBJECT,COLL
 S COLL=$P(KEY,":",3)
 I '$L(COLL) D SETERROR^VPRJRER(210,KEY) QUIT ""
 ;
 L +^VPRJD(KEY):2 E  D SETERROR^VPRJRER(502) QUIT ""
 ; kill the old indexes and object
 S OBJECT=""
 S OLDOBJ="" M OLDOBJ=^VPRJD(KEY)
 TSTART
 K ^VPRJD(KEY)
 K ^VPRJDJ("JSON",KEY)
 K ^VPRJDJ("TEMPLATE",KEY)
 D INDEX^VPRJDX(KEY,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRJD(KEY)
 Q
DELCTN(COLL,SYSID) ; Delete a collection given its name
 I '$L(COLL) D SETERROR^VPRJRER(215) QUIT ""
 N ROOT,LROOT,UID
 S ROOT="urn:va:"_COLL_":"
 I $L($G(SYSID)) S ROOT=ROOT_SYSID_":"
 S LROOT=$L(ROOT)
 S UID=ROOT F  S UID=$O(^VPRJD(UID)) Q:$E(UID,1,LROOT)'=ROOT  D DELETE(UID)
 Q

VPRJDX^INT^1^63294;58829^0
VPRJDX ;SLC/KCM -- Index a JSON object
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
INDEX(KEY,OLDOBJ,NEWOBJ) ; Index this object identified by its KEY
 N IDXCOLL,IDXNAME
 ; Currently assuming UID is urn:va:collection:vistaAccount:...
 ; For example:  urn:va:fresh:93EF
 S IDXCOLL=$P(KEY,":",3)
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"index",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRMETA("index",IDXNAME,"collection",IDXCOLL)
 . I IDXMETA("method")="tally" D TALLY Q
 . I IDXMETA("method")="attr"  D ATTRIB Q
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"link",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRMETA("link",IDXNAME,"collection",IDXCOLL)
 . D REVERSE
 D COUNTS
 Q
 ;
 ; ----- Maintain counts of objects -----
 ;
COUNTS ; set counts for different collection types
 N DOMAIN
 D KCOUNT("collection",IDXCOLL,.OLDOBJ)
 D SCOUNT("collection",IDXCOLL,.NEWOBJ)
 Q
SCOUNT(GROUP,TOPIC,OBJECT) ; Increment a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRJDX("tally",GROUP,TOPIC))
 S ^VPRJDX("tally",GROUP,TOPIC)=TALLY+1 ; incr count for collection
 ;
 L +^VPRJDX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRER(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRJDX("count",GROUP,TOPIC))
 S ^VPRJDX("count",GROUP,TOPIC)=TALLY+1 ; incr count across patients
 L -^VPRJDX("count",GROUP,TOPIC)
 Q
KCOUNT(GROUP,TOPIC,OBJECT) ; Decrement a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRJDX("tally",GROUP,TOPIC))
 S ^VPRJDX("tally",GROUP,TOPIC)=TALLY-1 ; decr count for collection
 ;
 L +^VPRJDX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRER(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRJDX("count",GROUP,TOPIC))
 S ^VPRJDX("count",GROUP,TOPIC)=TALLY-1 ; decr count across patients
 L -^VPRJDX("count",GROUP,TOPIC)
 Q
 ;
 ; ----- Index Logic: tally by attribute value -----
 ;
TALLY ; TALLY index ("tally",group,value)=tally
 ; if FIELD has no value, count is not changed
 D KTALLY(.OLDOBJ)
 D STALLY(.NEWOBJ)
 S ^VPRJDX("tally",IDXNAME)=$H
 Q
STALLY(OBJECT) ; Increment a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRJDX("tally",IDXNAME,VALUES(I,1)))
 . S ^VPRJDX("tally",IDXNAME,VALUES(I,1))=TALLY+1
 Q
KTALLY(OBJECT) ; Decrement a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRJDX("tally",IDXNAME,VALUES(I,1)))
 . S ^VPRJDX("tally",IDXNAME,VALUES(I,1))=TALLY-1
 . I ^VPRJDX("tally",IDXNAME,VALUES(I,1))=0 K ^VPRJDX("tally",IDXNAME,VALUES(I,1))
 Q
 ;
 ; ----- Index Logic: attributes -----
 ;
ATTRIB ; ATTRIBUTE index ("attr",group,value,sort,key)
 D KATTRIB(.OLDOBJ)
 D SATTRIB(.NEWOBJ)
 S ^VPRJDX("attr",IDXNAME)=$H
 Q
SATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q:'OK
 I $L(IDXMETA("review")) D
 . N REVIEW,REVTM
 . S REVIEW="S REVTM="_REVIEW_"(.OBJECT)" X REVIEW
 . S ^VPRJDX("keyReview",KEY,IDXNAME)=REVTM
 . S ^VPRJDX("review",REVTM,KEY,IDXNAME)=""
 ;
 I IDXMETA("levels")=0  D SA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D SA1  Q
 I IDXMETA("levels")=2  D SA2  Q
 I IDXMETA("levels")=3  D SA3  Q
 Q
KATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ;
 I $L(IDXMETA("review")) D
 . N REVTM
 . S REVTM=$G(^VPRJDX("keyReview",KEY,IDXNAME)) Q:'$L(REVTM)
 . K ^VPRJDX("keyReview",KEY,IDXNAME)
 . K ^VPRJDX("review",REVTM,KEY,IDXNAME)
 ;
 I IDXMETA("levels")=0  D KA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D KA1  Q
 I IDXMETA("levels")=2  D KA2  Q
 I IDXMETA("levels")=3  D KA3  Q
 Q
SA0 ; unsorted list set logic
 S ^VPRJDX("attr",IDXNAME,KEY)=""
 Q
KA0 ; unsorted list kill logic
 K ^VPRJDX("attr",IDXNAME,KEY)
 Q
SA1 ; one attribute set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),KEY,I)=""
 Q
KA1 ; one attribute kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),KEY,I)
 Q
SA2 ; two attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)=""
 Q
KA2 ; two attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)
 Q
SA3 ; three attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)=""
 Q
KA3 ; three attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)
 Q
 ;
REVERSE ; REV index
 ; ("rev",pointedToURN,relName,thisURN)
 D KREVERSE(.OLDOBJ)
 D SREVERSE(.NEWOBJ)
 S ^VPRJDX("rev",IDXNAME)=$H
 Q
SREVERSE(OBJECT) ; Set a relation link index
 Q:$D(OBJECT)<10
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRJDX("rev",VALUES(I,1),IDXNAME,KEY,I)=""
 Q
KREVERSE(OBJECT) ; Kill a relation link index
 Q:$D(OBJECT)<10
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRJDX("rev",VALUES(I,1),IDXNAME,KEY,I)
 Q

VPRJFD^INT^1^63294;58829^0
VPRJFD ;SLC/KCM -- Set/Kill Indexes for Operational Data
 ;;1.0;JSON DATA STORE;;Jan 25, 2013
 ;
ACT(PERSON) ; Return true if active person
 I $G(PERSON("disuser"),"false")="true" Q 0
 Q 1

VPRJFPS^INT^1^63405;44018^0
VPRJFPS ;SLC/KCM -- Set/Kill Indexes for Medications
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
VALID(MED) ; Return true if required fields for indexing are present
 I '$L($G(MED("facility"))) Q 0
 Q 1
 ;
IACT(MED) ; Return true if active inpatient med
 Q:'$L($G(MED("medStatus"))) 0
 Q:MED("medStatus")'=VPRCONST("SCT_MED_STATUS_ACTIVE") 0
 Q:$G(MED("IMO")) 0 ; inpatient med for outpatient
 Q:$G(MED("medType"))'=VPRCONST("SCT_MED_TYPE_GENERAL") 0
 Q 1
 ;
OACT(MED) ; Return true if active outpatient med
 Q:'$L($G(MED("medStatus"))) 0
 Q:MED("medStatus")'=VPRCONST("SCT_MED_STATUS_ACTIVE") 0
 Q:$G(MED("IMO"))!($G(MED("medType"))=VPRCONST("SCT_MED_TYPE_GENERAL")) 0
 Q 1
 ;
MICRO(LAB) ; Return true if microbiology test
 ;Q:$G(LAB("kind"))="Microbiology" 1  ; can't do this easily -- kind is buried in result
 Q:$E($G(LAB("localId")),1,2)="MI" 1  ; need to change since this is VA-specific
 Q 0
 ;
PATH(LAB) ; Return true if pathology test
 N X S X=$E($G(LAB("localId")),1,2)
 I (X'="CH"),(X'="MI") Q 1            ; temporary work-around -- this is VA-specific
 Q 0
RSLT(LAB) ; Return true if lab result
 I $D(LAB("typeName")) Q 1
 Q 0
ACC(LAB) ; Return true if accession
 I $G(LAB("organizerType"))="accession" Q 1
 Q 0
VS(VITAL) ; Return true if vital sign result
 I $D(VITAL("typeName")) Q 1
 Q 0
CWAD(DOC) ; Return true if CWAD document
 I $G(DOC("uid"))'="" I $P(DOC("uid"),":",3)="allergy" Q 1
 ;
 N C,S
 S C=$G(DOC("documentTypeCode"))
 S S=$G(DOC("status"))
 I ((C="C")!(C="D")!(C="W")),((S="COMPLETED")!(S="AMENDED")) Q 1
 Q 0
PRNTDOCS(DOC) ; Return if the docment does NOT have a child, ensuring this index only contains parent documents
 I $D(DOC("parentUid")) Q 0
 Q 1
CURVISIT(VISIT) ; Return true if checked-in, and not checked-out.
 I $G(VISIT("current"))="true" Q 1
 Q 0
SYNCERR(PT) ; Return true if the patient has sync errors > 0.
 I +$G(PT("syncErrorCount"))>0 Q 1
 Q 0
IO(OBS) ; return true if obs is an I/O - Fortunately, all I/O worthy term names start with INTAKE or OUTPUT
 Q:(OBS("typeName")?1"OUTPUT -".E)!(OBS("typeName")?1"INTAKE -".E) 1
 Q 0
WARDLOC(LOC) ;
 Q:LOC("type")="W" 1
 Q 0
CLINLOC(LOC) ;
 Q:LOC("type")="C" 1
 Q 0
PTLOADNG(STAT) ;
 N RSLT,I S RSLT=0,I="" F  S I=$O(STAT("syncStatusByVistaSystemId",I)) Q:I=""  D
 . I STAT("syncStatusByVistaSystemId",I,"syncComplete")="false" S RSLT=1
 Q RSLT
PTLOADED(STAT) ;
 N CMPLT,INCMPLT,I S CMPLT=0,INCMPLT=0,I="" F  S I=$O(STAT("syncStatusByVistaSystemId",I)) Q:I=""  D
 . I STAT("syncStatusByVistaSystemId",I,"syncComplete")="true" S CMPLT=1 E  S INCMPLT=1
 Q CMPLT&'INCMPLT
PTSYNCSTATUS(STAT) ; return true if syncstatus object has forOperational=false
 Q:STAT("forOperational")="false" 1
 Q 0
TASKPND(TASK) ;
 I $G(TASK("completed"))="true" Q 0
 Q 1
PACT(PROB) ; return true if active problem and not removed
 I $G(PROB("removed"))="true" Q 0
 I $G(PROB("statusCode"))="urn:sct:55561003" Q 1
 Q 0
PIACT(PROB) ; return true if inactive problem and not removed
 I $G(PROB("removed"))="true" Q 0
 I $G(PROB("statusCode"))="urn:sct:73425007" Q 1
 Q 0
PBOTH(PROB) ; return true if either active or inactive problem and not removed
 I $G(PROB("removed"))="true" Q 0
 I $G(PROB("statusCode"))="urn:sct:55561003" Q 1
 I $G(PROB("statusCode"))="urn:sct:73425007" Q 1
 Q 0
PRMVD(PROB) ; return true if removed problem
 I $G(PROB("removed"))="true" Q 1
 Q 0
NOOS(VISIT) ; return true if visit is not Occasion of Service (OOS)
 I $G(VISIT("locationOos"),"false")="true" Q 0
 Q 1
NEWS(ITEM) ; return true to include the item in the news-feed index
 I $P(ITEM("uid"),":",3)="visit",($G(ITEM("locationOos"),"false")="true") Q 0
 Q 1
ALLDOC(OBJ) ; return true to include in the all document index
 I $P(OBJ("uid"),":",3)'="document" Q 1     ; include consult, proc, surgery, imaging
 I $D(OBJ("parentUid")) Q 0                 ; skip child documents
 N C S C=$G(OBJ("documentTypeCode"))
 I (C="RA")!(C="CR")!(C="CP")!(C="SR") Q 0  ; skip imaging,consult,proc,surgery
 Q 1                                        ; include other documents
 ;

VPRJFTST^INT^1^63396;54290^0
VPRJFTST ;SLC/KCM -- Test Index Functions
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
NOTORNG(OBJ) ; true if not orange
 I $G(OBJ("color"))="yellow" Q 0
 Q 1

VPRJPMD^INT^1^63294;58829^0
VPRJPMD ;SLC/KCM -- Set up Meta Data for VPR Indexing
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETUP ;
 K ^VPRMETA
 S ^VPRMETA("system")=$$SYSID^VPRJRUT()
 S ^VPRMETA("version")=$P($T(VERSION^VPRJVER),";;",2)
 S ^VPRMETA("version","build")=$P($T(BUILD^VPRJVER),";;",2)
 ;
 D INDEXES
 D DOMAINS
 D BLDMETA^VPRJCD("template","TLT","VPRJPMT")  ; VPR templates
 D BLDMETA^VPRJCD("template","TLT","VPRJDMT")  ; ODC templates
 D BLDMETA^VPRJCD("link","LINKED","VPRJPMR")   ; VPR and ODC linkages
 ;
 ; "every" index is special index that references all the UID's for a patient
 S ^VPRMETA("index","every")="every"
 S ^VPRMETA("index","every","common","levels")=0
 S ^VPRMETA("index","every","common","method")="every"
 ;
 S ^VPRMETA("codes","med","productFormCode")=""
 S ^VPRMETA("codes","med","medStatus")=""
 S ^VPRMETA("codes","med","medType")=""
 S ^VPRMETA("codes","med","products[]","ingredientCode")=""
 S ^VPRMETA("codes","med","products[]","drugClassCode")=""
 S ^VPRMETA("codes","med","products[]","suppliedCode")=""
 S ^VPRMETA("codes","med","products[]","ingredientRole")=""
 S ^VPRMETA("codes","med","dosages[]","routeCode")=""
 S ^VPRMETA("codes","med","dosages[]","bodySite")=""
 S ^VPRMETA("codes","med","fills[]","fillStatus")=""
 ;
 L +^VPRPTJ("PID"):2 E  QUIT
 I '$G(^VPRPTJ("PID")) S ^VPRPTJ("PID")=0 ; initialize PID counter
 I '$D(^VPRPTX("count","patient","patient")) S ^VPRPTX("count","patient","patient")=0
 L -^VPRPTJ("PID")
 Q
INDEXES ; -- build meta data for all indexes
 K ^VPRMETA("index")
 K ^VPRMETA("collection")
 ;
 ; Patient Indexes
 D BLDMETA^VPRJCD("index:attr","IDXLIST","VPRJPMX")
 D BLDMETA^VPRJCD("index:tally","IDXTALLY","VPRJPMX")
 D BLDMETA^VPRJCD("index:time","IDXTIME","VPRJPMX")
 D BLDMETA^VPRJCD("index:attr","IDXATTR","VPRJPMX")
 D BLDMETA^VPRJCD("index:xattr","XIDXATTR","VPRJPMX")
 ; D BLDMETA^VPRJCD("index:match","IDXMATCH","VPRJPMX")
 ;
 ; Non-Patient Data Indexes
 D BLDMETA^VPRJCD("index:tally","IDXTALLY","VPRJDMX")
 D BLDMETA^VPRJCD("index:attr","IDXATTR","VPRJDMX")
 Q
 ;
 ;
DOMAINS ; -- Map collections to domains
 N I,X,COLL,DOMAIN
 S I=0 F  S I=I+1,X=$P($T(DOMAIN+I^VPRJPMX),";;",2,99) Q:X="zzzzz"  D
 . S COLL=$P(X,":"),DOMAIN=$P(X,":",2)
 . S ^VPRMETA("collection",COLL,"domain")=DOMAIN
 Q

VPRJPMR^INT^1^63392;64670^0
VPRJPMR ;SLC/KCM -- Meta data for VPR object relations
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;;relationshipName
 ;;  collections: collection{, collection, ...}
 ;;  ref: {targetFieldName>}sourceFieldName
 ;;  rev: {reverseRelationFieldName}
LINKED ;; describes relationships (linkages) between collection types
 ;;utest-multiple
 ;;  collections: utestc
 ;;  ref: dest[].obj>items[].uid
 ;;  rev: testItems
 ;;utest-single
 ;;  collections: utestc
 ;;  ref: from
 ;;  rev: testFroms
 ;;utest-ods
 ;;  collections: utestods
 ;;  ref: from[]>items[].uid
 ;;  rev: testFroms
 ;;task-link
 ;;  collections: task
 ;;  ref: link>linkUid
 ;;  rev: tasks
 ;;task-pat-link
 ;;  collections: patient
 ;;  ref: patient>pid
 ;;order-link
 ;;  collections: order
 ;;  ref: results[].result>results[].uid
 ;;document-parent
 ;;  collections: document
 ;;  ref: parent>parentUid
 ;;  rev: childDocs
 ;;procedure-result
 ;;  collections: consult,visit,procedure,surgery,image
 ;;  ref: results[]>results[].uid
 ;;  rev: procedures
 ;;team-category-link
 ;;  collections: team
 ;;  ref: categories[]>categories[].uid
 ;;  rev: teams
 ;;team-positions-link
 ;;  collections: team
 ;;  ref: staff[].position>staff[].positionUid
 ;;  rev: teams
 ;;team-boards-link
 ;;  collections: team
 ;;  ref: staff[].board>staff[].boardUid
 ;;  rev: teams
 ;;team-people-link
 ;;  collections: team
 ;;  ref: staff[].person>staff[].personUid
 ;;  rev: teams
 ;;zzzzz
 ;
 ;
BROKEN(LINK) ;
 N LINKEE,LINKER
 S PID="" F  S PID=$O(^VPRPTI(PID)) Q:'$L(PID)  D
 . S LINKEE="" F  S LINKEE=$O(^VPRPTI(PID,"rev",LINKEE)) Q:'$L(LINKEE)  D
 . . Q:'$D(^VPRPTI(PID,"rev",LINKEE,LINK))
 . . I '$D(^VPRPT(PID,LINKEE)) W !,"Missing: ",LINKEE I 1
 . . E  W !,"Good: ",LINKEE
 Q
 ;N SPEC,CLTN
 ;S CLTN="" F  S CLTN=$O(^VPRMETA("link",LINK,"collection",CLTN)) Q:CLTN=""  D
 ;. N SPEC
 ;. M SPEC=^VPRMETA("link",LINK,"collection",CLTN,1)

VPRJPMT^INT^1^63335;60351^0
VPRJPMT ;SLC/KCM -- Meta data for VPR JSON templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
TLT ;;
 ;;summary
 ;;  collections: allergy,consult,document,visit,appointment,factor,immunization,med,obs,order,problem,procedure,surgery,image,lab,vital,patient
 ;;  directives: include, applyOnSave
 ;;  fields: uid, dateTime, facilityName, summary
 ;;  fields.allergy: dateTime=<none>
 ;;  fields.consult: typeName, summary=<none>
 ;;  fields.document: referenceDateTime, localTitle, subject, summary=<none>, dateTime=<none>
 ;;  fields.visit: kind, locationName, specialty, summary=<none>, dateTime=<none>
 ;;  fields.appointment: kind, locationName, specialty, summary=<none>, dateTime=<none>
 ;;  fields.factor: recorded, dateTime=<none>
 ;;  fields.immunization: administeredDateTime, dateTime=<none>
 ;;  fields.med: overallStart, overallStop, medStatusName, dateTime=<none>
 ;;  fields.obs: observed, dateTime=<none>
 ;;  fields.order: start, stop, dateTime=<none>
 ;;  fields.problem: statusName, dateTime=<none>
 ;;  fields.procedure: typeName, summary=<none>
 ;;  fields.surgery: typeName, summary=<none>
 ;;  fields.image: typeName, summary=<none>
 ;;  fields.lab: observed, typeName, specimen, result, units, interpretationName, low, high, comment, summary=<none>, dateTime=<none>
 ;;  fields.vital: observed, typeName, result, units, interpretationName, low, high, summary=<none>, dateTime=<none>
 ;;  fields.patient: pid, dateOfBirth, died, familyName, givenNames, displayName, genderName, ssn, icn, sensitive, summary=<none>, dateTime=<none>, facilityName=<none>
 ;;child-document
 ;;  collections: document
 ;;  directives: exclude, applyOnSave
 ;;  fields: localId
 ;;notext
 ;;  collections: document
 ;;  directives: exclude, applyOnSave
 ;;  fields: content, text
 ;;dose
 ;;  collections: med
 ;;  directives: include, applyOnSave
 ;;  fields: uid, qualifiedName, kind, medStatusName, facilityName, lastFilled, vaStatus, vaType, overallStart, overallStop, dosages[].dose, dosages[].start, dosages[].stop,dosages[].relativeStop,dosages[].relativeStart,orders[].fillsRemaining,orders[].daysSupply,orders[].quantityOrdered,orders[].predecessor,orders[].successor
 ;;identifiers
 ;;  collections: allergy,consult,document,visit,appointment,factor,immunization,med,obs,order,problem,procedure,surgery,image,lab,vital,patient
 ;;  directives: include, applyOnSave
 ;;  fields: uid, pid, localId
 ;;
 ;;unit-test-general
 ;;  collections: utesta, utestb
 ;;  directives: include, applyOnSave
 ;;  fields: uid, clinicians=authors[*/].provider.name, dateTime, lastFill=fills[-1].*, ingredients[].name=products[].ingredient
 ;;  fields.utestb: dateTime=adminDateTime
 ;;unit-test-instance
 ;;  collections: utesta
 ;;  directives: include, applyOnSave
 ;;  fields: uid, qualifiedName, dose=dosages[#].dose, start=dosages[#].start, stop=dosages[#].stop
 ;;unit-test-exclude
 ;;  collections: utesta
 ;;  directives: exclude, applyOnSave
 ;;  fields: content, fills, products[].drugClass
 ;;unit-test-summary
 ;;  collections: utesta,utestb,utestc
 ;;  directives: include, applyOnSave
 ;;  fields: uid, dateTime, facilityName, summary
 ;;  fields.utestb: dateTime=adminDateTime
 ;;  fields.utestc: name, dateTime=<none>, summary=<none>
 ;;unit-test-expand-1
 ;;  collections: utestc
 ;;  directives: include, applyOnSave
 ;;  fields: uid, localId, from>from
 ;;unit-test-expand-2
 ;;  collections: utestc
 ;;  directives: include, applyOnSave
 ;;  fields: uid, items[]>items[].uid
 ;;unit-test-query
 ;;  collections: utestc
 ;;  directives: include, applyOnQuery
 ;;  fields: uid, localId, name, text
 ;;zzzzz

VPRJPMX^INT^1^63417;48849^0
VPRJPMX ;SLC/KCM -- Meta data for JSON indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Types of collation:
 ;       V: Inverse HL7 Time (appends "=" after complementing time)
 ;       T: Forward HL7 Time (appends " " to time)
 ;       N: Numeric          (+value)
 ;       S: String           (appends " " to ensure string)
 ;       s: String           (case insensitive, appends " " to ensure string)
 ;       P: Plain            (uses value as is)
 ;       p: Plain            (case insensitive, use value as is)
 ;
 ; --------------------------------------------------------
 ; List type indexes are special case of attribute indexes.  The have 0 or 1
 ; fields, used for default sorting.  The definition structure is:
 ;
 ;;indexName
 ;;    collections: {collection}, {collection}, ...
 ;;    fields: {fieldName}({collation},{ifNull})  -or-  <none>
 ;;    sort:  {default orderBy string}  -or-  <none>
IDXLIST ; list type indexes (sortType defaults to string)
 ;;allergy
 ;;    collections: allergy
 ;;    fields: <none>
 ;;    sort: <none>
 ;;consult
 ;;    collections: consult
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;document
 ;;    collections: document
 ;;    fields: referenceDateTime/V/0
 ;;    sort: referenceDateTime desc
 ;;parent-documents
 ;;    collections: document, procedure, surgery, image, consult
 ;;    fields: dateTime/V/0
 ;;    fields.document: referenceDateTime
 ;;    sort: dateTime descs
 ;;    setif: $$PRNTDOCS^VPRJFPS
 ;;encounter
 ;;    collections: visit, appointment
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;healthfactor
 ;;    collections: factor
 ;;    fields: recorded/V/0
 ;;    sort: recorded desc
 ;;imaging
 ;;    collections: image
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;immunization
 ;;    collections: immunization
 ;;    fields: administeredDateTime/V/0
 ;;    sort: administeredDateTime desc
 ;;laboratory
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$RSLT^VPRJFPS
 ;;result
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$RSLT^VPRJFPS
 ;;accession
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$ACC^VPRJFPS 
 ;;medication
 ;;    collections: med
 ;;    fields: overallStop/V/0
 ;;    sort: overallStop desc
 ;;microbiology
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$MICRO^VPRJFPS
 ;;observation
 ;;    collections: obs
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;order
 ;;    collections: order
 ;;    fields: entered/V/0
 ;;    sort: entered desc
 ;;order-status
 ;;    collections: order
 ;;    fields: statusName/V/0
 ;;    sort: entered desc
 ;;pathology
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$PATH^VPRJFPS
 ;;problem
 ;;    collections: problem
 ;;    fields: <none>
 ;;    sort: <none>
 ;;problem-active
 ;;    collections: problem
 ;;    fields: onset/V/0
 ;;    sort: onset desc
 ;;    setif: $$PACT^VPRJFPS
 ;;problem-inactive
 ;;    collections: problem
 ;;    fields: onset/V/0
 ;;    sort: onset desc
 ;;    setif: $$PIACT^VPRJFPS
 ;;problem-both
 ;;    collections: problem
 ;;    fields: onset/V/0
 ;;    sort: onset desc
 ;;    setif: $$PBOTH^VPRJFPS
 ;;problem-removed
 ;;    collections: problem
 ;;    fields: onset/V/0
 ;;    sort: onset desc
 ;;    setif: $$PRMVD^VPRJFPS
 ;;procedure
 ;;    collections: procedure,surgery,image,consult
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;vitalsign
 ;;    collections: vital
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;    setif: $$VS^VPRJFPS
 ;;notesview
 ;;    collections: document, procedure, surgery, image, consult
 ;;    fields: dateTime/V/0
 ;;    fields.document: referenceDateTime
 ;;    sort: dateTime desc
 ;;cwad
 ;;    collections: document, allergy, alert
 ;;    fields: referenceDateTime/V/0
 ;;    sort: referenceDateTime desc
 ;;    setif: $$CWAD^VPRJFPS
 ;;med-active-inpt
 ;;    collections: med
 ;;    fields: overallStop/V/9
 ;;    sort: overallStop desc
 ;;    setif: $$IACT^VPRJFPS
 ;;med-active-outpt
 ;;    collections: med
 ;;    fields: overallStop/V/9
 ;;    sort: overallStop desc
 ;;    setif: $$OACT^VPRJFPS 
 ;;appointment
 ;;    collections: appointment
 ;;    fields: dateTime/V/9
 ;;    sort: dateTime desc
 ;;curvisit
 ;;    collections: visit
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;    setif: $$CURVISIT^VPRJFPS
 ;;task
 ;;    collections: task
 ;;    fields: <none>
 ;;    sort: <none>
 ;;diagnosis
 ;;    collections: diagnosis
 ;;    fields: <none>
 ;;    sort: <none>
 ;;roadtrip
 ;;    collections: roadtrip
 ;;    fields: <none>
 ;;    sort: <none>
 ;;auxiliary
 ;;    collections: auxiliary
 ;;    fields: <none>
 ;;    sort: <none>
 ;;treatment
 ;;    collections: treatment
 ;;    fields: <none>
 ;;    sort: <none>
 ;;mentalhealth
 ;;    collections: mh
 ;;    fields: administeredDateTime/V/0
 ;;    sort: administeredDateTime desc
 ;;visittreatment
 ;;    collections: ptf
 ;;    fields: <none>
 ;;    sort: <none>
 ;;exam
 ;;    collections: exam
 ;;    fields: <none>
 ;;    sort: <none>
 ;;visitcptcode
 ;;    collections: cpt
 ;;    fields: <none>
 ;;    sort: <none>
 ;;educationtopic
 ;;    collections: education
 ;;    fields: <none>
 ;;    sort: <none>
 ;;purposeofvisit
 ;;    collections: pov
 ;;    fields: <none>
 ;;    sort: <none>
 ;;skintest
 ;;    collections: skin
 ;;    fields: <none>
 ;;    sort: <none>
 ;;patsyncerr
 ;;    collections: pat
 ;;    fields: syncErrorCount
 ;;    sort: syncErrorCount desc
 ;;    setif:$$SYNCERR^VPRJFPS
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Tally time indexes maintain counts of each value a field takes on
 ; The definition structure is:
 ;
 ;;indexName
 ;;    fields.{collection}: {tallyField}
IDXTALLY ; tally type indexes
 ;;kind
 ;;    collections: lab, med, vital
 ;;    fields: kind
 ;;lab-count-name
 ;;    collections: lab
 ;;    fields: qualifiedName
 ;;vs-count-name
 ;;    collections: vital
 ;;    fields: typeName
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Time type indexes organize data by start and stop times.
 ; the structure is:
 ; 
 ;;indexName
 ;;    fields.{collection}: {startField}, {stopField}
IDXTIME ; time type indexes
 ;;all-time
 ;;    collections: allergy,appointment,consult,document,image,immunization,lab,med,mh,obs,order,problem,procedure,roadtrip,surgery,task,treatment,visit,vital
 ;;    fields: start/V/0, stop/V/9
 ;;    fields.allergy: entered
 ;;    fields.appointment: dateTime
 ;;    fields.consult: dateTime
 ;;    fields.document: referenceDateTime
 ;;    fields.image: dateTime
 ;;    fields.immunization: administeredDateTime
 ;;    fields.lab: observed
 ;;    fields.med: overallStart, overallStop
 ;;    fields.mh: administeredDateTime
 ;;    fields.obs: observed
 ;;    fields.order: start,stop
 ;;    fields.problem: onset
 ;;    fields.procedure: dateTime
 ;;    fields.roadtrip: date
 ;;    fields.surgery: dateTime
 ;;    fields.task: dueDate
 ;;    fields.treatment: dueDate
 ;;    fields.visit: dateTime
 ;;    fields.vital: observed
 ;;    sort: start desc
 ;;lab-time
 ;;    collections: lab
 ;;    fields: observed/V/0
 ;;    sort: observed descd
 ;;med-time
 ;;    collections: med
 ;;    fields: overallStart/V/0, overallStop/V/9
 ;;    sort: overallStart desc
 ;;vs-time
 ;;    collections: vital
 ;;    fields: observed/V/0
 ;;    sort: observed desc
 ;;visit-time
 ;;    collections:visit
 ;;    fields: dateTime/V/0
 ;;    sort: dateTime desc
 ;;    setif: $$NOOS^VPRJFPS
 ;;news-feed
 ;;    collections:consult,immunization,procedure,surgery,visit
 ;;    fields: dateTime/V
 ;;    fields.immunization: administeredDateTime
 ;;    fields.visit: dateTime|stay.dischargeDateTime
 ;;    sort: dateTime desc
 ;;    setif: $$NEWS^VPRJFPS
 ;;utest-time
 ;;    collections: utestc
 ;;    fields: stay.started|updated/V
 ;;    sort: updated desc
 ;;    setif: $$NOTORNG^VPRJFTST
 ;;zzzzz
 ;
 ; --------------------------------------------------------
 ; Attribute type indexes index first by field, then by sort
 ; The first collation is the field collation, followed by the sort collation.
 ; The default is s,s (both case-insensitive strings) if no other collation
 ; is defined.
IDXATTR ;
 ;;utest
 ;;    collections: utesta, utestb
 ;;    fields: <none>
 ;;    sort: <none>
 ;;utest-c
 ;;    collections: utestc
 ;;    fields: name/s
 ;;    sort: name
 ;;lab-lnc-code
 ;;    collections: lab
 ;;    fields: lnccodes[]/s, observed/V/0
 ;;    sort: observed desc
 ;;lab-type
 ;;    collections: lab
 ;;    fields: typeName/s, observed/V/0
 ;;    sort: observed desc
 ;;vs-type
 ;;    collections: vital
 ;;    fields: typeName/s, observed/V/0
 ;;    sort: observed desc
 ;;lab-qualified-name
 ;;    collections: lab
 ;;    fields: qualifiedName/s, observed/V/0
 ;;    sort: observed desc
 ;;vs-qualified-name
 ;;    collections: vital
 ;;    fields: qualifiedName/s, observed/V/0
 ;;    sort: observed desc
 ;;med-qualified-name
 ;;    collections: med
 ;;    fields: qualifiedName/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-class-code
 ;;    collections: med
 ;;    fields: products[].drugClassCode/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-ingredient-name
 ;;    collections: med
 ;;    fields: products[].ingredientName/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;med-provider
 ;;    collections: med
 ;;    fields: orders[].provider.name/s, overallStop/V/0
 ;;    sort: overallStop desc
 ;;visit-stop-code
 ;;    collections: visit
 ;;    fields: stopCodeUid/S, dateTime/V
 ;;    sort: dateTime desc
 ;;proc-type
 ;;    collections: consult
 ;;    fields: typeName/s, dateTime/V/0
 ;;imm-name
 ;;    collections: immunization
 ;;    fields: name/s, administeredDateTime/V/0
 ;;    sort: adminisiteredDateTime desc
 ;;provider
 ;;    collections: allergy,consult,document,visit,appointment,immunization,med,order,problem,procedure,surgery,image
 ;;    fields: providerName/s, dateTime/V
 ;;    fields.allergy: enteredByName, entered
 ;;    fields.allergy: verifiedByName, entered
 ;;    fields.consult: providers[].provider.name, dateTime
 ;;    fields.document: clinicians[].clinician.name, referenceDateTime
 ;;    fields.visit: providers[].provider.name, dateTime
 ;;    fields.appointment: providers[].provider.name, dateTime
 ;;    fields.immunization: perfomer, administeredDateTime
 ;;    fields.med: orders[].provider.name, overallStop
 ;;    fields.order: providerName, start
 ;;    fields.problem: providerName, updated
 ;;    fields.procedure: providers[].provider.name, dateTime
 ;;    fields.surgery: providers[].provider.name, dateTime
 ;;    fields.image: providers[].provider.name, dateTime
 ;;    sort: dateTime desc, providerName asc
 ;;io-observations
 ;;    collections: obs
 ;;    fields: typeName, observed
 ;;    sort: observed desc, typeName asc
 ;;    setif: $$IO^VPRJFPS
 ;;docs-view
 ;;    collections: consult,document,procedure,surgery,image
 ;;    fields: dateTime/V
 ;;    fields.document: referenceDateTime
 ;;    fields.lab: observed
 ;;    sort: datetime desc
 ;;    setif: $$ALLDOC^VPRJFPS
 ;;zzzzz
 ;
 ; --------------------------------------------------------
IDXMATCH ; match type indexes (sortType defaults to string)
 ;;condition.hyperlipidemia
 ;;    collections: med
 ;;    fields: products[].ingredientName
 ;;    values: SIMVASTATIN
 ;;condition.cardiac
 ;;    collections: med
 ;;    fields: products[].drugClassCode
 ;;    values: urn:vadc:CV050,urn:vadc:CV100,urn:vadc:CV702,urn:vadc:CV250
 ;;condition.bleedingrisk
 ;;    collections: med
 ;;    fields:products[].drugClassCode
 ;;    values: urn:vadc:BL110
 ;;condition.diabetes
 ;;    collections: med
 ;;    fields: products[].drugClassCode
 ;;    values: urn:vadc:HS502
 ;;zzzzz
 ;
 ; --------------------------------------------------------
XIDXATTR ; cross-patient attribute indexes
 ;;patient
 ;;    collections: patient
 ;;    sort: name asc
 ;;alert
 ;;    collections: alert
 ;;    fields: links[].uid
 ;;    sort: referenceDateTime desc
 ;;document-all
 ;;    collections: document
 ;;    fields: uid/s
 ;;    sort: referenceDateTime desc
 ;;task-pending
 ;;    collections: task
 ;;    fields: taskName/s, createdByCode, dueDate/V/0
 ;;    sort: dueDate asc
 ;;    setif: $$TASKPND^VPRJFPS
 ;;zzzzz
 ;
 ; --------------------------------------------------------
DOMAIN ; map collections to domains
 ;;allergy:allergy
 ;;document:document
 ;;visit:encounter
 ;;appointment:encounter
 ;;factor:healthfactor
 ;;immunization:immunization
 ;;med:medication
 ;;obs:observation
 ;;order:order
 ;;consult:consult
 ;;procedure:procedure
 ;;surgery:procedure
 ;;image:procedure
 ;;consult:procedure
 ;;problem:problem
 ;;lab:laboratory
 ;;vital:vitalsign
 ;;mh:mentalhealth
 ;;patient:demographics
 ;;task:task
 ;;diagnosis:diagnosis
 ;;roadtrip:roadtrip
 ;;auxiliary:auxiliary
 ;;treatment:treatment
 ;;zzzzz

VPRJPQ^INT^1^63294;58829^0
VPRJPQ ;SLC/KCM -- Query for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;TODO: if desc order, make sure limit starts at the right end
 ;
QKEY(PID,KEY,TEMPLATE) ; Return an object given the key
 N VPRDATA,ORDER
 S TEMPLATE=$G(TEMPLATE)
 I '$D(^VPRPTJ("JSON",PID,KEY)) D SETERROR^VPRJRER(104,"Pid:"_PID_" Key:"_KEY) Q
 K ^TMP("VPRDATA",$J)
 S ^TMP("VPRDATA",$J,KEY,0)=PID,VPRDATA=1,ORDER(0)=0
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
 ;
QTALLY(PID,CNTNM) ; Return a set of counts
 ; return tallies as data:{items:[{"topic":"MEDICATION,INPT","count":4}
 I '$L(CNTNM) D SETERROR^VPRJRER(101) Q
 N BUFFER S BUFFER=""
 ;
 N TOPIC,DATA,COUNT,X
 S DATA=0,TOPIC=""
 F  S TOPIC=$O(^VPRPTI(PID,"tally",CNTNM,TOPIC)) Q:TOPIC=""  D
 . S COUNT=+^VPRPTI(PID,"tally",CNTNM,TOPIC)
 . S X=$S('DATA:"",1:",")_"{""topic"":"""_TOPIC_""",""count"":"_COUNT_"}"
 . S DATA=DATA+1,DATA(DATA)=X
 S X=$$BLDHEAD^VPRJCB(DATA) D STAGE^VPRJCB(X)
 S DATA=0 F  S DATA=$O(DATA(DATA)) Q:'DATA  D STAGE^VPRJCB(DATA(DATA))
 D STAGE^VPRJCB("]}}"),OUT^VPRJCB
 Q
 ;
 ;defined at the QINDEX level:
 ;     PID:  VPR patient identifier
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequece of the returned valuse, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QINDEX(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; query based on index
 I '$L($G(INDEX)) D SETERROR^VPRJRER(101) Q
 N VPRDATA,METHOD,CLAUSES
 S RANGE=$G(RANGE),ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=+$G(^TMP($J,"total")) S:'BAIL BAIL=999999
 M INDEX=^VPRMETA("index",INDEX,"common")
 S METHOD=$G(INDEX("method")) I '$L(METHOD) D SETERROR^VPRJRER(102,INDEX) Q
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 I METHOD="time" D QTIME^VPRJPQA
 I METHOD="attr" D QATTR^VPRJPQA
 I METHOD="every" D QEVERY^VPRJPQA
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
QFIND(PID,COLL,ORDER,BAIL,TEMPLATE,FILTER) ; return items from collection without index
 N VPRDATA,CLAUSES,PREFIX,KEY
 S ORDER=$G(ORDER),BAIL=$G(BAIL),TEMPLATE=$G(TEMPLATE),FILTER=$G(FILTER)
 S VPRDATA=+$G(^TMP($J,"total")) S:'BAIL BAIL=999999
 I $L(FILTER) D PARSE^VPRJCF(FILTER,.CLAUSES) Q:$G(HTTPERR)
 D SETORDER^VPRJCO(.ORDER) Q:$G(HTTPERR)
 K ^TMP("VPRDATA",$J)
 S PREFIX="urn:va:"_COLL_":",KEY=PREFIX
 F  S KEY=$O(^VPRPT(PID,KEY)) Q:$E(KEY,1,$L(PREFIX))'=PREFIX  D ADDONE^VPRJPQA(KEY,0)
 D BUILD^VPRJCB
 K ^TMP("VPRDATA",$J)
 Q
QLAST(PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER) ; return most recent item in the list
 N IDXLAST S IDXLAST=1
 D QINDEX(PID,INDEX,$G(RANGE),$G(ORDER),$G(BAIL),$G(TEMPLATE),$G(FILTER))
 Q

VPRJPQA^INT^1^63363;56099^0
VPRJPQA ;SLC/KCM -- Query using attribute indexes for JSON patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;TODO: if desc order, make sure limit starts at the right end
 ;
 ;defined at the QINDEX level:
 ;     PID:  VPR patient identifier
 ;   INDEX:  Name of the index
 ;   RANGE:  range of values, examples:  A..Z, GLUCOSE*>2010..2013, A,C,E
 ;   ORDER:  sequence of the returned values, examples:  desc | facilityName asc
 ;    BAIL:  maximum number of matches to return
 ;  METHOD:  style of index, "attr", "time"
 ;  FILTER:  criteria statement to further limit returned results
 ; CLAUSES:  clauses to apply filter to each object
 ;
QEVERY ; return all items (filter may be applied and order used)
 N KEY
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
QTIME ; intersect START and STOP
 ; Build ^TMP("VPRDATA",$J,time,key) with keys of objects to return
 ; When ADDONE is called, SUB(1) is start date and SUB(2) is stop date
 N START,STOP,DIR,SUB,KEY,INST,FOUND
 D PARSERNG^VPRJCR
 S SUB(1)=START(1) F  S SUB(1)=$O(^VPRPTI(PID,"time",INDEX,SUB(1))) Q:SUB(1)=""  Q:SUB(1)]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,"time",INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,"time",INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D
 . . . S SUB(2)=^VPRPTI(PID,"time",INDEX,SUB(1),KEY,INST) ; make SUB(2) the stop date
 . . . D ADDONE(KEY,INST,.SUB)
 . . . S FOUND(KEY,INST)=""
 S SUB(2)=START(1) F  S SUB(2)=$O(^VPRPTI(PID,"stop",INDEX,SUB(2))) Q:SUB(2)=""  Q:SUB(2)]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,"stop",INDEX,SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,"stop",INDEX,SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  I '$D(FOUND(KEY,INST)) D
 . . . S SUB(1)=^VPRPTI(PID,"stop",INDEX,SUB(2),KEY,INST) ; make SUB(1) the start date
 . . . D ADDONE(KEY,INST,.SUB)
 Q
QATTR ; return items where attribute value is in range
 ; Build ^TMP("VPRDATA",$J,sortkey,sortkey,...,key,instances) with keys of objects to return
 ; Expects:  VPRDATA,PID,METHOD,RANGE,INDEX,ORDER,CLAUSES,BAIL
 N START,STOP,DIR,SUB,KEY,INST
 D PARSERNG^VPRJCR
 I $G(IDXLAST)=1 D  ; handle finding last or latest items
 . S DIR(INDEX("levels"))=$S(INDEX("collate",INDEX("levels"))="V":1,1:-1)
 . I INDEX("levels")=0  D L0 Q
 . I INDEX("levels")=1  D L1 Q
 . I INDEX("levels")=2  D L2 Q
 . I INDEX("levels")=3  D L3 Q
 E  D               ; normal search loops
 . I INDEX("levels")=0  D A0 Q
 . I INDEX("levels")=1  D A1 Q
 . I INDEX("levels")=2  D A2 Q
 . I INDEX("levels")=3  D A3 Q
 Q
A0 ; unsorted list
 S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
A1 ; sorted list / attribute only
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
A3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)=START(3) F  S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY="" F  S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY)) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST="" F  S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,INST)) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
NXT1() ;
 I START(1,"collate")="L" S SUB(1)=$O(START(1,"list",SUB(1))) Q SUB(1)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1)),DIR(1))
 ;
NXT2() ;
 I START(2,"collate")="L" S SUB(2)=$O(START(2,"list",SUB(2))) Q SUB(2)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2)),DIR(2))
 ;
NXT3() ;
 I START(3,"collate")="L" S SUB(3)=$O(START(3,"list",SUB(3))) Q SUB(3)
 Q $O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3)),DIR(3))
 ;
L0 ; unsorted list
 S KEY="" S KEY=$O(^VPRPTI(PID,METHOD,INDEX,KEY),-1) Q:KEY=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,0)
 Q
L1 ; sorted list / attribute only
 S SUB(1)="" S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L2 ; two attributes / attribute with sort
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)="" S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
L3 ; three attributes
 S SUB(1)=START(1) F  S SUB(1)=$$NXT1 Q:SUB(1)=""  Q:SUB(1)]]STOP(1)  Q:VPRDATA'<BAIL  D
 . S SUB(2)=START(2) F  S SUB(2)=$$NXT2 Q:SUB(2)=""  Q:SUB(2)]]STOP(2)  Q:VPRDATA'<BAIL  D
 . . S SUB(3)="" S SUB(3)=$$NXT3 Q:SUB(3)=""  Q:SUB(3)]]STOP(3)  Q:VPRDATA'<BAIL  D
 . . . S KEY=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),"")) Q:KEY=""  Q:VPRDATA'<BAIL  D
 . . . . S INST=$O(^VPRPTI(PID,METHOD,INDEX,SUB(1),SUB(2),SUB(3),KEY,"")) Q:INST=""  Q:VPRDATA'<BAIL  D ADDONE(KEY,INST,.SUB)
 Q
ADDONE(KEY,INST,SUB) ; add uid, calculating new sort key if necessary
 ; Expects: PID,.ORDER,.CLAUSES
 I $D(CLAUSES) Q:'$$EVALAND^VPRJCF(.CLAUSES,KEY)  ;apply filter, quit if not true
 N I,SORT
 S I=0 F  S I=$O(ORDER(I)) Q:'I  S SORT(I)=$S(+ORDER(I):SUB(+ORDER(I)),1:$$SORTVAL(I))
 S VPRDATA=VPRDATA+1
 ; case
 I ORDER(0)=0 S ^TMP("VPRDATA",$J,KEY,INST)=PID Q
 I ORDER(0)=1 S ^TMP("VPRDATA",$J,SORT(1),KEY,INST)=PID Q
 I ORDER(0)=2 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),KEY,INST)=PID Q
 I ORDER(0)=3 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),KEY,INST)=PID Q
 I ORDER(0)=4 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),KEY,INST)=PID Q
 I ORDER(0)=5 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),KEY,INST)=PID Q
 I ORDER(0)=6 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),KEY,INST)=PID Q
 I ORDER(0)=7 S ^TMP("VPRDATA",$J,SORT(1),SORT(2),SORT(3),SORT(4),SORT(5),SORT(6),SORT(7),KEY,INST)=PID Q
 ; end case
 Q
 ;
 ; TODO: figure out how map alias to collection for specific instance
 ;   
SORTPID(LEVEL) ; enter here to set PID first
 ; from VPRJAQA
 N PID S PID=$O(^VPRPTJ("KEY",KEY,"")) ; first set newed PID
 Q $$SORTVAL(LEVEL)                    ; then calc sort value
 ;
SORTVAL(LEVEL) ; return a value or 0 from patient gbl for sorting
 ; Expects: PID,KEY,INST,.ORDER   derived from GETVALS^VPRJCV
 ; LEVEL is the subscript position of the sort key
 ; ORDER(LEVEL) described the value in the format returned by FLDSPEC^VPRJCD
 ; if there is no value, a 0 is used so the sort subscript remains non-null
 N CLTN
 S CLTN=0
 I ORDER(LEVEL,CLTN,"srcMethod")=0 Q $$SRTVAL0
 N IARY
 D EXPINST^VPRJCU(INST,IARY)  ; INST=a#1|b#2>b.c#3 to IARY(arrayPath)=number
 I ORDER(LEVEL,CLTN,"srcMethod")=1 Q $$SRTVAL1
 I ORDER(LEVEL,CLTN,"srcMethod")=2 Q $$SRTVAL2
 I ORDER(LEVEL,CLTN,"srcMethod")=99 Q $$SRTVALR
 Q 0
 ;
SRTVAL0() ; return value for x
 N X
 S X=$G(^VPRPT(PID,KEY,ORDER(LEVEL,CLTN,"srcPath",1)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",1),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVAL1() ; return value for x[instance].y
 N I,X
 S I=$G(IARY(ORDER(LEVEL,CLTN,"srcArrays",1,"path"))) Q:'I ""
 S X=$G(^VPRPT(PID,KEY,ORDER(LEVEL,CLTN,"srcPath",1),I,ORDER(LEVEL,CLTN,"srcPath",2)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",2),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVAL2() ; return value for x[instance].y[instance].z
 N I,J,X
 S I=$G(IARY(ORDER(LEVEL,"srcArrays",1,"path"))) Q:'I ""
 S J=$G(IARY(ORDER(LEVEL,"srcArrays",2,"path"))) Q:'J ""
 S X=$G(^VPRPT(PID,KEY,ORDER(LEVEL,CLTN,"srcPath",1),I,ORDER(LEVEL,CLTN,"srcPath",2),J,ORDER(LEVEL,CLTN,"srcPath",3)),0) I $D(^(ORDER(LEVEL,CLTN,"srcPath",3),"\s")) S X=X_" "
 Q $S(X]"":X,1:0)
 ;
SRTVALR() ; return value using indirection
 I +$G(ORDER(LEVEL,CLTN,"srcArrays"))=0 Q $G(@ORDER(LEVEL,CLTN,"srcRef"))
 N I,N,X
 D NXTNODE(1)
 Q X
NXTNODE(N) ; loop on the next node given instance
 ; FROM: GETVALR  traverse nodes using recursion
 S I(N)=$G(IARY(ORDER(LEVEL,CLTN,"srcArrays",N,"path"))) I 'I(N) S X=0 QUIT
 I N<ORDER(LEVEL,CLTN,"srcArrays") D NXTNODE(N+1) Q
 S X=$G(@ORDER(LEVEL,CLTN,"srcRef"),0) I $D(@ORDER(LEVEL,CLTN,"srcRef")@("\s")) S X=X_" "
 S:X="" X=0
 Q
 ;

VPRJPR^INT^1^63398;51312^0
VPRJPR ;SLC/KCM -- Handle RESTful operations for patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PUTPT(ARGS,BODY) ; PUTs patient demographics into the database
 N DEMOG,ERR,PID
 D DECODE^VPRJSON("BODY","DEMOG","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 I $G(DEMOG("uid"))="" D SETERROR^VPRJRER(211) QUIT ""
 S PID=$$UPDPT(.DEMOG) I '$L(PID) QUIT ""
 S DEMOG("pid")=PID
 K BODY
 D ENCODE^VPRJSON("DEMOG","BODY","ERR") I $D(ERR) D SETERROR^VPRJRER(202) QUIT ""
 Q "/vpr/"_PID_"/"_$$SAVE^VPRJPS(PID,.BODY)
 ;
UPDPT(PD,PID) ; updates PID indexes, returns PID
 ; TODO -- just make sure that
 ;         the demographics object is parsed for ICN & added or updated if necessary
 ;         the patient count is updated if we are adding the patient
 ;         the proper pid is returned
 ; .PD: patient demographics object (decoded JSON)
 ; PID: optional, passed in if known, empty for new patient
 N UID,DFN,ICN,ICV,NEWPID
 S UID=$G(PD("uid")) I '$L("uid") D SETERROR^VPRJRER(207) Q ""
 S DFN=$$DFN4OBJ("PD"),ICN=$$ICN4OBJ("PD"),ICV=$$ICV4OBJ("PD"),PID=$G(PID)
 ; figure out the PID
 I '$L(PID),$L(ICN) S PID=$G(^VPRPTJ("PID",ICN))
 I '$L(PID),$L(DFN) S PID=$G(^VPRPTJ("PID",DFN))
 I '$L(PID) S NEWPID=1
 S PID=$S($L(PID):PID,$L(DFN):DFN,$L(ICN):ICN,1:$$NXTPID) Q:'$L(PID) ""
 ; check for conflicting ICN's
 N XUID,ROOT,LROOT,XICN,XDFN,DFNS
 S ROOT="urn:va:patient:",LROOT=$L(ROOT)
 S XUID=ROOT F  S XUID=$O(^VPRPT(PID,XUID)) Q:$E(XUID,1,LROOT)'=ROOT  I XUID'=UID D
 . S XICN=$$ICN4OBJ($NA(^VPRPT(PID,XUID)))
 . I $L(ICN),$L(XICN),ICN'=XICN D SETERROR^VPRJRER(205,"ICNs:"_ICN_","_XICN) Q
 I $G(HTTPERR) Q ""
 ;
 L +^VPRPTJ("PID"):2 E  D SETERROR^VPRJRER(502) Q ""
 I $G(NEWPID) D  ; if new PID, update the patient count
 . N PCNT
 . S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 . S ^VPRPTX("count","patient","patient")=PCNT+1
 ; add ICN,DFN and PID to the PID index
 TSTART
 S ^VPRPTJ("PID",PID)=PID
 I $L(ICN) S ^VPRPTJ("PID",ICN)=PID S:PID'=ICN ^VPRPTJ("PID",PID,ICN)=""
 I $L(DFN) S ^VPRPTJ("PID",DFN)=PID S:PID'=DFN ^VPRPTJ("PID",PID,DFN)=""
 I $L(ICV) S ^VPRPTJ("PID",ICV)=PID S ^VPRPTJ("PID",PID,ICV)=""
 TCOMMIT
 L -^VPRPTJ("PID")
 Q PID
 ;
NXTPID() ; Return the next available generated PID
 N PID
 L +^VPRPTJ("PID"):2 E  D SETERROR^VPRJRER(502) Q ""
 S ^VPRPTJ("PID")=$G(^VPRPTJ("PID"))+1,PID=";"_^VPRPTJ("PID")
 L -^VPRPTJ("PID")
 Q PID
 ;
DFN4OBJ(OBJNM) ; Return DFN given object named in OBJNM
 Q $TR($P($G(@OBJNM@("uid")),":",4,5),":",";")
 ;
ICN4OBJ(OBJNM) ; Return ICN given object named in OBJNM
 Q $P($G(@OBJNM@("icn")),"V") ; strip off checksum
 ;
ICV4OBJ(OBJNM) ; Return full ICN (with checksum) from OBJNM
 Q $G(@OBJNM@("icn"))
 ;
PID(ARGS) ; Returns a proper PID for PID or ALIAS
 I '$L($G(ARGS("pid"))) D SETERROR^VPRJRER(211) Q ""
 N PID,I,X
 S PID=""
 F I=1:1:$L(ARGS("pid"),",") S X=$P(ARGS("pid"),",",I) D
 . I $G(X)[":" S X=$TR(X,":",";")
 . S X=$G(^VPRPTJ("PID",$G(X,0)))
 . S PID=PID_$S($L(PID):",",1:"")_X
 I '$L(PID) D SETERROR^VPRJRER(211)
 Q PID
 ;
GETPT(RESULT,ARGS) ; Returns patient demographics
 ;TODO: set this up so that is is returning the "local" demographics rather than the first hit
 I $$UNKARGS^VPRJCU(.ARGS,"pid,icndfn,template") Q
 I $L($G(ARGS("icndfn"))) S ARGS("pid")=ARGS("icndfn")
 N UID,PID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S UID=$O(^VPRPT(PID,"urn:va:patient:")) ; just grab the first for now
 ; TODO: create a patient object that is common across sites
 I $E(UID,1,15)'="urn:va:patient:" D SETERROR^VPRJRER(211) Q
 D QKEY^VPRJPQ(PID,UID)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
PUTOBJ(ARGS,BODY) ; PUTs an object for a patient into the database
 N PID S PID=$$PID(.ARGS) Q:'$L(PID) ""
 Q "/vpr/"_PID_"/"_$$SAVE^VPRJPS(PID,.BODY)
 ;
GETOBJ(RESULT,ARGS) ; gets an object given a UID
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 N TEMPLATE S TEMPLATE=$G(ARGS("template"))
 D QKEY^VPRJPQ(PID,$G(ARGS("uid")),TEMPLATE)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
GETUID(RESULT,ARGS) ; gets an object given a UID only (no PID)
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid,template") Q
 I '$L(ARGS("uid")) D SETERROR^VPRJRER(207) Q
 N PID S PID=$O(^VPRPTJ("KEY",ARGS("uid"),""))
 I '$L(PID) D SETERROR^VPRJRER(203) Q
 N TEMPLATE S TEMPLATE=$G(ARGS("template"))
 D QKEY^VPRJPQ(PID,ARGS("uid"),TEMPLATE)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
INDEX(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$D(^VPRMETA("index",INDEX)) D SETERROR^VPRJRER(102,INDEX) Q
 ;
 ; check to see if we can return a cached result
 N HASHSTR,HASHTS,HASH S (HASHSTR,HASHTS,HASH)=""
 S HASHSTR="vpr/index/"_PID_"/"_INDEX_"/"_RANGE_"/"_ORDER_"/"_TEMPLATE_"/"_FILTER
 I $$CACHED(PID,INDEX,HASHSTR,.HASH,.HASHTS) D  Q
 . S RESULT=$NA(^VPRTMP(HASH)),RESULT("pageable")=""
 ;
 ; otherwise prepare cache and do the regular query
 ; ^TMP($J) is killed at the beginning of each request in VPRJREQ
 S ^TMP($J,"query")=HASHSTR,^TMP($J,"timestamp")=HASHTS
 S ^TMP($J,"pid")=PID,^TMP($J,"index")=INDEX,^TMP($J,"hash")=HASH
 S ^TMP($J,"template")=TEMPLATE,^TMP($J,"total")=0
 F IDXPID=1:1:$L(PID,",") D QINDEX^VPRJPQ($P(PID,",",IDXPID),INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CACHED(PID,INDEX,HASHSTR,HASH,HASHTS) ; return TRUE if query cached and the cache is current
 ; .HASH returns the hashed value of HASHSTR
 ; .HASHTS returns the current $H of the index used
 Q:'$L(INDEX) 0  Q:'$L(PID) 0  Q:(PID[",") 0
 N MTHD
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method")) Q:'$L(MTHD) 0
 S HASHTS=$G(^VPRPTI(PID,MTHD,INDEX))
 S HASH=$$HASH^VPRJRUT(HASHSTR)
 I '$D(^VPRTMP(HASH,"query"))!'$D(^VPRTMP(HASH,"timestamp")) Q 0  ; no cached data
 I ^VPRTMP(HASH,"query")'=HASHSTR Q 0    ; hash matched, but not original string
 I ^VPRTMP(HASH,"timestamp")=HASHTS Q 1  ; timestamps match, quit true
 Q 0                                     ; default to no cached data
 ;
LAST(RESULT,ARGS) ; GET for objects by index
 I $$UNKARGS^VPRJCU(.ARGS,"pid,indexName,range,order,bail,template,filter") Q
 N PID,INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 F IDXPID=1:1:$L(PID,",") D QLAST^VPRJPQ($P(PID,",",IDXPID),INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
FIND(RESULT,ARGS) ; GET for objects using 'where' criteria
 I $$UNKARGS^VPRJCU(.ARGS,"pid,collection,order,bail,template,filter") Q
 N PID,COLL,ORDER,BAIL,TEMPLATE,FILTER,IDXPID
 S PID=$$PID(.ARGS) Q:'$L(PID)
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 F IDXPID=1:1:$L(PID,",") D QFIND^VPRJPQ($P(PID,",",IDXPID),COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
COUNT(RESULT,ARGS) ; GET for count of domain objects
 I $$UNKARGS^VPRJCU(.ARGS,"pid,countName") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D QTALLY^VPRJPQ(PID,ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLCOUNT(RESULT,ARGS) ; GET for count of objects across patients
 I $$UNKARGS^VPRJCU(.ARGS,"countName") Q
 D QCOUNT^VPRJAQ(ARGS("countName"))
 S RESULT=$NA(^TMP($J))
 Q
ALLPID(RESULT,ARGS) ; GET all PID's
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,template") Q
 D QPID^VPRJAQ
 S RESULT=$NA(^TMP($J))
 Q
ALLINDEX(RESULT,ARGS) ; GET for index across patients
 I $$UNKARGS^VPRJCU(.ARGS,"indexName,range,order,bail,template,filter") Q
 N INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER
 S INDEX=$G(ARGS("indexName"))
 S RANGE=$G(ARGS("range"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 D QINDEX^VPRJAQ(INDEX,RANGE,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
ALLFIND(RESULT,ARGS) ; GET using filter across all patients
 I $$UNKARGS^VPRJCU(.ARGS,"collection,order,bail,template,filter") Q
 N COLL,ORDER,BAIL,TEMPLATE,FILTER
 S COLL=$G(ARGS("collection"))
 S ORDER=$G(ARGS("order"))
 S BAIL=$G(ARGS("bail"))
 S TEMPLATE=$G(ARGS("template"))
 S FILTER=$G(ARGS("filter"))
 I '$L(FILTER) D SETERROR^VPRJRER(112) Q
 D QFIND^VPRJAQ(COLL,ORDER,BAIL,TEMPLATE,FILTER)
 S RESULT=$NA(^TMP($J)),RESULT("pageable")=""
 Q
CHKSUM(RESULT,ARGS) ; Get checksum for a patient
  N PID,SYSTEM
  S SYSTEM=$G(ARGS("system"))
  S PID=$$PID(.ARGS) Q:'$L(PID)
  D EN^VPRJCRC(.RESULT,SYSTEM,PID)
  Q
DELUID(RESULT,ARGS) ; DELETE an object
 I $$UNKARGS^VPRJCU(.ARGS,"pid,uid") Q
 N PID S PID=$G(^VPRPTJ("PID",$G(ARGS("pid"),"none")))
 I '$L(PID) S PID=$O(^VPRPTJ("KEY",ARGS("uid"),""))
 I '$L(PID) D SETERROR^VPRJRER(211) QUIT ""
 D DELETE^VPRJPS(PID,ARGS("uid"))
 S RESULT=$NA(^TMP($J))
 Q
DELCLTN(RESULT,ARGS) ; Delete a collection
 I $$UNKARGS^VPRJCU(.ARGS,"pid,collectionName,system") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D DELCLTN^VPRJPS(PID,$G(ARGS("collectionName")),$G(ARGS("system")))
 S RESULT=""
 Q
DELPT(RESULT,ARGS) ; DELETE a patient
 I $$UNKARGS^VPRJCU(.ARGS,"pid") Q
 N PID S PID=$$PID(.ARGS) Q:'$L(PID)
 D CLEARPT^VPRJPS(PID)
 S RESULT=""
 Q
DELALL(RESULT,ARGS) ; DELETE the entire VPR store
 I $$UNKARGS^VPRJCU(.ARGS,"confirm") Q
 I $G(ARGS("confirm"))'="true" D SETERROR^VPRJRER(405) Q
 D KILLDB^VPRJ2P
 S RESULT=""
 Q

VPRJPS^INT^1^63398;51312^0
VPRJPS ;SLC/KCM -- Save / Retrieve Patient-Related JSON objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SAVE(PID,JSON) ; Save a JSON encoded object
 N UID,COLL,KEY,OBJECT,OLDOBJ,VPRJERR,INDEXER,TLTARY
 ;
 ; decode JSON into object and extract required fields
 D DECODE^VPRJSON("JSON","OBJECT","VPRJERR")
 I $L($G(VPRJERR)) D SETERROR^VPRJRER(202,VPRJERR) QUIT ""
 S UID=$G(OBJECT("uid")) I '$L(UID) D SETERROR^VPRJRER(207) QUIT ""
 ;
 ; Parse out the collection, and key from the UID
 ; Currently assuming UID is urn:va:type:vistaAccount:localId...
 ; For example:  urn:va:med:93EF:34014
 N COLL S COLL=$P(UID,":",3)
 I '$L(COLL) D SETERROR^VPRJRER(210,UID) QUIT ""
 ;
 ; TODO: replace with a general facility for pre-actions based on collection?
 ; Next statement is special processing when patient demographics are updated
 ;   (DEMOG is defined if UPDPT has been called already)
 I COLL="patient",'$D(DEMOG) S PID=$$UPDPT^VPRJPR(.OBJECT,PID) Q:'$L(PID) ""
 ;
 L +^VPRPT(PID,UID):2 E  D SETERROR^VPRJRER(502) QUIT ""
 ; kill the old indexes and object
 S OLDOBJ="" M OLDOBJ=^VPRPT(PID,UID)
 D BLDTLT^VPRJCT1(COLL,.OBJECT,.TLTARY) Q:$G(HTTPERR) ""
 TSTART
 K ^VPRPT(PID,UID)
 K ^VPRPTJ("JSON",PID,UID)
 ;
 S ^VPRPTJ("KEY",UID,PID)=""
 M ^VPRPTJ("JSON",PID,UID)=JSON
 M ^VPRPTJ("TEMPLATE",PID,UID)=TLTARY
 M ^VPRPT(PID,UID)=OBJECT
 D INDEX^VPRJPX(PID,UID,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,UID)
 S ^VPRPTI(PID,"every","every")=$H  ; timestamps latest update for this PID
 ;
 Q $$URLENC^VPRJRUT(UID)  ; no errors
 ;
DELETE(PID,KEY) ; Delete an object given its UID
 N OLDOBJ,OBJECT,COLL
 S COLL=$P(KEY,":",3)
 I '$L(COLL) D SETERROR^VPRJRER(210,KEY) QUIT
 I COLL="patient" D SETERROR^VPRJRER(413,KEY) QUIT ; must delete entire patient instead
 ;
 L +^VPRPT(PID,KEY):2 E  D SETERROR^VPRJRER(502) QUIT
 ; kill the old indexes and object
 S OBJECT=""
 S OLDOBJ="" M OLDOBJ=^VPRPT(PID,KEY)
 TSTART
 K ^VPRPT(PID,KEY)
 K ^VPRPTJ("KEY",KEY,PID)
 K ^VPRPTJ("JSON",PID,KEY)
 K ^VPRPTJ("TEMPLATE",PID,KEY)
 D INDEX^VPRJPX(PID,KEY,.OLDOBJ,.OBJECT)
 TCOMMIT
 L -^VPRPT(PID,KEY)
 S ^VPRPTI(PID,"every","every")=$H ; timestamps latest update for the PID
 Q
DELCLTN(PID,CLTN,SYSID) ; Delete a collection for a patient
 I '$L(CLTN) D SETERROR^VPRJRER(215) QUIT
 N ROOT,LROOT,UID
 S ROOT="urn:va:"_CLTN_":"
 I $L($G(SYSID)) S ROOT=ROOT_SYSID_":"
 S LROOT=$L(ROOT)
 L +^VPRPT(PID,ROOT):5 E  D SETERROR^VPRJRER() QUIT
 S UID=ROOT F  S UID=$O(^VPRPT(PID,UID)) Q:$E(UID,1,LROOT)'=ROOT  D DELETE(PID,UID)
 L -^VPRPT(PID,ROOT)
 Q
CLEARPT(PID) ; -- Clear data for patient
 L +^VPRPT(PID):5 E  D SETERROR^VPRJRER(502) QUIT
 ; go through with cleanup even if PID not used
 N PIDUSED
 S PIDUSED=($D(^VPRPTJ("PID",PID))>0)
 ;
 N HASH ; remove cached queries
 S HASH="" F  S HASH=$O(^VPRTMP("PID",PID,HASH)) Q:HASH=""  K ^VPRTMP(HASH)
 K ^VPRTMP("PID",PID)
 ;
 N KEY ; remove the xref for UID's
 S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  K ^VPRPTJ("KEY",KEY,PID)
 ;
 D CLRXIDX^VPRJ2P(PID)  ; clear indexes of type xattr
 D CLRCODES^VPRJ2P(PID) ; clear codes in VPRPTX
 D CLREVIEW^VPRJ2P(PID) ; clear review dates in VPRPTX
 D CLRCOUNT^VPRJ2P(PID) ; decrement the cross patient counts
 ;
 N ALIAS
 S ALIAS="" F  S ALIAS=$O(^VPRPTJ("PID",PID,ALIAS)) Q:ALIAS=""  D
 . I ^VPRPTJ("PID",ALIAS)'=PID D SETERROR^VPRJRER(212) Q
 . K ^VPRPTJ("PID",ALIAS)
 K ^VPRPTJ("PID",PID)
 ;
 I PIDUSED D
 . N PCNT ; decrement the count of patients
 . L +^VPRPTJ("PID"):2 E  D SETERROR^VPRJRER(502,"patient") QUIT
 . S PCNT=$G(^VPRPTX("count","patient","patient"),0)
 . S ^VPRPTX("count","patient","patient")=PCNT-1
 . L -^VPRPTJ("PID")
 ;
 K ^VPRPTI(PID)           ; kill all indexes for the patient
 K ^VPRPT(PID)            ; kill all the data for the patient
 K ^VPRPTJ("JSON",PID)     ; kill original JSON objects for the patient
 K ^VPRPTJ("TEMPLATE",PID) ; kill the pre-compiled JSON objects for the patient
 L -^VPRPT(PID)
 I 'PIDUSED D SETERROR^VPRJRER(214) QUIT
 Q

VPRJPX^INT^1^63383;38904^0
VPRJPX ;SLC/KCM -- Index a JSON object
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
INDEX(PID,KEY,OLDOBJ,NEWOBJ) ; Index this object identified by its KEY
 N IDXCOLL,IDXNAME
 ; Currently assuming UID is urn:va:type:vistaAccount:localId...
 ; For example:  urn:va:med:93EF:34014
 N VPRCONST D CONST
 S IDXCOLL=$P(KEY,":",3)
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"index",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRMETA("index",IDXNAME,"collection",IDXCOLL)
 . I IDXMETA("method")="tally" D TALLY Q
 . I IDXMETA("method")="time"  D TIME Q
 . I IDXMETA("method")="attr"  D ATTRIB^VPRJPXA Q
 . I IDXMETA("method")="xattr" D XATTR^VPRJPXA Q
 S IDXNAME="" F  S IDXNAME=$O(^VPRMETA("collection",IDXCOLL,"link",IDXNAME)) Q:IDXNAME=""  D
 . N IDXMETA
 . M IDXMETA=^VPRMETA("link",IDXNAME,"collection",IDXCOLL)
 . D REVERSE
 ;D CODES (do this later -- when we add in support for matches)
 D COUNTS
 Q
 ;
 ; ----- Maintain counts of objects -----
 ;
COUNTS ; set counts for different collection types
 N DOMAIN
 D KCOUNT("collection",IDXCOLL,.OLDOBJ)
 D SCOUNT("collection",IDXCOLL,.NEWOBJ)
 S DOMAIN=$G(^VPRMETA("collection",IDXCOLL,"domain")) Q:DOMAIN=""
 D KCOUNT("domain",DOMAIN,.OLDOBJ)
 D SCOUNT("domain",DOMAIN,.NEWOBJ)
 Q
SCOUNT(GROUP,TOPIC,OBJECT) ; Increment a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 S ^VPRPTI(PID,"tally",GROUP,TOPIC)=TALLY+1 ; incr count for patient
 ;
 L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRER(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRPTX("count",GROUP,TOPIC))
 S ^VPRPTX("count",GROUP,TOPIC)=TALLY+1 ; incr count across patients
 L -^VPRPTX("count",GROUP,TOPIC)
 Q
KCOUNT(GROUP,TOPIC,OBJECT) ; Decrement a count index
 Q:$D(OBJECT)<10
 N TALLY
 S TALLY=+$G(^VPRPTI(PID,"tally",GROUP,TOPIC))
 S ^VPRPTI(PID,"tally",GROUP,TOPIC)=TALLY-1 ; decr count for patient
 ;
 L +^VPRPTX("count",GROUP,TOPIC):1 E  D SETERROR^VPRJRER(502,GROUP_" "_TOPIC) QUIT
 S TALLY=+$G(^VPRPTX("count",GROUP,TOPIC))
 S ^VPRPTX("count",GROUP,TOPIC)=TALLY-1 ; decr count across patients
 L -^VPRPTX("count",GROUP,TOPIC)
 Q
 ;
 ; ----- Index Logic: tally by attribute value -----
 ;
TALLY ; TALLY index (PID,"tally",group,value)=tally
 ; if FIELD has no value, count is not changed
 D KTALLY(.OLDOBJ)
 D STALLY(.NEWOBJ)
 S ^VPRPTI(PID,"tally",IDXNAME)=$H
 Q
STALLY(OBJECT) ; Increment a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1)))
 . S ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=TALLY+1
 Q
KTALLY(OBJECT) ; Decrement a tally index
 Q:$D(OBJECT)<10
 N VALUES,I,TALLY
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S TALLY=+$G(^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1)))
 . S ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=TALLY-1
 . I ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))=0 K ^VPRPTI(PID,"tally",IDXNAME,VALUES(I,1))
 Q
 ;
 ; ----- Index Logic: time ranges -----
 ;
TIME ; TIME index   (PID,"time",group,start,key)=stop
 ; -- if time range (PID,"stop",group,stop,key)=start
 ; expects start to always be something (0 if null), stop is optional
 D KTIME(.OLDOBJ)
 D STIME(.NEWOBJ)
 S ^VPRPTI(PID,"time",IDXNAME)=$H
 Q
STIME(OBJECT) ; Set a time based index
 Q:$D(OBJECT)<10
 Q:'$$SETIF(.OBJECT)
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . S ^VPRPTI(PID,"time",IDXNAME,VALUES(I,1),KEY,I)=$G(VALUES(I,2))
 . Q:'$L($G(VALUES(I,2)))
 . S ^VPRPTI(PID,"stop",IDXNAME,VALUES(I,2),KEY,I)=VALUES(I,1)
 Q
KTIME(OBJECT) ; Kill a time based index
 Q:$D(OBJECT)<10
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  D
 . K ^VPRPTI(PID,"time",IDXNAME,VALUES(I,1),KEY,I)
 . Q:'$L($G(VALUES(I,2)))
 . K ^VPRPTI(PID,"stop",IDXNAME,VALUES(I,2),KEY,I)
 Q
 ;
REVERSE ; REV index
 ; (PID,"rev",pointedToURN,relName,thisURN)
 D KREVERSE(.OLDOBJ)
 D SREVERSE(.NEWOBJ)
 S ^VPRPTI(PID,"rev",IDXNAME)=$H
 Q
SREVERSE(OBJECT) ; Set a relation link index
 Q:$D(OBJECT)<10
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"rev",VALUES(I,1),IDXNAME,KEY,I)=""
 Q
KREVERSE(OBJECT) ; Kill a relation link index
 Q:$D(OBJECT)<10
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"rev",VALUES(I,1),IDXNAME,KEY,I)
 Q
CODES ; code indexes
 D KCODES(.OLDOBJ)
 D SCODES(.NEWOBJ)
 Q
SCODES(OBJECT) ; set indexed codes
 Q:$D(OBJECT)<10
 N FIELD,SUB,LIST,I  ; assume max of 2 levels for now
 S FIELD="" F  S FIELD=$O(^VPRMETA("codes",IDXCOLL,FIELD)) Q:FIELD=""  D
 . I FIELD'["[]" D SETCODE(PID,KEY,$G(OBJECT(FIELD)),FIELD) Q
 . S LIST=$P(FIELD,"[]")
 . S I=0 F  S I=$O(OBJECT(LIST,I)) Q:'I  D
 . . S SUB="" F  S SUB=$O(^VPRMETA("codes",IDXCOLL,LIST,SUB)) Q:SUB=""  D SETCODE(PID,KEY,$G(OBJECT(LIST,I,SUB)),SUB)
 Q
KCODES(OBJECT) ; kill indexed codes
 Q:$D(OBJECT)<10
 N FIELD,SUB,LIST,I  ; assume max of 2 levels for now
 S FIELD="" F  S FIELD=$O(^VPRMETA("codes",IDXCOLL,FIELD)) Q:FIELD=""  D
 . I FIELD'["[]" D KILLCODE(PID,KEY,$G(OBJECT(FIELD)),FIELD) Q
 . S LIST=$P(FIELD,"[]")
 . S I=0 F  S I=$O(OBJECT(LIST,I)) Q:'I  D
 . . S SUB="" F  S SUB=$O(^VPRMETA("codes",IDXCOLL,LIST,SUB)) Q:SUB=""  D KILLCODE(PID,KEY,$G(OBJECT(LIST,I,SUB)),SUB)
 Q
SETCODE(PID,KEY,CODE,FIELD) ; Set index of all codes
 Q:'$L($G(CODE))
 S ^VPRPTX("allCodes",CODE,FIELD,PID,KEY)=""
 S ^VPRPTX("pidCodes",PID,FIELD,CODE,KEY)=""
 Q
KILLCODE(PID,KEY,CODE,FIELD) ; Kill index of all codes
 Q:'$L($G(CODE))
 K ^VPRPTX("allCodes",CODE,FIELD,PID,KEY)
 K ^VPRPTX("pidCodes",PID,FIELD,CODE,KEY)
 Q
CONST ; Set up constants for use
 S VPRCONST("SCT_MED_STATUS_ACTIVE")="urn:sct:55561003"
 S VPRCONST("SCT_MED_TYPE_OTC")="urn:sct:329505003"
 S VPRCONST("SCT_MED_TYPE_PRESCRIBED")="urn:sct:73639000"
 S VPRCONST("SCT_MED_TYPE_GENERAL")="urn:sct:105903003"
 Q
SETIF(OBJECT) ; return evaluated setif statement, otherwise return true
 ; expects IDXMETA
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q OK
 ;

VPRJPXA^INT^1^63294;58829^0
VPRJPXA ;SLC/KCM -- Attribute Style Indexes for patient (VPR) objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; ----- Index Logic: attributes by patient -----
 ;
ATTRIB ; ATTRIBUTE index (PID,"attr",group,value(s)...,key)
 D KATTRIB(.OLDOBJ)
 D SATTRIB(.NEWOBJ)
 S ^VPRPTI(PID,"attr",IDXNAME)=$H
 Q
SATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q:'OK
 I $L(IDXMETA("review")) D
 . N REVIEW,REVTM
 . S REVIEW="S REVTM="_REVIEW_"(.OBJECT)" X REVIEW
 . S ^VPRPTI(PID,"review",KEY,IDXNAME)=REVTM
 . S ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)=""
 . S ^VPRPTX("pidReview",PID,REVTM)=""
 ;
 I IDXMETA("levels")=0  D SA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D SA1  Q
 I IDXMETA("levels")=2  D SA2  Q
 I IDXMETA("levels")=3  D SA3  Q
 Q
KATTRIB(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ;
 I $L(IDXMETA("review")) D
 . N REVTM
 . S REVTM=$G(^VPRPTI(PID,"review",KEY,IDXNAME)) Q:'$L(REVTM)
 . K ^VPRPTI(PID,"review",KEY,IDXNAME)
 . K ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)
 . K ^VPRPTX("pidReview",PID,REVTM)
 ;
 I IDXMETA("levels")=0  D KA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D KA1  Q
 I IDXMETA("levels")=2  D KA2  Q
 I IDXMETA("levels")=3  D KA3  Q
 Q
SA0 ; unsorted list set logic
 S ^VPRPTI(PID,"attr",IDXNAME,KEY)=""
 Q
KA0 ; unsorted list kill logic
 K ^VPRPTI(PID,"attr",IDXNAME,KEY)
 Q
SA1 ; one attribute set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),KEY,I)=""
 Q
KA1 ; one attribute kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),KEY,I)
 Q
SA2 ; two attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)=""
 Q
KA2 ; two attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)
 Q
SA3 ; three attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)=""
 Q
KA3 ; three attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTI(PID,"attr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)
 Q
 ;
 ; ----- Index Logic: attributes across patients -----
 ;
XATTR ; ATTRIBUTE index ("xattr",group,value(s)...,key)
 D KXATTR(.OLDOBJ)
 D SXATTR(.NEWOBJ)
 S ^VPRPTX("xattr",IDXNAME)=$H
 Q
SXATTR(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ; SETIF conditional statement is in format "$$TAG^ROUTINE"
 N OK,SETIF
 S OK=1
 I $L(IDXMETA("setif")) S OK=0,SETIF=IDXMETA("setif")_"(.OBJECT)" I @SETIF S OK=1
 Q:'OK
 I $L(IDXMETA("review")) D
 . N REVIEW,REVTM
 . S REVIEW="S REVTM="_REVIEW_"(.OBJECT)" X REVIEW
 . S ^VPRPTI(PID,"review",KEY,IDXNAME)=REVTM
 . S ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)=""
 . S ^VPRPTX("pidReview",PID,REVTM)=""
 ;
 I IDXMETA("levels")=0  D SXA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D SXA1  Q
 I IDXMETA("levels")=2  D SXA2  Q
 I IDXMETA("levels")=3  D SXA3  Q
 Q
KXATTR(OBJECT) ; Set attribute based index
 Q:$D(OBJECT)<10
 ;
 I $L(IDXMETA("review")) D
 . N REVTM
 . S REVTM=$G(^VPRPTI(PID,"review",KEY,IDXNAME)) Q:'$L(REVTM)
 . K ^VPRPTI(PID,"review",KEY,IDXNAME)
 . K ^VPRPTX("review",REVTM,PID,KEY,IDXNAME)
 . K ^VPRPTX("pidReview",PID,REVTM)
 ;
 I IDXMETA("levels")=0  D KXA0  Q
 ;
 N VALUES,I
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.IDXMETA) Q:'$D(VALUES)
 I IDXMETA("levels")=1  D KXA1  Q
 I IDXMETA("levels")=2  D KXA2  Q
 I IDXMETA("levels")=3  D KXA3  Q
 Q
SXA0 ; unsorted list set logic
 S ^VPRPTX("xattr",IDXNAME,KEY)=""
 Q
KXA0 ; unsorted list kill logic
 K ^VPRPTX("xattr",IDXNAME,KEY)
 Q
SXA1 ; one attribute set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTX("xattr",IDXNAME,VALUES(I,1),KEY,I)=""
 Q
KXA1 ; one attribute kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTX("xattr",IDXNAME,VALUES(I,1),KEY,I)
 Q
SXA2 ; two attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTX("xattr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)=""
 Q
KXA2 ; two attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTX("xattr",IDXNAME,VALUES(I,1),VALUES(I,2),KEY,I)
 Q
SXA3 ; three attributes set logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  S ^VPRPTX("xattr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)=""
 Q
KXA3 ; three attributes kill logic
 S I="" F  S I=$O(VALUES(I)) Q:I=""  K ^VPRPTX("xattr",IDXNAME,VALUES(I,1),VALUES(I,2),VALUES(I,3),KEY,I)
 Q

VPRJRCL^INT^1^63294;58829^0
VPRJRCL ;SLC/KCM -- Control the HTTP listener
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
GO(PORT) ; start up REST listener with defaults
 I $G(PORT) D SPORT(PORT)
 S PORT=$G(^VPRHTTP(0,"port"),9080)
 D SETUP^VPRJPMD             ; make sure meta data is in place
 J START^VPRJREQ(PORT)       ; start the listener
 Q
STOP ; tell the listener to stop running
 I $E($G(^VPRHTTP(0,"listener")),1,4)'="stop" S ^VPRHTTP(0,"listener")="stopping"
 Q
STOPW ; tell the listener to stop running and wait until it stops
 ; this function is interactive
 N I,X
 W !,"Stopping HTTP listener on port "_$G(^VPRHTTP(0,"port"),9080)_"."
 D STOP
 F I=1:1:12 D  Q:X="stopped"
 . S X=^VPRHTTP(0,"listener")
 . I X="stopped" W X,! Q
 . W "."
 . H 1
 I X'="stopped" W "failed to stop.  Status: ",$$STATUS,!
 Q
SPORT(PORT) ; set the port that should be listened on
 Q:'$G(PORT)
 S ^VPRHTTP(0,"port")=PORT
 Q
SLOG(LEVEL) ; set log level -  0:errors,1:headers&errors,2:raw,3:body&response
 ; ** called from VPRJREQ -- cannot be interactive **
 K ^VPRHTTP(0,"logging","path")
 S ^VPRHTTP(0,"logging")=$G(LEVEL,0)
 S ^VPRHTTP(0,"logging","start")=$S(LEVEL>0:$H,1:"")
 Q
CLEAR ; clear the logs
 K ^VPRHTTP("log")
 Q
LOG() ; return the current logging level
 Q $G(^VPRHTTP(0,"logging"),0)
 ;
PORT() ; return the HTTP port number
 Q $G(^VPRHTTP(0,"port"),9080)
 ;
STATUS() ; Return status of the HTTP listener
 ;Simple Exchange (happy path)
 ;GET /ping HTTP/1.1
 ;Host: JDSlocalhost
 ;
 ;HTTP/1.1 200 OK
 ;Content-Length: 20
 ;Content-Type: application/json
 ;Date: Wed, 15 Aug 2012 21:10:09 GMT
 ;
 ;{"status":"running"}
 ;
 I $E($G(^VPRHTTP(0,"listener")),1,4)="stop" Q ^VPRHTTP(0,"listener")
 ;
 N HTTPLOG,HTTPREQ,PORT,X
 S HTTPLOG=0,PORT=$G(^VPRHTTP(0,"port"),9080)
 O "|TCP|2":("127.0.0.1":PORT:"CT"):2 E  Q "not responding"
 U "|TCP|2"
 W "GET /ping HTTP/1.1"_$C(10,13)_"Host: JDSlocalhost"_$C(10,13,10,13),!
 F  S X=$$RDCRLF^VPRJREQ() Q:'$L(X)  D ADDHEAD^VPRJREQ(X)
 U "|TCP|2":(::"S")
 I $G(HTTPREQ("header","content-length"))>0 D RDLEN^VPRJREQ(HTTPREQ("header","content-length"),2)
 C "|TCP|2"
 S X=$P($G(HTTPREQ("body",1)),"""",4)
 I '$L(X) Q "unknown"
 Q X

VPRJREQ^INT^1^63384;42216^0
VPRJREQ ;SLC/KCM -- Listen for HTTP requests
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Listener Process ---------------------------------------
 ;
START(TCPPORT) ; set up listening for connections
 Q:$G(^VPRHTTP(0,"updating"))        ; don't allow starting during upgrade
 S ^VPRHTTP(0,"listener")="running"
 ;
 S TCPPORT=$G(TCPPORT,9080)
 S TCPIO="|TCP|"_TCPPORT
 O TCPIO:(:TCPPORT:"ACT"):15 E  U 0 W !,"error" Q
 U TCPIO
LOOP ; wait for connection, spawn process to handle it
 I $E(^VPRHTTP(0,"listener"),1,4)="stop" C TCPIO S ^VPRHTTP(0,"listener")="stopped" Q
 D CHRON
 ;
 R *X:10 I '$T G LOOP
 I '$$LCLHOST^VPRJRUT() W *-2 G LOOP ; reject & close port if not localhost
 ; 
 J CHILD:(:4:TCPIO:TCPIO):10
 I $ZA\8196#2=1 W *-2 ;job failed to clear bit
 ;
 G LOOP
 ;
 ;
CHRON ; handle events related to passage of time
 ; TODO: start job every n seconds to handle logging check, review xrefs, etc.
 ; turn off logging after 10 minutes
 I $$ESECS($G(^VPRHTTP(0,"logging","start")))>600 D SLOG^VPRJRCL(0)
 Q
ESECS(TS) ; return elapsed seconds since TS (in $H format)
 ; assumes we don't care about magnitude of larger differences
 N D,S
 S D=$H,S=$P(D,",",2),D=$P(D,",")
 S D=D-TS I D>11 Q 999999  ; just return 999999 if >11 days
 S S=S-$P(TS,",",2),S=S+(D*86400)
 Q S
 ;
 ; Child Handling Process ---------------------------------
 ;
 ; The following variables exist during the course of the request
 ; HTTPREQ contains the HTTP request, with subscripts as follow --
 ; HTTPREQ("method") contains GET, POST, PUT, HEAD, or DELETE
 ; HTTPREQ("path") contains the path of the request (part from server to ?)
 ; HTTPREQ("query") contains any query params (part after ?)
 ; HTTPREQ("header",name) contains a node for each header value
 ; HTTPREQ("body",n) contains as an array the body of the request
 ; HTTPREQ("location") stashes the location value for PUT, POST
 ; HTTPREQ("store") stashes the type of store (vpr or data)
 ;
 ; HTTPRSP contains the HTTP response (or name of global with the response)
 ; HTTPLOG indicates the logging level
 ; HTTPLOG("this") is logging level for this process only
 ; HTTPLOG("path") is a url pattern to match
 ; HTTPERR non-zero if there is an error state
 ;
CHILD ; handle HTTP requests on this connection
 S HTTPLOG("DT")=+$H  ; same timestamp used for log throughout session
 N $ET S $ET="G ETSOCK^VPRJREQ"
 ;
NEXT ; begin next request
 K HTTPREQ,HTTPRSP,HTTPERR
 K ^TMP($J),^TMP("HTTPERR",$J) ; TODO: change the namespace for the error global
 S HTTPLOG=$S($D(HTTPLOG("this")):HTTPLOG("this"),1:$G(^VPRHTTP(0,"logging"),0))
 I HTTPLOG=2,'$D(HTTPLOG("path")) S HTTPLOG("path")=$G(^VPRHTTP(0,"logging","path"))
 ;
WAIT ; wait for request on this connection
 I $E(^VPRHTTP(0,"listener"),1,4)="stop" C $P Q
 U $P:(::"CT")
 R TCPX:10 I '$T G WAIT
 I '$L(TCPX) G WAIT
 ;
 ; -- got a request and have the first line
 D INCRLOG ; set unique request id
 I HTTPLOG>3 D LOGRAW(TCPX)
 S HTTPREQ("line1")=TCPX
 S HTTPREQ("method")=$P(TCPX," ")
 S HTTPREQ("path")=$P($P(TCPX," ",2),"?")
 S HTTPREQ("query")=$P($P(TCPX," ",2),"?",2,999)
 ; TODO: time out connection after N minutes of wait 
 ; TODO: check format of TCPX and raise error if not correct
 I $E($P(TCPX," ",3),1,4)'="HTTP" G NEXT
 ;
 ; -- read the rest of the lines in the header
 F  S TCPX=$$RDCRLF() Q:'$L(TCPX)  D ADDHEAD(TCPX)
 ;
 ; -- decide how to read body, if any
 U $P:(::"S")
 ; TODO: handle chunked input of body
 I $$LOW^VPRJRUT($G(HTTPREQ("header","transfer-encoding")))="chunked" D RDCHNKS
 ; handle regular input of body
 I $G(HTTPREQ("header","content-length"))>0 D RDLEN(HTTPREQ("header","content-length"),99)
 ;
 ; -- build response (map path to routine & call, otherwise 404)   
 S $ETRAP="G ETCODE^VPRJREQ"
 S HTTPERR=0
 D RESPOND^VPRJRSP
 S $ETRAP="G ETSOCK^VPRJREQ"
 ; TODO: restore HTTPLOG if necessary
 ;
 ; -- write out the response (error if HTTPERR>0)
 U $P:(::"S")
 I $G(HTTPERR) D RSPERROR^VPRJRSP ; switch to error response
 D SENDATA^VPRJRSP
 I HTTPLOG D LOGGING
 ;
 ; -- exit on Connection: Close
 I $$LOW^VPRJRUT($G(HTTPREQ("header","connection")))="close" D  Q
 . K ^TMP($J),^TMP("HTTPERR",$J)
 . C $P
 ;
 ; -- otherwise get ready for the next request
 G NEXT
 ;
RDCRLF() ; read a header line
 ; fixes a problem where the read would terminate before CRLF
 ; (on a packet boundary or when 1024 characters had been read)
 N X,LINE,RETRY
 S LINE=""
 F RETRY=1:1 R X:1 D:HTTPLOG>3 LOGRAW(X) S LINE=LINE_X Q:$A($ZB)=13  Q:RETRY>10
 Q LINE
 ;
RDCHNKS ; read body in chunks
 Q  ; still need to implement
 ;
RDLEN(REMAIN,TIMEOUT) ; read L bytes with timeout T
 N X,LINE,LENGTH
 S LINE=0
RDLOOP ;
 ; read until L bytes collected
 ; quit with what we have if read times out
 S LENGTH=REMAIN I LENGTH>4000 S LENGTH=4000
 R X#LENGTH:TIMEOUT
 I '$T D:HTTPLOG>3 LOGRAW("timeout:"_X) S LINE=LINE+1,HTTPREQ("body",LINE)=X Q
 I HTTPLOG>3 D LOGRAW(X)
 S REMAIN=REMAIN-$L(X),LINE=LINE+1,HTTPREQ("body",LINE)=X
 G:REMAIN RDLOOP
 Q
 ;
ADDHEAD(LINE) ; add header name and header value
 ; expects HTTPREQ to be defined
 N NAME,VALUE
 S NAME=$$LOW^VPRJRUT($$LTRIM^VPRJRUT($P(LINE,":")))
 S VALUE=$$LTRIM^VPRJRUT($P(LINE,":",2,99))
 I LINE'[":" S NAME="",VALUE=LINE
 I '$L(NAME) S NAME=$G(HTTPREQ("header")) ; grab the last name used
 I '$L(NAME) Q  ; no header name so just ignore this line
 I $D(HTTPREQ("header",NAME)) D
 . S HTTPREQ("header",NAME)=HTTPREQ("header",NAME)_","_VALUE
 E  D
 . S HTTPREQ("header",NAME)=VALUE,HTTPREQ("header")=NAME
 Q
 ;
ETSOCK ; error trap when handling socket (i.e., client closes connection)
 D LOGERR
 C $P H 2
 HALT  ; exit because connection has been closed
 ;
ETCODE ; error trap when calling out to routines
 S $ETRAP="G ETBAIL^VPRJREQ"
 I $TLEVEL TROLLBACK ; abandon any transactions
 L                   ; release any locks
 ; Set the error information and write it as the HTTP response.
 D LOGERR
 D SETERROR^VPRJRER(501,"Log ID:"_HTTPLOG("ID")) ; sets HTTPERR
 D RSPERROR^VPRJRSP  ; switch to error response
 D SENDATA^VPRJRSP
 ; Leave $ECODE as non-null so that the error handling continues.
 ; This next line will 'unwind' the stack and got back to listening
 ; for the next HTTP request (goto NEXT).
 S $ETRAP="Q:$ESTACK&$QUIT 0 Q:$ESTACK  S $ECODE="""" G NEXT"
 Q
ETBAIL ; error trap of error traps
 U $P
 W "HTTP/1.1 500 Internal Server Error",$C(13,10),$C(13,10),!
 C $P H 1
 K ^TMP($J),^TMP("HTTPERR",$J)
 HALT  ; exit because we can't recover
 ;
INCRLOG ; get unique log id for each request
 N DT,ID
 S DT=HTTPLOG("DT")
 L +^VPRHTTP("log",DT):2 E  S HTTPLOG("ID")=99999 Q  ; get unique logging session
 S ID=$G(^VPRHTTP("log",DT),0)+1
 S ^VPRHTTP("log",DT)=ID
 L -^VPRHTTP("log",DT)
 S HTTPLOG("ID")=ID
 Q
LOGGING ; log non-error information based on log level
 ; HTTPLOG=0:  log hard errors only
 ; HTTPLOG=1:  log HTTP errors
 ; HTTPLOG=2:  log requests matching path specified by HTTPLOG("path")
 ; HTTPLOG=3:  log all requests
 ; HTTPLOG=4:  log raw reads
 ;
 I HTTPLOG=1,'$G(HTTPERR) Q
 I HTTPLOG=2,'$$MATCH(HTTPREQ("path"),HTTPLOG("path")) Q
 N DT,ID
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S ^VPRHTTP("log",DT,$J,ID)=$$HTE^XLFDT($H)_"  $J:"_$J_"  $P:"_$P
 S ^VPRHTTP("log",DT,$J,ID,"type")=$S($D(^VPRHTTP("log",DT,$J,ID,"error"))=1:0,1:HTTPLOG)
 S ^VPRHTTP("log",DT,$J,ID,"line1")=HTTPREQ("line1")
 M ^VPRHTTP("log",DT,$J,ID,"header")=HTTPREQ("header")
 M ^VPRHTTP("log",DT,$J,ID,"body")=HTTPREQ("body")
 I $L($G(HTTPLOG("name"))) D
 . S ^VPRHTTP("log",DT,$J,ID,"name")=HTTPLOG("name")
 . S ^VPRHTTP("log","names",HTTPLOG("name"),DT,$J,ID)="" ; xref by name
 I $G(HTTPERR) M ^VPRHTTP("log",DT,$J,ID,"error","http")=^TMP("HTTPERR",$J)
 M ^VPRHTTP("log",DT,$J,ID,"response","body")=HTTPRSP
 M ^VPRHTTP("log",DT,$J,ID,"response","request")=HTTPREQ
 Q
LOGRAW(X) ; log raw lines read in
 N DT,ID,LN
 S DT=HTTPLOG("DT"),ID=HTTPLOG("ID")
 S LN=$G(^VPRHTTP("log",DT,$J,ID,"raw"),0)+1
 S ^VPRHTTP("log",DT,$J,ID,"raw")=LN
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN)=X
 S ^VPRHTTP("log",DT,$J,ID,"raw",LN,"ZB")=$A($ZB)
 Q
LOGERR ; log error information
 N %D,%I
 S %D=HTTPLOG("DT"),%I=HTTPLOG("ID")
 S ^VPRHTTP("log",%D,$J,%I,"error")=$ZERROR_"  ($ECODE:"_$ECODE_")"
 N %LVL,%TOP,%N
 S %TOP=$STACK(-1),%N=0
 F %LVL=0:1:%TOP S %N=%N+1,^VPRHTTP("log",%D,$J,%I,"error","stack",%N)=$STACK(%LVL,"PLACE")_":"_$STACK(%LVL,"MCODE")
 N %X,%Y
 S %X="^VPRHTTP(""log"",%D,$J,%I,""error"",""symbols"","
 ;TODO make the following loop work also in GTM (DOLRO^%ZOSV)
 S %Y="%" F  M:$D(@%Y) @(%X_"%Y)="_%Y) S %Y=$O(@%Y) Q:%Y=""
 ;
 D LOGGING
 Q
MATCH(X,P,D) ;
 N I,OK,MAX
 S D=$G(D,"/")
 I '$L(P) Q 0 ; no pattern returns false
 F I=1:1:$L(X,D) S X(I)=$P(X,D,I),MAX=I
 F I=1:1:$L(P,D) S P(I)=$P(P,D,I) S:I>MAX MAX=I
 S OK=1
 F I=1:1:MAX Q:$G(P(I))="..."  D  Q:'OK
 . I $D(P(I))'=1 S OK=0 Q
 . I P(I)="*" Q
 . I $D(X(I))'=1 S OK=0 Q
 . I P(I)'=X(I) S OK=0
 Q OK
 ;

VPRJRER^INT^1^63294;58829^0
VPRJRER ;SLC/KCM -- Error Recording
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
SETERROR(ERRCODE,MESSAGE) ; set error info into ^TMP("HTTPERR",$J)
 ; causes HTTPERR system variable to be set
 ; ERRCODE:  query errors are 100-199, update errors are 200-299, M errors are 500
 ; MESSAGE:  additional explanatory material
 N NEXTERR,ERRNAME,TOPMSG
 S HTTPERR=400,TOPMSG="Bad Request"
 ; query errors (100-199)
 I ERRCODE=101 S ERRNAME="Missing name of index"
 I ERRCODE=102 S ERRNAME="Invalid index name"
 I ERRCODE=103 S ERRNAME="Parameter error"
 I ERRCODE=104 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Bad key"
 I ERRCODE=105 S ERRNAME="Template error"
 I ERRCODE=106 S ERRNAME="Bad Filter Parameter"
 I ERRCODE=107 S ERRNAME="Unsupported Field Name"
 I ERRCODE=108 S ERRNAME="Bad Order Parameter"
 I ERRCODE=109 S ERRNAME="Order requires indexed array value"
 I ERRCODE=110 S ERRNAME="Order field unknown"
 I ERRCODE=111 S ERRNAME="Unrecognized parameter"
 I ERRCODE=112 S ERRNAME="Filter required"
 I ERRCODE=113 S ERRNAME="No reverse field name"
 ; update errors (200-299)
 I ERRCODE=201 S ERRNAME="Unknown collection" ; unused?
 I ERRCODE=202 S ERRNAME="Unable to decode JSON"
 I ERRCODE=203 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine patient"
 I ERRCODE=204 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Unable to determine collection" ; unused?
 I ERRCODE=205 S ERRNAME="Patient mismatch with object"
 I ERRCODE=207 S ERRNAME="Missing UID"
 I ERRCODE=209 S ERRNAME="Missing range or index" ; unused?
 I ERRCODE=210 S ERRNAME="Unknown UID format"
 I ERRCODE=211 S HTTPERR=404,TOPMSG="Not Found",ERRNAME="Missing patient identifiers"
 I ERRCODE=212 S ERRNAME="Mismatch of patient identifiers"
 I ERRCODE=213 S ERRNAME="Delete demographics only not allowed"
 I ERRCODE=214 S HTTPERR=404,ERRNAME="Patient ID not found in database"
 I ERRCODE=215 S ERRNAME="Missing collection name"
 I ERRCODE=216 S ERRNAME="Incomplete deletion of collection"
 I ERRCODE=217 S ERRNAME="JSON parsing error"
 I ERRCODE=218 S ERRNAME="Template encoding error"
 I ERRCODE=219 S ERRNAME="Template not found"
 ; HTTP errors
 I ERRCODE=400 S ERRNAME="Bad Request"
 I ERRCODE=404 S ERRNAME="Not Found"
 I ERRCODE=405 S ERRNAME="Method Not Allowed"
 ; system errors (500-599)
 I ERRCODE=501 S ERRNAME="M execution error"
 I ERRCODE=502 S ERRNAME="Unable to lock record"
 I '$L($G(ERRNAME)) S ERRNAME="Unknown error"
 ;
 I ERRCODE>500 S HTTPERR=500,TOPMSG="Internal Server Error"  ; M Server Error
 I ERRCODE<500,ERRCODE>400 S HTTPERR=ERRCODE,TOPMSG=ERRNAME  ; Other HTTP Errors 
 S NEXTERR=$G(^TMP("HTTPERR",$J,0),0)+1,^TMP("HTTPERR",$J,0)=NEXTERR
 S ^TMP("HTTPERR",$J,1,"apiVersion")="1.0"
 S ^TMP("HTTPERR",$J,1,"error","code")=HTTPERR
 S ^TMP("HTTPERR",$J,1,"error","message")=TOPMSG
 S ^TMP("HTTPERR",$J,1,"error","request")=$G(HTTPREQ("method"))_" "_$G(HTTPREQ("path"))_" "_$G(HTTPREQ("query"))
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"reason")=ERRCODE
 S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"message")=ERRNAME
 I $L($G(MESSAGE)) S ^TMP("HTTPERR",$J,1,"error","errors",NEXTERR,"domain")=MESSAGE
 Q

VPRJRSP^INT^1^63398;51312^0
VPRJRSP ;SLC/KCM -- Handle HTTP Response
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; -- prepare and send RESPONSE
 ;
RESPOND ; find entry point to handle request and call it
 ; expects HTTPREQ, HTTPRSP is used to return the response
 ;
 ; TODO: check cache of HEAD requests first and return that if there?
 K ^TMP($J)
 N ROUTINE,LOCATION,HTTPARGS,HTTPBODY,LOWPATH
 D MATCH(.ROUTINE,.HTTPARGS) I $G(HTTPERR) QUIT
 D QSPLIT(.HTTPARGS) I $G(HTTPERR) QUIT
 S HTTPREQ("paging")=$G(HTTPARGS("start"),0)_":"_$G(HTTPARGS("limit"),999999)
 S LOWPATH=$$LOW^VPRJRUT(HTTPREQ("path"))
 S HTTPREQ("store")=$S($E(LOWPATH,2,9)="vpr/all/":"xvpr",$E(LOWPATH,2,4)="vpr":"vpr",1:"data")
 ; treat PUT and POST the same for now (we always replace objects when updating)
 I "PUT,POST"[HTTPREQ("method") D  QUIT
 . N BODY
 . M BODY=HTTPREQ("body") K:'$G(HTTPLOG) HTTPREQ("body")
 . X "S LOCATION=$$"_ROUTINE_"(.HTTPARGS,.BODY)"
 . I $L(LOCATION) S HTTPREQ("location")=$S($D(HTTPREQ("header","host")):"http://"_HTTPREQ("header","host")_LOCATION,1:LOCATION)
 ; otherwise treat as GET
 D @(ROUTINE_"(.HTTPRSP,.HTTPARGS)")
 Q
QSPLIT(QUERY) ; parses and decodes query fragment into array
 ; expects HTTPREQ to contain "query" node
 ; .QUERY will contain query parameters as subscripts: QUERY("name")=value
 N I,X,NAME,VALUE
 F I=1:1:$L(HTTPREQ("query"),"&") D
 . S X=$$URLDEC^VPRJRUT($P(HTTPREQ("query"),"&",I))
 . S NAME=$P(X,"="),VALUE=$P(X,"=",2,999)
 . I $L(NAME) S QUERY($$LOW^VPRJRUT(NAME))=VALUE
 Q
MATCH(ROUTINE,ARGS) ; evaluate paths in sequence until match found (else 404)
 ; TODO: this needs some work so that it will accomodate patterns shorter than the path
 ; expects HTTPREQ to contain "path" and "method" nodes
 ; ROUTINE contains the TAG^ROUTINE to execute for this path, otherwise empty
 ; .ARGS will contain an array of resolved path arguments
 ;
 N SEQ,PATH,PATTERN,DONE,FAIL,I,PATHSEG,PATTSEG,TEST,ARGUMENT,METHOD,PATHOK
 S DONE=0,PATH=HTTPREQ("path"),PATHOK=0
 S:$E(PATH)="/" PATH=$E(PATH,2,$L(PATH))
 F SEQ=1:1 S PATTERN=$P($T(URLMAP+SEQ),";;",2,99) Q:PATTERN="zzzzz"  D  Q:DONE
 . K ARGS
 . S ROUTINE=$P(PATTERN," ",3),METHOD=$P(PATTERN," "),PATTERN=$P(PATTERN," ",2),FAIL=0
 . I $L(PATTERN,"/")'=$L(PATH,"/") S ROUTINE="" Q  ; must have same number segments
 . F I=1:1:$L(PATH,"/") D  Q:FAIL
 . . S PATHSEG=$$URLDEC^VPRJRUT($P(PATH,"/",I),1)
 . . S PATTSEG=$$URLDEC^VPRJRUT($P(PATTERN,"/",I),1)
 . . I $E(PATTSEG)'="{" S FAIL=($$LOW^VPRJRUT(PATHSEG)'=$$LOW^VPRJRUT(PATTSEG)) Q
 . . S PATTSEG=$E(PATTSEG,2,$L(PATTSEG)-1) ; get rid of curly braces
 . . S ARGUMENT=$P(PATTSEG,"?"),TEST=$P(PATTSEG,"?",2)
 . . I $L(TEST) S FAIL=(PATHSEG'?@TEST) Q:FAIL
 . . S ARGS(ARGUMENT)=PATHSEG
 . I 'FAIL S PATHOK=1 I METHOD'=HTTPREQ("method") S FAIL=1
 . S:FAIL ROUTINE="" S:'FAIL DONE=1
 I PATHOK,ROUTINE="" D SETERROR^VPRJRER(405,"Method Not Allowed") QUIT
 I ROUTINE="" D SETERROR^VPRJRER(404,"Not Found") QUIT
 Q
SENDATA ; write out the data as an HTTP response
 ; expects HTTPERR to contain the HTTP error code, if any
 ; RSPTYPE=1  local variable
 ; RSPTYPE=2  data in ^TMP($J)
 ; RSPTYPE=3  pageable data in ^TMP($J,"data") or ^VPRTMP(hash,"data")
 N SIZE,RSPTYPE,PREAMBLE,START,LIMIT
 S RSPTYPE=$S($E($G(HTTPRSP))'="^":1,$D(HTTPRSP("pageable")):3,1:2)
 I RSPTYPE=1 S SIZE=$$VARSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=2 S SIZE=$$REFSIZE^VPRJRUT(.HTTPRSP)
 I RSPTYPE=3 D
 . S START=$P(HTTPREQ("paging"),":"),LIMIT=$P(HTTPREQ("paging"),":",2)
 . D PAGE^VPRJRUT(.HTTPRSP,START,LIMIT,.SIZE,.PREAMBLE)
 . ; if an error was generated during the paging, switch to return the error
 . I $G(HTTPERR) D RSPERROR S RSPTYPE=2,SIZE=$$REFSIZE^VPRJRUT(.HTTPRSP)
 ;
 ; TODO: Handle HEAD requests differently
 ;       (put HTTPRSP in ^XTMP and return appropriate header)
 ; TODO: Handle 201 responses differently (change simple OK to created)
 ;
 W $$RSPLINE(),$C(13,10)
 W "Date: "_$$GMT^VPRJRUT_$C(13,10)
 I $D(HTTPREQ("location")) W "Location: "_HTTPREQ("location")_$C(13,10)
 W "Content-Type: application/json"_$C(13,10)
 W "Content-Length: ",SIZE,$C(13,10)_$C(13,10)
 I 'SIZE W $C(13,10),! Q  ; flush buffer and quit
 ;
 N I,J
 I RSPTYPE=1 D            ; write out local variable
 . I $D(HTTPRSP)#2 W HTTPRSP
 . I $D(HTTPRSP)>1 S I=0 F  S I=$O(HTTPRSP(I)) Q:'I  W HTTPRSP(I)
 I RSPTYPE=2 D            ; write out global using indirection
 . I $D(@HTTPRSP)#2 W @HTTPRSP
 . I $D(@HTTPRSP)>1 S I=0 F  S I=$O(@HTTPRSP@(I)) Q:'I  W @HTTPRSP@(I)
 I RSPTYPE=3 D            ; write out pageable records
 . W PREAMBLE
 . F I=START:1:(START+LIMIT-1) Q:'$D(@HTTPRSP@($J,I))  D
 . . I I>START W "," ; separate items with a comma
 . . S J="" F  S J=$O(@HTTPRSP@($J,I,J)) Q:'J  W @HTTPRSP@($J,I,J)
 . W "]}}"
 . K @HTTPRSP@($J)
 W $C(13,10),!  ; flush buffer
 I RSPTYPE=3,($E(HTTPRSP,1,4)="^TMP") D UPDCACHE
 Q
UPDCACHE ; update the cache for this query
 I HTTPREQ("store")="data" G UPD4DATA
 I HTTPREQ("store")="xvpr" Q  ; don't cache cross patient for now
 ; otherwise drop into VPR cache update
UPD4VPR ;
 N PID,INDEX,HASH,HASHTS,MTHD
 S PID=$G(^TMP($J,"pid")),INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(PID)  Q:'$L(INDEX)  Q:'$L(HASH)  Q:PID[","
 ;
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRPTI(PID,MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 . S ^VPRTMP("PID",PID,HASH)=""
 L -^VPRTMP(HASH)
 Q
UPD4DATA ;
 N INDEX,HASH,HASHTS,MTHD
 S INDEX=$G(^TMP($J,"index"))
 S HASH=$G(^TMP($J,"hash")),HASHTS=$G(^TMP($J,"timestamp"))
 Q:'$L(INDEX)  Q:'$L(HASH)
 ;
 S MTHD=$G(^VPRMETA("index",INDEX,"common","method"))
 L +^VPRTMP(HASH):1  E  Q
 I $G(^VPRJDX(MTHD,INDEX))=HASHTS D
 . K ^VPRTMP(HASH)
 . M ^VPRTMP(HASH)=^TMP($J)
 . S ^VPRTMP(HASH,"created")=$H
 L -^VPRTMP(HASH)
 Q
RSPERROR ; set response to be an error response
 D ENCODE^VPRJSON("^TMP(""HTTPERR"",$J,1)","^TMP(""HTTPERR"",$J,""JSON"")")
 S HTTPRSP="^TMP(""HTTPERR"",$J,""JSON"")"
 K HTTPRSP("pageable")
 Q
RSPLINE() ; writes out a response line based on HTTPERR
 I '$G(HTTPERR),'$D(HTTPREQ("location")) Q "HTTP/1.1 200 OK"
 I '$G(HTTPERR),$D(HTTPREQ("location")) Q "HTTP/1.1 201 Created"
 I $G(HTTPERR)=400 Q "HTTP/1.1 400 Bad Request"
 I $G(HTTPERR)=404 Q "HTTP/1.1 404 Not Found"
 I $G(HTTPERR)=405 Q "HTTP/1.1 405 Method Not Allowed"
 Q "HTTP/1.1 500 Internal Server Error"
 ;
PING(RESULT,ARGS) ; writes out a ping response
 S RESULT="{""status"":""running""}"
 Q
VERSION(RESULT,ARGS) ; returns version number
 S RESULT="{""version"":"""_$G(^VPRMETA("version"))_""", ""build"":"""_$G(^VPRMETA("version","build"))_"""}"
 Q
GETLOG(RESULT,ARGS) ; returns log level info
 S RESULT="{""level"":"_HTTPLOG
 I $D(HTTPLOG("path")) S RESULT=RESULT_",""path"":"_HTTPLOG("path")
 I $D(HTTPLOG("name")) S RESULT=RESULT_",""name"":"_HTTPLOG("name")
 S RESULT=RESULT_"}"
 Q
PUTLOG(ARGS,BODY) ; sets log level
 N LOG,ERR
 D DECODE^VPRJSON("BODY","LOG","ERR")
 I $D(ERR) D SETERROR^VPRJRER(217) Q
 S HTTPLOG=$G(LOG("level"))
 I $D(LOG("path")) S HTTPLOG("path")=LOG("path")
 I $D(LOG("name")) S HTTPLOG("name")=LOG("name")
 Q
VPRMATCH(ROUTINE,ARGS) ; specific algorithm for matching URL's
 Q
URLMAP ; map URLs to entry points (HTTP methods handled within entry point)
 ;;POST vpr PUTPT^VPRJPR
 ;;PUT vpr PUTPT^VPRJPR
 ;;DELETE vpr DELALL^VPRJPR
 ;;GET vpr/all/count/{countName} ALLCOUNT^VPRJPR
 ;;GET vpr/all/index/pid/pid ALLPID^VPRJPR
 ;;GET vpr/all/index/{indexName} ALLINDEX^VPRJPR
 ;;GET vpr/all/index/{indexName}/{template} ALLINDEX^VPRJPR
 ;;GET vpr/all/find/{collection} ALLFIND^VPRJPR
 ;;GET vpr/all/find/{collection}/{template} ALLFIND^VPRJPR
 ;;DELETE vpr/all/collection/{collectionName} ALLDELC^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E} GETUID^VPRJPR
 ;;GET vpr/uid/{uid?1"urn:".E}/{template} GETUID^VPRJPR
 ;;DELETE vpr/uid/{uid?1"urn:".E} DELUID^VPRJPR
 ;;GET vpr/pid/{icndfn} GETPT^VPRJPR
 ;;POST vpr/{pid} PUTOBJ^VPRJPR
 ;;PUT vpr/{pid} PUTOBJ^VPRJPR
 ;;GET vpr/{pid}/index/{indexName} INDEX^VPRJPR
 ;;GET vpr/{pid}/index/{indexName}/{template} INDEX^VPRJPR
 ;;GET vpr/{pid}/last/{indexName} LAST^VPRJPR
 ;;GET vpr/{pid}/last/{indexName}/{template} LAST^VPRJPR
 ;;GET vpr/{pid}/find/{collection} FIND^VPRJPR
 ;;GET vpr/{pid}/find/{collection}/{template} FIND^VPRJPR
 ;;GET vpr/{pid}/{uid?1"urn:".E} GETOBJ^VPRJPR
 ;;GET vpr/{pid}/{uid?1"urn:".E}/{template} GETOBJ^VPRJPR
 ;;GET vpr/{pid}/count/{countName} COUNT^VPRJPR
 ;;GET vpr/{pid} GETPT^VPRJPR
 ;;GET vpr/{pid}/checksum/{system} CHKSUM^VPRJPR
 ;;DELETE vpr/{pid}/{uid?1"urn:".E} DELUID^VPRJPR
 ;;DELETE vpr/{pid} DELPT^VPRJPR
 ;;DELETE vpr/{pid}/collection/{collectionName} DELCLTN^VPRJPR
 ;;POST data PUTOBJ^VPRJDR
 ;;PUT data PUTOBJ^VPRJDR
 ;;PUT data/{collectionName} NEWOBJ^VPRJDR
 ;;POST data/{collectionName} NEWOBJ^VPRJDR
 ;;GET data/{uid?1"urn:".E} GETOBJ^VPRJDR
 ;;GET data/{uid?1"urn:".E}/{template} GETOBJ^VPRJDR
 ;;GET data/index/{indexName} INDEX^VPRJDR
 ;;GET data/index/{indexName}/{template} INDEX^VPRJDR
 ;;GET data/last/{indexName} LAST^VPRJDR
 ;;GET data/count/{countName} COUNT^VPRJDR
 ;;GET data/find/{collection} FIND^VPRJDR
 ;;GET data/find/{collection}/{template} FIND^VPRJDR
 ;;GET data/all/count/{countName} ALLCOUNT^VPRJDR
 ;;DELETE data/{uid?1"urn:".E} DELUID^VPRJDR
 ;;DELETE data/collection/{collectionName} DELCTN^VPRJDR
 ;;DELETE data DELALL^VPRJDR
 ;;GET ping PING^VPRJRSP
 ;;GET version VERSION^VPRJRSP
 ;;GET jds/logger/this GETLOG^VPRJRSP
 ;;PUT jds/logger/this PUTLOG^VPRJRSP
 ;;POST jds/logger/this PUTLOG^VPRJRSP
 ;;zzzzz
 Q

VPRJRUT^INT^1^63294;58829^0
VPRJRUT ;SLC/KCM -- Utilities for HTTP communications
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
LTRIM(%X) ; Trim whitespace from left side of string
 ; derived from XLFSTR, but also removes tabs
 N %L,%R
 S %L=1,%R=$L(%X)
 F %L=1:1:$L(%X) Q:$A($E(%X,%L))>32
 Q $E(%X,%L,%R)
 ;
URLENC(X) ; Encode a string for use in a URL
 ; Q $ZCONVERT(X,"O","URL")  ; uncomment for fastest performance on Cache
 ; =, &, %, +, non-printable 
 ; {, } added JC 7-24-2012
 N I,Y,Z,LAST
     S Y=$P(X,"%") F I=2:1:$L(X,"%") S Y=Y_"%25"_$P(X,"%",I)
 S X=Y,Y=$P(X,"&") F I=2:1:$L(X,"&") S Y=Y_"%26"_$P(X,"&",I)
 S X=Y,Y=$P(X,"=") F I=2:1:$L(X,"=") S Y=Y_"%3D"_$P(X,"=",I)
 S X=Y,Y=$P(X,"+") F I=2:1:$L(X,"+") S Y=Y_"%2B"_$P(X,"+",I)
 S X=Y,Y=$P(X,"{") F I=2:1:$L(X,"{") S Y=Y_"%7B"_$P(X,"{",I)
 S X=Y,Y=$P(X,"}") F I=2:1:$L(X,"}") S Y=Y_"%7D"_$P(X,"}",I)
 S Y=$TR(Y," ","+")
 S Z="",LAST=1
 F I=1:1:$L(Y) I $A(Y,I)<32 D
 . S CODE=$$DEC2HEX($A(Y,I)),CODE=$TR($J(CODE,2)," ","0")
 . S Z=Z_$E(Y,LAST,I-1)_"%"_CODE,LAST=I+1
 S Z=Z_$E(Y,LAST,$L(Y))
 Q Z
 ;
URLDEC(X,PATH) ; Decode a URL-encoded string
 ; Q $ZCONVERT(X,"I","URL")  ; uncomment for fastest performance on Cache
 ;
 N I,OUT,FRAG,ASC
 S:'$G(PATH) X=$TR(X,"+"," ") ; don't convert '+' in path fragment
 F I=1:1:$L(X,"%") D
 . I I=1 S OUT=$P(X,"%") Q
 . S FRAG=$P(X,"%",I),ASC=$E(FRAG,1,2),FRAG=$E(FRAG,3,$L(FRAG))
 . I $L(ASC) S OUT=OUT_$C($$HEX2DEC(ASC))
 . S OUT=OUT_FRAG
 Q OUT
 ;
REFSIZE(ROOT) ; return the size of glvn passed in ROOT
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N SIZE,I
 S SIZE=0
 I $D(@ROOT)#2 S SIZE=$L(@ROOT)
 I $D(@ROOT)>1 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  S SIZE=SIZE+$L(@ROOT@(I))
 Q SIZE
 ;
VARSIZE(V) ; return the size of a variable
 Q:'$D(V) 0
 N SIZE,I
 S SIZE=0
 I $D(V)#2 S SIZE=$L(V)
 I $D(V)>1 S I="" F  S I=$O(V(I)) Q:'I  S SIZE=SIZE+$L(V(I))
 Q SIZE
 ;
PAGE(ROOT,START,LIMIT,SIZE,PREAMBLE) ; create the size and preamble for a page of data
 Q:'$D(ROOT) 0 Q:'$L(ROOT) 0
 N I,J,KEY,KINST,COUNT,TEMPLATE,PID
 K @ROOT@($J)
 S SIZE=0,COUNT=0,TEMPLATE=$G(@ROOT@("template"),0) ;,PID=$G(@ROOT@("pid"))
 I $L(TEMPLATE) D LOADSPEC^VPRJCT1(.TEMPLATE)
 F I=START:1:(START+LIMIT-1) Q:'$D(@ROOT@("data",I))  S COUNT=COUNT+1 D
 . S KEY="" F  S KEY=$O(@ROOT@("data",I,KEY)) Q:KEY=""  D
 . . S KINST="" F  S KINST=$O(@ROOT@("data",I,KEY,KINST)) Q:KINST=""  D
 . . . S PID=^(KINST)  ; null if non-pt data
 . . . D TMPLT(ROOT,.TEMPLATE,I,KEY,KINST,PID)
 . . . S J="" F  S J=$O(@ROOT@($J,I,J)) Q:'J  S SIZE=SIZE+$L(@ROOT@($J,I,J))
 S PREAMBLE=$$BLDHEAD(@ROOT@("total"),COUNT,START,LIMIT)
 ; add 3 for "]}}", add COUNT-1 for commas
 S SIZE=SIZE+$L(PREAMBLE)+3+COUNT-$S('COUNT:0,1:1)
 Q
TMPLT(ROOT,TEMPLATE,ITEM,KEY,KINST,PID) ; set template
 I HTTPREQ("store")="vpr"  G TLT4VPR
 I HTTPREQ("store")="data" G TLT4DATA
 I HTTPREQ("store")="xvpr" G TLT4XVPR
 ; otherwise trigger error and quit
 Q
TLT4XVPR ;
 ; set PID for this object unless just getting UID
 I TEMPLATE'="uid" N PID S PID=$O(^VPRPTJ("KEY",KEY,0))
 ; then drop thru to regular VPR template
TLT4VPR ;
 ; called from PAGE
 I TEMPLATE="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 I $E(TEMPLATE,1,4)="rel;" D RELTLTP^VPRJCT1($NA(@ROOT@($J,ITEM)),KEY,.TEMPLATE,PID) Q
 I $E(TEMPLATE,1,4)="rev;" D REVTLTP^VPRJCT1($NA(@ROOT@($J,ITEM)),KEY,.TEMPLATE,PID) Q
 ; query time template
 I $D(TEMPLATE)>1 D APPLYTLT Q
 ; saved template
 I $L(TEMPLATE),$D(^VPRPTJ("TEMPLATE",PID,KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRPTJ("JSON",PID,KEY)
 Q
TLT4DATA ;
 ; called from PAGE
 I $G(TEMPLATE)="uid" S @ROOT@($J,ITEM,1)="{""uid"":"""_KEY_"""}" Q
 I $E(TEMPLATE,1,4)="rel;" D RELTLTD^VPRJCT1($NA(@ROOT@($J,ITEM)),KEY,.TEMPLATE) Q
 I $E(TEMPLATE,1,4)="rev;" D REVTLTD^VPRJCT1($NA(@ROOT@($J,ITEM)),KEY,.TEMPLATE) Q
 ; query time template
 I $D(TEMPLATE)>1 D APPLYTLT Q
 ; other template
 I $L(TEMPLATE),$D(^VPRJDJ("TEMPLATE",KEY,TEMPLATE)) M @ROOT@($J,ITEM)=^(TEMPLATE) Q
 ; else full object
 M @ROOT@($J,ITEM)=^VPRJDJ("JSON",KEY)
 Q
APPLYTLT ; apply query time template
 ; called from TLT4VPR, TLT4XVPR, TLT4DATA
 ; expects TEMPLATE, KEY, KINST, PID, ROOT, ITEM
 ; no PID means use data store
 N OBJECT,JSON,CLTN,SPEC
 I $L(PID) M OBJECT=^VPRPT(PID,KEY) S CLTN=$P(KEY,":",3) I 1
 E  M OBJECT=^VPRJD(KEY) S CLTN=$P(KEY,":",3)
 M SPEC=TEMPLATE("collection",CLTN)
 I '$D(SPEC) D  QUIT  ; return whole object if template missing
 . I $L(PID) M @ROOT@($J,ITEM)=^VPRPTJ("JSON",PID,KEY) I 1
 . E  M @ROOT@($J,ITEM)=^VPRJDJ("JSON",KEY)
 D APPLY^VPRJCT(.SPEC,.OBJECT,.JSON,KINST)
 M @ROOT@($J,ITEM)=JSON
 Q
BLDHEAD(TOTAL,COUNT,START,LIMIT) ; Build the object header
 N X,UPDATED
 S UPDATED=$P($$FMTHL7^XLFDT($$NOW^XLFDT),"+")
 S X="{""apiVersion"":""1.0"",""data"":{""updated"":"_UPDATED_","
 S X=X_"""totalItems"":"_TOTAL_","
 S X=X_"""currentItemCount"":"_COUNT_","
 I LIMIT'=999999 D  ; only set thise if paging
 . S X=X_"""itemsPerPage"":"_LIMIT_","
 . S X=X_"""startIndex"":"_START_","
 . S X=X_"""pageIndex"":"_(START\LIMIT)_","
 . S X=X_"""totalPages"":"_(TOTAL\LIMIT+$S(TOTAL#LIMIT:1,1:0))_","
 S X=X_"""items"":["
 Q X
 ;
 ;
 ; Cache specific functions
 ;
LCLHOST() ; return TRUE if the peer connection is localhost
 I $E($I,1,5)'="|TCP|" Q 0
 N VER,ADDR
 S VER=$P($P($ZV,") ",2),"(")
 I VER<2011 S ADDR=$ZU(111,0),ADDR=$A(ADDR,1)_"."_$A(ADDR,2)_"."_$A(ADDR,3)_"."_$A(ADDR,4) I 1
 E  S ADDR=$SYSTEM.TCPDevice.PeerAddr(0)
 I ADDR="127.0.0.1" Q 1
 I ADDR="0:0:0:0:0:0:0:1" Q 1
 I ADDR="::1" Q 1
 Q 0
 ;
HASH(X) ; return CRC-32 of string contained in X
 Q $ZCRC(X,7) ; return the CRC-32 value
 ;
GMT() ; return HTTP date string (this is really using UTC instead of GMT)
 N TM,DAY
 S TM=$ZTIMESTAMP,DAY=$ZDATETIME(TM,11)
 Q $P(DAY," ")_", "_$ZDATETIME(TM,2)_" GMT"
 ;
SYSID() ; return a likely unique system ID
 N X
 S X=$ZUTIL(110)_":"_$G(^VPRHTTP("port"),9080)
 Q $ZHEX($ZCRC(X,6))
 ;
DEC2HEX(NUM) ; return a decimal number as hex
 Q $ZHEX(NUM)
 ;
HEX2DEC(HEX) ; return a hex number as decimal
 Q $ZHEX(HEX_"H")
 ;
WR4HTTP ; open file to save HTTP response
 O "VPRJT.TXT":"WNS"  ; open for writing
 U "VPRJT.TXT"
 Q
RD4HTTP() ; read HTTP body from file and return as value
 N X
 O "VPRJT.TXT":"RSD" ; for reading and delete when done
 U "VPRJT.TXT"
 F  R X:1 Q:'$L(X)  ; read lines until there is an empty one
 R X:2              ; now read the JSON object
 D C4HTTP
 Q X
 ;
C4HTTP ; close file used for HTTP response
 C "VPRJT.TXT"
 U $P
 Q
LOADFILE(FILE,BODY) ; Read from file & put into ARY(line)
 N I,LINE,EOF
 K ARY
 O FILE
 S EOF=0,I=0
         F  D READLN(.LINE) Q:EOF  S I=I+1 S BODY(I)=LINE
         C FILE
         Q
READLN(LINE) ; Read file into array
         ; expects FILE as the file handle
         ; called from LOADFILE
         N $ES,$ET
         S $ET="D CHKEOF^VPRJRUT Q"
         U FILE R LINE:5
         Q
CHKEOF   ; Check for EOF
         I $ZE["ENDOFFILE" S EOF=1,$EC=""
         Q

VPRJSON^INT^1^63335;60351^0
VPRJSON ;SLC/KCM -- Decode/Encode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2,3**;Sep 01, 2011;Build 50
 ;
 ; Note:  Since the routines use closed array references, VVROOT and VVERR
 ;        are used to reduce risk of naming conflicts on the closed array.
 ;
DECODE(VVJSON,VVROOT,VVERR)  ; Set JSON object into closed array ref VVROOT
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 G DIRECT^VPRJSOND
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 G DIRECT^VPRJSONE
 ;
 ;
ESC(X) ; Escape string for JSON
 Q $$ESC^VPRJSONE(X)
 ;
UES(X) ; Unescape JSON string
 Q $$UES^VPRJSOND(X)
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 ; switch (ID) -- XERRX ends statement
 N ERRMSG
 ;
 ; Decode Error Messages
 ;
 I ID="STL{" S ERRMSG="Stack too large for new object." G XERRX
 I ID="SUF}" S ERRMSG="Stack Underflow - extra } found" G XERRX
 I ID="STL[" S ERRMSG="Stack too large for new array." G XERRX
 I ID="SUF]" S ERRMSG="Stack Underflow - extra ] found." G XERRX
 I ID="OBM" S ERRMSG="Array mismatch - expected ] got }." G XERRX
 I ID="ARM" S ERRMSG="Object mismatch - expected } got ]." G XERRX
 I ID="MPN" S ERRMSG="Missing property name." G XERRX
 I ID="EXT" S ERRMSG="Expected true, got "_VAL G XERRX
 I ID="EXF" S ERRMSG="Expected false, got "_VAL G XERRX
 I ID="EXN" S ERRMSG="Expected null, got "_VAL G XERRX
 I ID="TKN" S ERRMSG="Unable to identify type of token, value was "_VAL G XERRX
 I ID="SCT" S ERRMSG="Stack mismatch - exit stack level was  "_VAL G XERRX
 I ID="EIQ" S ERRMSG="Close quote not found before end of input." G XERRX
 I ID="EIU" S ERRMSG="Unexpected end of input while unescaping." G XERRX
 I ID="RSB" S ERRMSG="Reverse search for \ past beginning of input." G XERRX
 I ID="ORN" S ERRMSG="Overrun while scanning name." G XERRX
 I ID="OR#" S ERRMSG="Overrun while scanning number." G XERRX
 I ID="ORB" S ERRMSG="Overrun while scanning boolean." G XERRX
 I ID="ESC" S ERRMSG="Escaped character not recognized"_VAL G XERRX
 ;
 ; Encode Error Messages
 ;
 I ID="SOB" S ERRMSG="Unable to serialize node as object, value was "_VAL G XERRX
 I ID="SAR" S ERRMSG="Unable to serialize node as array, value was "_VAL G XERRX
 S ERRMSG="Unspecified error "_ID_" "_$G(VAL)
XERRX ; end switch
 S @VVERR@(0)=$G(@VVERR@(0))+1
 S @VVERR@(@VVERR@(0))=ERRMSG
 S VVERRORS=VVERRORS+1
 Q

VPRJSOND^INT^1^63335;60351^0
VPRJSOND ;SLC/KCM -- Decode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2,3**;Sep 01, 2011;Build 50
 ;
DECODE(VVJSON,VVROOT,VVERR) ; Set JSON object into closed array ref VVROOT
 ;
DIRECT ; TAG for use by DECODE^VPRJSON
 ;
 ; Examples: D DECODE^VPRJSON("MYJSON","LOCALVAR","LOCALERR")
 ;           D DECODE^VPRJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
 ;
 ; VVJSON: string/array containing serialized JSON object
 ; VVROOT: closed array reference for M representation of object
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 ;   VVIDX: points to next character in JSON string to process
 ; VVSTACK: manages stack of subscripts
 ;  VVPROP: true if next string is property name, otherwise treat as value
 ;
 N VVMAX S VVMAX=4000 ; limit document lines to 4000 characters
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 ; If a simple string is passed in, move it to an temp array (VVINPUT)
 ; so that the processing is consistently on an array.
 I $D(@VVJSON)=1 N VVINPUT S VVINPUT(1)=@VVJSON,VVJSON="VVINPUT"
 S VVROOT=$NA(@VVROOT@("Z")),VVROOT=$E(VVROOT,1,$L(VVROOT)-4) ; make open array ref
 N VVLINE,VVIDX,VVSTACK,VVPROP,VVTYPE,VVERRORS
 S VVLINE=$O(@VVJSON@("")),VVIDX=1,VVSTACK=0,VVPROP=0,VVERRORS=0
 F  S VVTYPE=$$NXTKN() Q:VVTYPE=""  D  I VVERRORS Q
 . I VVTYPE="{" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)="",VVPROP=1 D:VVSTACK>64 ERRX("STL{") Q
 . I VVTYPE="}" D  QUIT
 . . I +VVSTACK(VVSTACK)=VVSTACK(VVSTACK),VVSTACK(VVSTACK) D ERRX("OBM") ; Numeric and true only
 . . S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF}")
 . I VVTYPE="[" S VVSTACK=VVSTACK+1,VVSTACK(VVSTACK)=1 D:VVSTACK>64 ERRX("STL[") Q
 . I VVTYPE="]" D:'VVSTACK(VVSTACK) ERRX("ARM") S VVSTACK=VVSTACK-1 D:VVSTACK<0 ERRX("SUF]") Q
 . I VVTYPE="," D  Q
 . . I +VVSTACK(VVSTACK)=VVSTACK(VVSTACK),VVSTACK(VVSTACK) S VVSTACK(VVSTACK)=VVSTACK(VVSTACK)+1  ; VEN/SMH - next in array 
 . . E  S VVPROP=1                                   ; or next property name
 . I VVTYPE=":" S VVPROP=0 D:'$L($G(VVSTACK(VVSTACK))) ERRX("MPN") Q
 . I VVTYPE="""" D  Q
 . . I VVPROP S VVSTACK(VVSTACK)=$$NAMPARS() I 1
 . . E  D ADDSTR
 . S VVTYPE=$TR(VVTYPE,"TFN","tfn")
 . I VVTYPE="t" D SETBOOL("t") Q
 . I VVTYPE="f" D SETBOOL("f") Q
 . I VVTYPE="n" D SETBOOL("n") Q
 . I "0123456789+-.eE"[VVTYPE D SETNUM(VVTYPE) Q  ;S @$$CURNODE()=$$NUMPARS(VVTYPE) Q
 . D ERRX("TKN",VVTYPE)
 I VVSTACK'=0 D ERRX("SCT",VVSTACK)
 Q
NXTKN() ; Move the pointers to the beginning of the next token
 N VVDONE,VVEOF,VVTOKEN
 S VVDONE=0,VVEOF=0 F  D  Q:VVDONE!VVEOF  ; eat spaces & new lines until next visible char
 . I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=$O(@VVJSON@(VVLINE)),VVIDX=1 I 'VVLINE S VVEOF=1 Q
 . I $A(@VVJSON@(VVLINE),VVIDX)>32 S VVDONE=1 Q
 . S VVIDX=VVIDX+1
 Q:VVEOF ""  ; we're at the end of input
 S VVTOKEN=$E(@VVJSON@(VVLINE),VVIDX),VVIDX=VVIDX+1
 Q VVTOKEN
 ;
ADDSTR ; Add string value to current node, escaping text along the way
 ; Expects VVLINE,VVIDX to reference that starting point of the index
 ; TODO: add a mechanism to specify names that should not be escaped
 ;       just store as ":")= and ":",n)=
 ;
 ; Happy path -- we find the end quote in the same line
 N VVEND,VVX
 S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 I VVEND,($E(@VVJSON@(VVLINE),VVEND-2)'="\") D SETSTR  QUIT  ;normal
 I VVEND,$$ISCLOSEQ(VVLINE) D SETSTR QUIT  ;close quote preceded by escaped \
 ;
 ; Less happy path -- first quote wasn't close quote
 N VVDONE,VVTLINE
 S VVDONE=0,VVTLINE=VVLINE ; VVTLINE for temporary increment of VVLINE
 F  D  Q:VVDONE  Q:VVERRORS
 . ;if no quote on current line advance line, scan again
 . I 'VVEND S VVTLINE=VVTLINE+1,VVEND=1 I '$D(@VVJSON@(VVTLINE)) D ERRX("EIQ") Q
 . S VVEND=$F(@VVJSON@(VVTLINE),"""",VVEND)
 . Q:'VVEND  ; continue on to next line if no quote found on this one
 . I (VVEND>2),($E(@VVJSON@(VVTLINE),VVEND-2)'="\") S VVDONE=1 Q  ; found quote position
 . S VVDONE=$$ISCLOSEQ(VVTLINE) ; see if this is an escaped quote or closing quote
 Q:VVERRORS
 ; unescape from VVIDX to VVEND, using \-extension nodes as necessary
 D UESEXT
 ; now we need to move VVLINE and VVIDX to next parsing point
 S VVLINE=VVTLINE,VVIDX=VVEND
 Q
SETSTR ; Set simple string value from within same line
 ; expects VVJSON, VVLINE, VVINX, VVEND
 N VVX
 S VVX=$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND
 S @$$CURNODE()=$$UES(VVX)
 ; "\s" node indicates value is really a string in case value 
 ;      collates as numeric or equals boolean keywords
 I VVX']]$C(1) S @$$CURNODE()@("\s")=""
 I VVX="true"!(VVX="false")!(VVX="null") S @$$CURNODE()@("\s")=""
 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1
 Q
UESEXT ; unescape from VVLINE,VVIDX to VVTLINE,VVEND & extend (\) if necessary
 ; expects VVLINE,VVIDX,VVTLINE,VVEND
 N VVI,VVY,VVSTART,VVSTOP,VVDONE,VVBUF,VVNODE,VVMORE,VVTO
 S VVNODE=$$CURNODE(),VVBUF="",VVMORE=0,VVSTOP=VVEND-2
 S VVI=VVIDX,VVY=VVLINE,VVDONE=0
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVSTART=VVI,VVI=$F(@VVJSON@(VVY),"\",VVI)
 . ; if we are on the last line, don't extract past VVSTOP
 . I (VVY=VVTLINE) S VVTO=$S('VVI:VVSTOP,VVI>VVSTOP:VVSTOP,1:VVI-2) I 1
 . E  S VVTO=$S('VVI:99999,1:VVI-2)
 . D ADDBUF($E(@VVJSON@(VVY),VVSTART,VVTO))
 . I (VVY'<VVTLINE),(('VVI)!(VVI>VVSTOP)) S VVDONE=1 QUIT  ; now past close quote
 . I 'VVI S VVY=VVY+1,VVI=1 QUIT  ; nothing escaped, go to next line
 . I VVI>$L(@VVJSON@(VVY)) S VVY=VVY+1,VVI=1 I '$D(@VVJSON@(VVY)) D ERRX("EIU")
 . N VVTGT S VVTGT=$E(@VVJSON@(VVY),VVI)
 . I VVTGT="u" D  I 1
 . . N VVTGTC S VVTGTC=$E(@VVJSON@(VVY),VVI+1,VVI+4),VVI=VVI+4
 . . I $L(VVTGTC)<4 S VVY=VVY+1,VVI=4-$L(VVTGTC),VVTGTC=VVTGTC_$E(@VVJSON@(VVY),1,VVI)
 . . D ADDBUF($C($$DEC^XLFUTL(VVTGTC,16)))
 . E  D ADDBUF($$REALCHAR(VVTGT))
 . S VVI=VVI+1
 . I (VVY'<VVTLINE),(VVI>VVSTOP) S VVDONE=1 ; VVI incremented past stop
 Q:VVERRORS
 D SAVEBUF
 Q
ADDBUF(VVX) ; add buffer of characters to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR
 I $L(VVX)+$L(VVBUF)>VVMAX D SAVEBUF
 S VVBUF=VVBUF_VVX
 Q
SAVEBUF ; write out buffer to destination
 ; expects VVBUF,VVMAX,VVNODE,VVMORE to be defined
 ; used directly by ADDSTR,ADDBUF
 I VVMORE S @VVNODE@("\",VVMORE)=VVBUF
 I 'VVMORE S @VVNODE=VVBUF I $L(VVBUF)<19,+$E(VVBUF,1,18) S @VVNODE@("\s")=""
 S VVMORE=VVMORE+1,VVBUF=""
 Q
ISCLOSEQ(VVBLINE) ; return true if this is a closing, rather than escaped, quote
 ; expects
 ;   VVJSON: lines of the JSON encoded string
 ;    VVIDX: points to 1st character of the segment
 ;   VVLINE: points to the line in which the segment starts
 ;    VVEND: points to 1st character after the " (may be past the end of the line)
 ; used directly by ADDSTR
 N VVBS,VVBIDX,VVBDONE
 S VVBS=0,VVBIDX=VVEND-2,VVBDONE=0 ; VVBIDX starts at 1st character before quote
 ; count the backslashes preceding the quote (odd number means the quote was escaped)
 F  D  Q:VVBDONE!VVERRORS
 . I VVBIDX<1 D  Q  ; when VVBIDX<1 go back a line
 . . S VVBLINE=VVBLINE-1 I VVBLINE<VVLINE D ERRX("RSB") Q
 . . S VVBIDX=$L(@VVJSON@(VVBLINE))
 . I $E(@VVJSON@(VVBLINE),VVBIDX)'="\" S VVBDONE=1 Q
 . S VVBS=VVBS+1,VVBIDX=VVBIDX-1
 Q VVBS#2=0  ; VVBS is even if this is a close quote
 ;
NAMPARS() ; Return parsed name, advancing index past the close quote
 ; -- This assumes no embedded quotes are in the name itself --
 N VVEND,VVDONE,VVNAME
 S VVDONE=0,VVNAME=""
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVEND=$F(@VVJSON@(VVLINE),"""",VVIDX)
 . I VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,VVEND-2),VVIDX=VVEND,VVDONE=1
 . I 'VVEND S VVNAME=VVNAME_$E(@VVJSON@(VVLINE),VVIDX,$L(@VVJSON@(VVLINE)))
 . I 'VVEND!(VVEND>$L(@VVJSON@(VVLINE))) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORN")
 ; prepend quote if label collates as numeric -- assumes no quotes in label
 I VVNAME']]$C(1) S VVNAME=""""""_VVNAME
 Q VVNAME
 ;
SETNUM(VVDIGIT) ; Set numeric along with any necessary modifier
 N VVX
 S VVX=$$NUMPARS(VVDIGIT)
 S @$$CURNODE()=+VVX
 ; if numeric is exponent, "0.nnn" or "-0.nnn" store original string
 I +VVX'=VVX S @$$CURNODE()@("\n")=VVX
 Q
NUMPARS(VVDIGIT) ; Return parsed number, advancing index past end of number
 ; VVIDX intially references the second digit
 N VVDONE,VVNUM
 S VVDONE=0,VVNUM=VVDIGIT
 F  D  Q:VVDONE  Q:VVERRORS
 . I '("0123456789+-.eE"[$E(@VVJSON@(VVLINE),VVIDX)) S VVDONE=1 Q
 . S VVNUM=VVNUM_$E(@VVJSON@(VVLINE),VVIDX)
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("OR#")
 Q VVNUM
 ;
SETBOOL(VVLTR) ; Parse and set boolean value, advancing index past end of value
 N VVDONE,VVBOOL,VVX
 S VVDONE=0,VVBOOL=VVLTR
 F  D  Q:VVDONE  Q:VVERRORS
 . S VVX=$TR($E(@VVJSON@(VVLINE),VVIDX),"TRUEFALSN","truefalsn")
 . I '("truefalsn"[VVX) S VVDONE=1 Q
 . S VVBOOL=VVBOOL_VVX
 . S VVIDX=VVIDX+1 I VVIDX>$L(@VVJSON@(VVLINE)) S VVLINE=VVLINE+1,VVIDX=1 I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 I VVLTR="t",(VVBOOL'="true") D ERRX("EXT",VVTYPE)
 I VVLTR="f",(VVBOOL'="false") D ERRX("EXF",VVTYPE)
 I VVLTR="n",(VVBOOL'="null") D ERRX("EXN",VVTYPE)
 S @$$CURNODE()=VVBOOL
 Q
 ;
OSETBOOL(VVX) ; set a value and increment VVIDX
 S @$$CURNODE()=VVX
 S VVIDX=VVIDX+$L(VVX)-1
 N VVDIFF S VVDIFF=VVIDX-$L(@VVJSON@(VVLINE))  ; in case VVIDX moves to next line
 I VVDIFF>0 S VVLINE=VVLINE+1,VVIDX=VVDIFF I '$D(@VVJSON@(VVLINE)) D ERRX("ORB")
 Q
CURNODE() ; Return a global/local variable name based on VVSTACK
 ; Expects VVSTACK to be defined already
 N VVI,VVSUBS
 S VVSUBS=""
 F VVI=1:1:VVSTACK S:VVI>1 VVSUBS=VVSUBS_"," D
 . I VVSTACK(VVI)=+VVSTACK(VVI) S VVSUBS=VVSUBS_VVSTACK(VVI) ; VEN/SMH Fix psudo array bug.
 . E  S VVSUBS=VVSUBS_""""_VVSTACK(VVI)_""""
 Q VVROOT_VVSUBS_")"
 ;
UES(X) ; Unescape JSON string
 ; copy segments from START to POS-2 (right before \)
 ; translate target character (which is at $F position)
 N POS,Y,START
 S POS=0,Y=""
 F  S START=POS+1 D  Q:START>$L(X)
 . S POS=$F(X,"\",START) ; find next position
 . I 'POS S Y=Y_$E(X,START,$L(X)),POS=$L(X) Q
 . ; otherwise handle escaped char
 . N TGT
 . S TGT=$E(X,POS),Y=Y_$E(X,START,POS-2)
 . I TGT="u" S Y=Y_$C($$DEC^XLFUTL($E(X,POS+1,POS+4),16)),POS=POS+4 Q
 . S Y=Y_$$REALCHAR(TGT)
 Q Y
 ;
REALCHAR(C) ; Return actual character from escaped
 I C="""" Q """"
 I C="/" Q "/"
 I C="\" Q "\"
 I C="b" Q $C(8)
 I C="f" Q $C(12)
 I C="n" Q $C(10)
 I C="r" Q $C(13)
 I C="t" Q $C(9)
 I C="u" ;case covered above in $$DEC^XLFUTL calls
 ;otherwise
 I $L($G(VVERR)) D ERRX("ESC",C)
 Q C
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJSONE^INT^1^63335;60351^0
VPRJSONE ;SLC/KCM -- Encode JSON
 ;;1.0;VIRTUAL PATIENT RECORD;**2,3**;Sep 01, 2011;Build 50
 ;
ENCODE(VVROOT,VVJSON,VVERR) ; VVROOT (M structure) --> VVJSON (array of strings)
 ;
DIRECT ; TAG for use by ENCODE^VPRJSON
 ;
 ; Examples:  D ENCODE^VPRJSON("^GLO(99,2)","^TMP($J)")
 ;            D ENCODE^VPRJSON("LOCALVAR","MYJSON","LOCALERR")
 ;
 ; VVROOT: closed array reference for M representation of object
 ; VVJSON: destination variable for the string array formatted as JSON
 ;  VVERR: contains error messages, defaults to ^TMP("VPRJERR",$J)
 ;
 S VVERR=$G(VVERR,"^TMP(""VPRJERR"",$J)")
 I '$L($G(VVROOT)) ; set error info
 I '$L($G(VVJSON)) ; set error info
 N VVLINE,VVMAX,VVERRORS
 S VVLINE=1,VVMAX=4000,VVERRORS=0  ; 96 more bytes of wiggle room
 S @VVJSON@(VVLINE)=""
 D SEROBJ(VVROOT)
 Q
 ;
SEROBJ(VVROOT) ; Serialize into a JSON object
 N VVFIRST,VVSUB,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"{"
 S VVFIRST=1
 S VVSUB="" F  S VVSUB=$O(@VVROOT@(VVSUB)) Q:VVSUB=""  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . ; get the name part
 . D SERNAME(VVSUB)
 . ; if this is a value, serialize it
 . I $$ISVALUE(VVROOT,VVSUB) D SERVAL(VVROOT,VVSUB) Q
 . ; otherwise navigate to the next child object or array
 . I $D(@VVROOT@(VVSUB))=10 S VVNXT=$O(@VVROOT@(VVSUB,"")) D  Q
 . . I +VVNXT D SERARY($NA(@VVROOT@(VVSUB))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVSUB)))
 . D ERRX("SOB",VVSUB)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"}"
 Q
SERARY(VVROOT) ; Serialize into a JSON array
 N VVFIRST,VVI,VVNXT
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"["
 S VVFIRST=1
 S VVI=0 F  S VVI=$O(@VVROOT@(VVI)) Q:'VVI  D
 . S:'VVFIRST @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"," S VVFIRST=0
 . I $$ISVALUE(VVROOT,VVI) D SERVAL(VVROOT,VVI) Q  ; write value
 . I $D(@VVROOT@(VVI))=10 S VVNXT=$O(@VVROOT@(VVI,"")) D  Q
 . . I +VVNXT D SERARY($NA(@VVROOT@(VVI))) I 1
 . . E  D SEROBJ($NA(@VVROOT@(VVI)))
 . D ERRX("SAR",VVI)  ; should quit loop before here
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_"]"
 Q
SERNAME(VVSUB) ; Serialize the object name into JSON string
 I $E(VVSUB)="""" S VVSUB=$E(VVSUB,2,$L(VVSUB)) ; quote indicates numeric label
 I ($L(VVSUB)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_""""_VVSUB_""""_":"
 Q
SERVAL(VVROOT,VVSUB) ; Serialize X into appropriate JSON representation
 N VVX,VVI,VVDONE
 ; if the node is already in JSON format, just add it
 I $D(@VVROOT@(VVSUB,":")) D  QUIT  ; <-- jump out here if preformatted
 . S VVX=$G(@VVROOT@(VVSUB,":")) D:$L(VVX) CONCAT
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,":",VVI)) Q:'VVI  S VVX=@VVROOT@(VVSUB,":",VVI) D CONCAT
 ;
 S VVX=$G(@VVROOT@(VVSUB)),VVDONE=0
 ; handle the numeric, boolean, and null types
 I $D(@VVROOT@(VVSUB,"\n")) S:$L(@VVROOT@(VVSUB,"\n")) VVX=@VVROOT@(VVSUB,"\n") D CONCAT QUIT  ; when +X'=X
 I '$D(@VVROOT@(VVSUB,"\s")),$L(VVX) D  QUIT:VVDONE
 . I VVX']]$C(1) S VVX=$$JNUM(VVX) D CONCAT S VVDONE=1 QUIT
 . I VVX="true"!(VVX="false")!(VVX="null") D CONCAT S VVDONE=1 QUIT
 ; otherwise treat it as a string type
 S VVX=""""_$$ESC(VVX) ; open quote
 D CONCAT
 I $D(@VVROOT@(VVSUB,"\")) D  ; handle continuation nodes
 . S VVI=0 F  S VVI=$O(@VVROOT@(VVSUB,"\",VVI)) Q:'VVI   D
 . . S VVX=$$ESC(@VVROOT@(VVSUB,"\",VVI))
 . . D CONCAT
 S VVX="""" D CONCAT    ; close quote
 Q
CONCAT ; come here to concatenate to JSON string
 I ($L(VVX)+$L(@VVJSON@(VVLINE)))>VVMAX S VVLINE=VVLINE+1,@VVJSON@(VVLINE)=""
 S @VVJSON@(VVLINE)=@VVJSON@(VVLINE)_VVX
 Q
ISVALUE(VVROOT,VVSUB) ; Return true if this is a value node
 I $D(@VVROOT@(VVSUB))#2 Q 1
 N VVX S VVX=$O(@VVROOT@(VVSUB,""))
 Q:VVX="\" 1  ; word processing continuation node
 Q:VVX=":" 1  ; pre-formatted JSON node
 Q 0
 ;
NUMERIC(X) ; Return true if the numeric
 I $L(X)>18 Q 0        ; string (too long for numeric)
 I X=0 Q 1             ; numeric (value is zero)
 I +X=0 Q 0            ; string
 I $E(X,1)="." Q 0     ; not a JSON number (although numeric in M)
 I $E(X,1,2)="-." Q 0  ; not a JSON number
 I +X=X Q 1            ; numeric
 I X?1"0."1.n Q 1      ; positive fraction
 I X?1"-0."1.N Q 1     ; negative fraction
 S X=$TR(X,"e","E")
 I X?.1"-"1.N.1".".N1"E".1"+"1.N Q 1  ; {-}99{.99}E{+}99
 I X?.1"-"1.N.1".".N1"E-"1.N Q 1      ; {-}99{.99}E-99
 Q 0
 ;
ESC(X) ; Escape string for JSON
 N Y,I,PAIR,FROM,TO
 S Y=X
 F PAIR="\\","""""","//",$C(8,98),$C(12,102),$C(10,110),$C(13,114),$C(9,116) D
 . S FROM=$E(PAIR),TO=$E(PAIR,2)
 . S X=Y,Y=$P(X,FROM) F I=2:1:$L(X,FROM) S Y=Y_"\"_TO_$P(X,FROM,I)
 I Y?.E1.C.E S X=Y,Y="" F I=1:1:$L(X) S FROM=$A(X,I) D
 . ; skip NUL character, otherwise encode ctrl-char
 . I FROM<32 Q:FROM=0  S Y=Y_$$UCODE(FROM) Q
 . I FROM>126,(FROM<160) S Y=Y_$$UCODE(FROM) Q
 . S Y=Y_$E(X,I)
 Q Y
 ;
JNUM(N) ; Return JSON representation of a number
 I N'<1 Q N
 I N'>-1 Q N
 I N>0 Q "0"_N
 I N<0 Q "-0"_$P(N,"-",2,9)
 Q N
 ;
UCODE(C) ; Return \u00nn representation of decimal character value
 N H S H="0000"_$$CNV^XLFUTL(C,16)
 Q "\u"_$E(H,$L(H)-3,$L(H))
 ;
ERRX(ID,VAL) ; Set the appropriate error message
 D ERRX^VPRJSON(ID,$G(VAL))
 Q

VPRJT^INT^1^63435;39516^0
VPRJT ;SLC/KCM -- Unit test driver
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;with acknowlegements to XTMUNIT, Imitation is the sincerest form of flattery
 ;
1 ; Run one specific test
 D EN("VPRJTDS") ;
 ; D EN("VPRJTQF") ;"VPRJTJE,VPRJTJD,VPRJTQU,VPRJTU")
 Q
ALL ; Run all the tests
 N ZZLINE,ZZNAME,ZZLIST
 S ZZLINE=0,ZZLIST=""
 F  S ZZLINE=ZZLINE+1 S ZZNAME=$T(EACH+ZZLINE) Q:'$L(ZZNAME)  S ZZNAME=$P($P(ZZNAME,";;",2,99)," ") Q:ZZNAME="zzzzz"  D
 . S ZZLIST=ZZLIST_$S($L(ZZLIST):",",1:"")_ZZNAME
 D EN(ZZLIST)
 ;D EN("VPRJTJE,VPRJTJD")
 ;D EN("VPRJTJE,VPRJTJD,VPRJUCU,VPRJTU,VPRJTS,VPRJUCR,VPRJTCF,VPRJTQX,VPRJUCD,VPRJUCV,VPRJTL,VPRJTT,VPRJTR,VPRJTRP,VPRJTDS,VPRJTDR,VPRJTDM")
 ;D EN("VPRJTJE,VPRJTJD,VPRJTCD,VPRJTCV")
 Q
EN(ZZRSET) ; Run tests for set of routines passed in
 N ZZFAILED,ZZROU,ZZPIECE
 F ZZPIECE=1:1:$L(ZZRSET,",") D TEST($P(ZZRSET,",",ZZPIECE))
 W !,$S($G(ZZFAILED):"Tests FAILED",1:"Tests PASSED")
 Q
TEST(ZZROU) ; Run tests in a specific routine
 W !!,">> "_ZZROU,?10,$P($T(@(ZZROU_"^"_ZZROU)),"--",2,99)
 N ZZI,ZZK,ZZX,ZZLABEL,ZZCODE,ZZCMT,ZZSET,ZZTEAR
 S ZZK=$T(@("STARTUP^"_ZZROU)) I $L(ZZK) D @("STARTUP^"_ZZROU)
 ;
 F ZZI=1:1 S ZZX=$T(@("+"_ZZI_"^"_ZZROU)) Q:ZZX=""  D
 . S ZZLABEL=$P(ZZX," "),ZZCODE=$$LTRIM($P(ZZX," ",2,99))
 . I $L(ZZLABEL),($E(ZZCODE,1,2)=";;"),($$UP($E(ZZCODE,1,9))["@TEST") D
 . . S ZZCMT=$E($P(ZZCODE,"@",2,99),5,$L(ZZCODE))
 . . W !,"Testing"_ZZCMT_" ["_ZZLABEL_"^"_ZZROU_"]"
 . . S ZZK=$T(@("SETUP^"_ZZROU)) I $L(ZZK) D @("SETUP^"_ZZROU)
 . . D @(ZZLABEL_"^"_ZZROU) ; run the unit test
 . . S ZZK=$T(@("TEARDOWN^"_ZZROU)) I $L(ZZK) D @("TEARDOWN^"_ZZROU)
 . . ;W ! ZW ; normally comment out except when looking for non-newed variables
 ;
 S ZZK=$T(@("SHUTDOWN^"_ZZROU)) I $L(ZZK) D @("SHUTDOWN^"_ZZROU)
 Q
EQ(EXPECT,ACTUAL,MSG) ;
 I EXPECT=ACTUAL W "." Q
 S ZZFAILED=1
 W:$X>1 ! W "expected: ",EXPECT,"  actual: ",ACTUAL,"  ",$G(MSG),!
 Q
NE(EXPECT,ACTUAL,MSG) ;
 I EXPECT'=ACTUAL W "." Q
 S ZZFAILED=1
 W:$X>1 ! W "not equal failed, value: ",ACTUAL,"  ",$G(MSG),!
 Q
UP(X) ; return uppercase for X
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
LTRIM(X) ; remove spaces from left side
 N POS F POS=1:1:$L(X) Q:$E(X,POS)'=" "
 Q $E(X,POS,$L(X))
 ;
EACH ; run each test one at a time
 ;;VPRJUJD   -- Unit tests for JSON decoding
 ;;VPRJUJE   -- Unit tests for JSON encoding
 ;;VPRJUREQ  -- Unit tests for HTTP listener request handling
 ;;VPRJURSP  -- Unit tests for HTTP listener response handling
 ;;VPRJURUT  -- Unit tests for HTTP listener utilities
 ;;VPRJUCU   -- Unit tests for common utilities
 ;;VPRJUCV   -- Unit tests for extracting values from objects
 ;;VPRJUCD   -- Unit tests for building meta-data
 ;;VPRJUCD1  -- Unit tests for building templates
 ;;VPRJUCT   -- Unit tests for applying templates
 ;;VPRJUCF   -- Unit tests for filter parameter
 ;;VPRJUCR   -- Unit tests for range parameter parsing
 ;;VPRJUFPS  -- Unit tests for index functions
 ;;VPRJTCF   -- Integration tests for query filters
 ;;VPRJTCT   -- Integration tests for templates
 ;;VPRJTCT1  -- Integration tests for rel/rev templates
 ;;VPRJTDS   -- Integration tests for saving objects to ODC
 ;;VPRJTDR   -- Integration tests for ODS RESTful queries
 ;;VPRJTDR2  -- Integration tests for ODS RESTful templates
 ;;VPRJTDM   -- Integration tests for ODS management tools
 ;;VPRJTPS   -- Integration tests for saving patient objects 
 ;;VPRJTPQ   -- Integration tests for query indexes
 ;;VPRJTPR   -- Integration tests for RESTful queries
 ;;VPRJTPR1  -- Integration tests for RESTful paging
 ;;VPRJTPR2  -- Integration tests for RESTful templates
 ;;VPRJTPR3  -- Integration tests for multi-patient RESTful queries
 ;;zzzzz
 ;;
 N ZZZ S ZZZ=0
 F  S ZZZ=ZZZ+1 Q:$P($P($T(EACH+ZZZ),";;",2,99)," ")="zzzzz"  D EN($P($P($T(EACH+ZZZ),";;",2,99)," ")) ;W ! ZW
 Q

VPRJTAR^INT^1^63294;58829^0
VPRJTAR ;SLC/KCM -- Special tests for RESTful queries across patients
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SHUTDOWN ; Run once after all tests
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
 ; these should not be run like the other tests
 ; they cannot produce the same results each time since they work across patients
 ;
ALLFIND ;; test find across patients
 D SETGET^VPRJTX("/vpr/all/find/med/uid?filter=like(""products[].ingredientName"",""ASPIRIN%25"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,($G(^TMP($J,"total"))>0))
 Q
ALLINDEX ;; test index across patients
 D SETGET^VPRJTX("/vpr/all/index/pt-name")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,($G(^TMP($J,"total"))>0))
 D ASSERT(1,$D(HTTPRSP("pageable")))
 Q
ALLPID ;; test getting all patient PID's
 D SETGET^VPRJTX("/vpr/all/index/pid/pid")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(0,$D(HTTPRSP("pageable")))
 D ASSERT(1,$P(^TMP($J,1),"""totalItems"":",2)>0)
 Q
ALLIDX2 ;; test index across patients
 D SETGET^VPRJTX("/vpr/all/index/xlab-lnc?range=urn:lnc:13955-0")
 D RESPOND^VPRJRSP
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,($G(^TMP($J,"total"))>0))
 D ASSERT(1,$D(HTTPRSP("pageable")))
 Q
ALL ;; run all tests
 D STARTUP
 D SETUP,ALLFIND,TEARDOWN
 D SETUP,ALLINDEX,TEARDOWN
 D SETUP,ALLPID,TEARDOWN
 D SHUTDOWN
 Q
1 ; run just one test
 D STARTUP,SETUP,ALLIDX2,TEARDOWN,SHUTDOWN
 Q

VPRJTCF^INT^1^63294;58829^0
VPRJTCF ;SLC/KCM -- Integration tests for query filters
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 D BLDPT^VPRJTX
 D MOCK1
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
MOCK1 ; Create mock data to test filter against
 N PID,UID
 S PID=VPRJTPID,UID="urn:va:test:93EF:-7:1"
 S ^VPRPT(PID,UID,"topValue")=1
 S ^VPRPT(PID,UID,"strValue")="quick brown fox"
 S ^VPRPT(PID,UID,"valueA")="red"
 S ^VPRPT(PID,UID,"result")=7.6
 S ^VPRPT(PID,UID,"observed")=20110919
 S ^VPRPT(PID,UID,"facility","name")="VAMC"
 S ^VPRPT(PID,UID,"products",1,"ingredient")="aspirin"
 S ^VPRPT(PID,UID,"products",2,"ingredient")="codeine"
 S ^VPRPT(PID,UID,"orders",1,"clinician","name")="Welby"
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
EVAL(LINE) ; return evaluation of statement
 N PID,UID,STMT,CLAUSES,HTTPERR
 S STMT=$P($T(@LINE),";;",2,99)
 D PARSE^VPRJCF(STMT,.CLAUSES)
 D ASSERT(0,$D(HTTPERR),"HTTP error:"_$G(HTTPERR))
 S PID=VPRJTPID,UID="urn:va:test:93EF:-7:1"
 K HTTPERR
 Q $$EVALAND^VPRJCF(.CLAUSES,UID)
 D ASSERT(0,$D(HTTPERR),"HTTP error:"_$G(HTTPERR))
 ;
SIMPLE ;; @TEST simple match
 ;; eq(topValue,1)
 ;; eq(topValue,42)
 ;; eq(missingValue,27)
 ;; eq("products[].ingredient","codeine")
 ;; eq("products[].ingredient","acetaminphen")
 ;; eq("facility.name","VAMC")
 ;; eq("facility.name","other") 
 D ASSERT(1,$$EVAL("SIMPLE+1"))
 D ASSERT(0,$$EVAL("SIMPLE+2"))
 D ASSERT(0,$$EVAL("SIMPLE+3"))
 D ASSERT(1,$$EVAL("SIMPLE+4"))
 D ASSERT(0,$$EVAL("SIMPLE+5"))
 D ASSERT(1,$$EVAL("SIMPLE+6"))
 D ASSERT(0,$$EVAL("SIMPLE+7"))
 Q
FLTAND ;; @TEST filter with ands
 ;; eq(topValue,1) eq(strValue,"quick brown fox")
 ;; eq(topValue,1) eq(strValue,"wrong")
 ;; ne(topValue,2) eq("products[].ingredient","aspirin")
 ;; eq(topValue,1) ne("products[].ingredient","acetaminophen")
 ;; eq(topValue,1) eq("products[].ingredient","acetaminophen")
 D ASSERT(1,$$EVAL("FLTAND+1"))
 D ASSERT(0,$$EVAL("FLTAND+2"))
 D ASSERT(1,$$EVAL("FLTAND+3"))
 D ASSERT(1,$$EVAL("FLTAND+4"))
 D ASSERT(0,$$EVAL("FLTAND+5"))
 Q
FLTOR ;; @TEST filter with or's
 ;; eq(topValue,1) or(eq(valueA,"red") eq(valueA,"green"))
 ;; eq(topValue,1) or(eq(valueA,"blue") eq(valueA,"yellow"))
 ;; eq(topValue,1) or{eq(valueA,"red") eq(valueA,"green")}
 D ASSERT(1,$$EVAL("FLTOR+1"))
 D ASSERT(0,$$EVAL("FLTOR+2"))
 D ASSERT(1,$$EVAL("FLTOR+3"))
 Q
FLTNOT ;; @TEST filter with not's
 ;; eq(topValue,1) not(eq(valueA,"yellow") eq(valueA,"green") eq(valueA,"blue"))
 ;; eq(topValue,1) not(eq(valueA,"red") eq(valueA,"green") eq(valueA,"blue"))
 ;; eq(topValue,1) not{eq(valueA,"red") eq(valueA,"green") eq(valueA,"blue")}
 D ASSERT(1,$$EVAL("FLTNOT+1"))
 D ASSERT(0,$$EVAL("FLTNOT+2"))
 D ASSERT(0,$$EVAL("FLTNOT+3"))
 Q
FLTIN ;; @TEST filter in property
 ;; in(valueA,["red","green","blue"])
 ;; in(valueA,["orange","banana","peach"])
 D ASSERT(1,$$EVAL("FLTIN+1"))
 D ASSERT(0,$$EVAL("FLTIN+2"))
 Q
FLTNIN ;; @TEST filter not in array
 ;; nin(valueA,["red","green","blue"])
 ;; nin(valueA,["orange","banana","peach"])
 ;; nin("products[].ingredient",["acetiminophen","ibuprofin"])
 ;; nin("products[].ingredient",["aspirin","codeine"])
 D ASSERT(0,$$EVAL("FLTNIN+1"))
 D ASSERT(1,$$EVAL("FLTNIN+2"))
 D ASSERT(1,$$EVAL("FLTNIN+3"))
 D ASSERT(0,$$EVAL("FLTNIN+4"))
 Q
FLTGTLT ;; @TEST filter gt and lt (value of result is 7.6)
 ;; gt(result,7.0)
 ;; gt(result,8)
 ;; gte(result,7.5)
 ;; gte(result,7.6)
 ;; gte(result,7.7)
 ;; lt(result,8)
 ;; lte(result,6)
 ;; lte(result,7.6)
 ;; lte(result,7.5)
 ;; lt(result,5)
 D ASSERT(1,$$EVAL("FLTGTLT+1"))
 D ASSERT(0,$$EVAL("FLTGTLT+2"))
 D ASSERT(1,$$EVAL("FLTGTLT+3"))
 D ASSERT(1,$$EVAL("FLTGTLT+4"))
 D ASSERT(0,$$EVAL("FLTGTLT+5"))
 D ASSERT(1,$$EVAL("FLTGTLT+6"))
 D ASSERT(0,$$EVAL("FLTGTLT+7"))
 D ASSERT(1,$$EVAL("FLTGTLT+8"))
 D ASSERT(0,$$EVAL("FLTGTLT+9"))
 D ASSERT(0,$$EVAL("FLTGTLT+10"))
 Q
FLTGTLTS ;; @TEST filter gt and lt with strings
 ;; gt(valueA,"blue")
 ;; gt(valueA,"TAN")
 ;; gte(valueA,"record")
 ;; gte(valueA,"red")
 ;; gte(valueA,"reddish")
 ;; lt(valueA,"TAN")
 ;; lte(valueA,"reddish")
 ;; lte(valueA,"red")
 ;; lte(valueA,"blue")
 ;; lt(valueA,"brown")
 D ASSERT(1,$$EVAL("FLTGTLTS+1"))
 D ASSERT(1,$$EVAL("FLTGTLTS+2")) ; lowercase sorts after upper
 D ASSERT(1,$$EVAL("FLTGTLTS+3"))
 D ASSERT(1,$$EVAL("FLTGTLTS+4"))
 D ASSERT(0,$$EVAL("FLTGTLTS+5"))
 D ASSERT(0,$$EVAL("FLTGTLTS+6")) ; uppercase is less than lowercase
 D ASSERT(1,$$EVAL("FLTGTLTS+7"))
 D ASSERT(1,$$EVAL("FLTGTLTS+8"))
 D ASSERT(0,$$EVAL("FLTGTLTS+9"))
 D ASSERT(0,$$EVAL("FLTGTLTS+10"))
 Q
FLTWEEN ;; @TEST between for numerics
 ;; between(result,7,8)
 ;; between(result,6,7)
 ;; between(result,8,9)
 D ASSERT(1,$$EVAL("FLTWEEN+1"))
 D ASSERT(0,$$EVAL("FLTWEEN+2"))
 D ASSERT(0,$$EVAL("FLTWEEN+3"))
 Q
FLTWEENS ;; @TEST between for strings
 ;; between(valueA,"rat","rot")
 ;; between(valueA,"RAT","ROT")
 ;; between(valueA,"reddish","tan")
 D ASSERT(1,$$EVAL("FLTWEENS+1"))
 D ASSERT(0,$$EVAL("FLTWEENS+2"))
 D ASSERT(0,$$EVAL("FLTWEENS+3"))
 Q
FLTLIKE ;; @TEST like for strings
 ;; like(strValue,"%brown%")
 ;; like(strValue,"%red%")
 ;; like(strValue,"%fox")
 ;; like("products[].ingredient","asp%")
 ;; like("products[].ingredient","ace%")
 ;; like("products[].ingredient","%C%")
 D ASSERT(1,$$EVAL("FLTLIKE+1"))
 D ASSERT(0,$$EVAL("FLTLIKE+2"))
 D ASSERT(1,$$EVAL("FLTLIKE+3"))
 D ASSERT(1,$$EVAL("FLTLIKE+4"))
 D ASSERT(0,$$EVAL("FLTLIKE+5"))
 D ASSERT(0,$$EVAL("FLTLIKE+5"))
 Q
FLTILIKE ;; @TEST ilike (case insensitive) for string
 ;; ilike("products[].ingredient","ACE%")
 ;; ilike("products[].ingredient","%C%")
 D ASSERT(0,$$EVAL("FLTILIKE+1"))
 D ASSERT(1,$$EVAL("FLTILIKE+2"))
 Q
FLTEXIST ;; @TEST exist for values
 ;; exists(result)
 ;; exists(absent)
 ;; exists("orders[].clinician.name")
 ;; exists(absent,false)
 D ASSERT(1,$$EVAL("FLTEXIST+1"))
 D ASSERT(0,$$EVAL("FLTEXIST+2"))
 D ASSERT(1,$$EVAL("FLTEXIST+3"))
 D ASSERT(1,$$EVAL("FLTEXIST+4"))
 Q
FLTDATES ;; @TEST dates represented as strings
 ;; between(observed,"2008","2012")
 ;; lt(observed,"201110")
 ;; gte(observed,"20110919")
 ;; lt(observed,"20080919103426")
 D ASSERT(1,$$EVAL("FLTDATES+1"))
 D ASSERT(1,$$EVAL("FLTDATES+2"))
 D ASSERT(1,$$EVAL("FLTDATES+3"))
 D ASSERT(0,$$EVAL("FLTDATES+4"))
 Q

VPRJTCT^INT^1^63294;58829^0
VPRJTCT ;SLC/KCM -- Integration tests for templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 D BLDPT^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
ONSAVE ;; @TEST template creation on save
 N TAGS
 S TAGS(1)="DATA1^VPRJTP03"
 D ADDDATA^VPRJTX(.TAGS,VPRJTPID)
 D ASSERT(10,$D(^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-general")))
 D ASSERT(10,$D(^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-exclude")))
 D ASSERT(10,$D(^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-instance")))
 N JSON,OBJ
 M JSON=^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-general")
 D DECODE^VPRJSON("JSON","OBJ")
 D ASSERT("Welby,Marcus/John,Trapper",OBJ("clinicians"))
 D ASSERT(20121229103022,OBJ("dateTime"))
 D ASSERT(1,$D(OBJ("dateTime","\s")))
 D ASSERT("Dragon Hair",OBJ("ingredients",2,"name"))
 D ASSERT(60,OBJ("lastFill","quantity"))
 K JSON,OBJ
 M JSON=^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-exclude")
 D DECODE^VPRJSON("JSON","OBJ")
 D ASSERT(10,$D(OBJ("dosages")))
 D ASSERT(10,$D(OBJ("authors")))
 D ASSERT(0,$D(OBJ("fills")))
 D ASSERT(0,$D(OBJ("content")))
 D ASSERT(0,$D(OBJ("products",1,"drugClass")))
 D ASSERT(1,$D(OBJ("products",1,"ingredient")))
 K JSON,OBJ
 M JSON=^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utesta:93EF:-7:1","unit-test-instance")
 D DECODE^VPRJSON("JSON","OBJ")
 ;W ! ZW OBJ
 ;B   check to see that the appropriate JSON objects exist
 Q
EXP1 ;; @TEST expanding fields in template
 N I,TAGS
 F I=2:1:5 S TAGS(I)="DATA"_I_"^VPRJTP03"
 D ADDDATA^VPRJTX(.TAGS,VPRJTPID)
 N JSON,OBJ
 M JSON=^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utestc:93EF:-7:23","unit-test-expand-1")
 D DECODE^VPRJSON("JSON","OBJ")
 D ASSERT(10,$D(OBJ("from")))
 D ASSERT(20111229103022,OBJ("from","dateTime"))
 D ASSERT(1,$D(OBJ("from","dateTime","\s")))
 D ASSERT("urn:va:utesta:93EF:-7:2",OBJ("from","uid"))
 Q
EXP2 ;; @TEST expanding fields in template
 N JSON,OBJ
 M JSON=^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utestc:93EF:-7:23","unit-test-expand-2")
 D DECODE^VPRJSON("JSON","OBJ")
 D ASSERT("urn:va:utesta:93EF:-7:1",OBJ("items",1,"uid"))
 D ASSERT("urn:va:utestb:93EF:-7:3",OBJ("items",2,"uid"))
 D ASSERT("a1",OBJ("items",1,"localId"))
 D ASSERT("b3",OBJ("items",2,"localId"))
 D ASSERT(0,$D(OBJ("items",3)))
 D ASSERT("urn:va:utestc:93EF:-7:23",OBJ("uid"))
 Q
QUERY ;; @TEST query type template
 D ASSERT(0,$D(^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:utestc:93EF:-7:23","unit-test-query")))
 N ROOT,OBJS,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest-c/unit-test-query")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.OBJS)
 D ASSERT("testRels",OBJS("data","items",1,"name"))
 D ASSERT("testRelsB",OBJS("data","items",2,"name"))
 D ASSERT(0,$D(OBJS("data","items",3,"name")))
 Q

VPRJTCT1^INT^1^63390;42968^0
VPRJTCT1 ;SLC/KCM -- Integration tests for rel/rev templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:5 S TAGS(I)="DATA"_I_"^VPRJTP03"
 D BLDPT^VPRJTX(.TAGS)
 K TAGS
 F I=1:1:6 S TAGS(I)="TEST"_I_"^VPRJTD01"
 S TAGS(7)="LINK1^VPRJTD01"
 D ODSBLD^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 D ODSCLR^VPRJTX
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
BLDTLT(TAG,RTN,TLT) ;; return spec in TLT
 N I,X,LINES,TEMPLATE,CLTN
 S I=0 F  S I=I+1,X=$P($T(@TAG+I^@RTN),";;",2,99) Q:X="zzzzz"  S LINES(I)=X
 D BLDSPEC^VPRJCD("link",.LINES,.TEMPLATE,.CLTN)
 S X=$O(TEMPLATE(""))
 M TLT=TEMPLATE(X)
 Q
METHOD1 ;; @TEST relationship with simple field assignment
 ;;utest-single
 ;;  collections: utestc
 ;;  ref: zdest>from
 ;;  rev: testFroms
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("METHOD1","VPRJTCT1",.TLT)
 D RELTLTP^VPRJCT1("RSLT","urn:va:utestc:93EF:-7:23",.TLT,VPRJTPID)
 D ASSERT(1,RSLT(1)["zdest")
 D ASSERT(1,RSLT(1)[$P($T(RSLT1A),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT1B),";;",2,99))
 ; (fields end up alphabetic due to the insertion of PID by ^VPRJTX)
 Q
RSLT1A ;;,"from":"urn:va:utesta:93EF:-7:2",
RSLT1B ;;,"zdest":{"authors":[{"provider":{"initials":"MW","name":"Welby,Marcus"}},{"provider":{"initials":"TJ","name":"John,Trapper"}}],"content":"This is a
 ;
METHOD2 ;; @TEST relationship with array uids replaced by summary objects
 ;;utest-multiple
 ;;  collections: utestc
 ;;  ref: items[].uid;unit-test-summary
 ;;  rev: testItems
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("METHOD2","VPRJTCT1",.TLT)
 D RELTLTP^VPRJCT1("RSLT","urn:va:utestc:93EF:-7:23",.TLT,VPRJTPID)
 ;N I F I=1:1 Q:'$D(RSLT(I))  W !,RSLT(I)
 D ASSERT(1,RSLT(1)[$P($T(RSLT2A),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT2B),";;",2,99))
 Q
RSLT2A ;;,"items":[{"uid":{"dateTime":"20121229103022","summary":"summary for uid utesta:1",
RSLT2B ;;,{"uid":{"dateTime":"20101229103022","summary":"summary for uid utestb:3",
 ;
METHOD3 ;; @TEST relationship with multiple nodes in field name
 ;;utest-single
 ;;  collections: utestc
 ;;  ref: za.zb>from;unit-test-summary
 ;;  rev: testFroms
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("METHOD3","VPRJTCT1",.TLT)
 D RELTLTP^VPRJCT1("RSLT","urn:va:utestc:93EF:-7:23",.TLT,VPRJTPID)
 D ASSERT(1,RSLT(1)[$P($T(RSLT3A),";;",2,99))
 Q
RSLT3A ;;,"za":{"zb":{"dateTime":"20111229103022","summary":"summary for uid utesta:2",
 ;
METHOD4 ;; @TEST relationship with unusual pattern for field name in arrays
 ;;utest-multiple
 ;;  collections: utestc
 ;;  ref: resolved.items[].obj>items[].uid;unit-test-summary
 ;;  rev: testItems
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("METHOD4","VPRJTCT1",.TLT)
 D RELTLTP^VPRJCT1("RSLT","urn:va:utestc:93EF:-7:23",.TLT,VPRJTPID)
 D ASSERT(1,RSLT(1)[$P($T(RSLT4A),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT4B),";;",2,99))
 Q
RSLT4A ;;,"items":[{"uid":"urn:va:utesta:93EF:-7:1"},{"uid":"urn:va:utestb:93EF:-7:3"}],"localId":"c1",
RSLT4B ;;,"resolved":{"items":[{"obj":{"dateTime":"20121229103022","summary":"summary for uid utesta:1",
 ;
METHOD5 ;; @TEST relationship where $Q must be used to iterate values
 ;;utest-multiple
 ;;  collections: utestc
 ;;  ref: dest[].obj>subs[].members[].uid
 ;;  rev: testItems
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("METHOD5","VPRJTCT1",.TLT)
 D RELTLTP^VPRJCT1("RSLT","urn:va:utestc:93EF:-7:23",.TLT,VPRJTPID)
 D ASSERT(1,RSLT(1)[$P($T(RSLT5A),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT5B),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT5C),";;",2,99))
 D ASSERT(1,RSLT(1)[$P($T(RSLT5D),";;",2,99))
 ; (the fields end up alphabetically arranged because PID is now inserted)
 Q
RSLT5A ;;{"dest":[{"obj":{"authors":[{"provider":{"initials":"MW","name":"Welby,Marcus"}},{"provider":{"initials":"TJ","name":"John,Trapper"}}],"content"
RSLT5B ;;"qualifiedName":"Miracle Tonic","summary":"summary for uid utesta:1","uid":"urn:va:utesta:93EF:-7:1"
RSLT5C ;;"summary":"summary for uid utesta:2","uid":"urn:va:utesta:93EF:-7:2"
RSLT5D ;;"summary":"summary for uid utestb:3","uid":"urn:va:utestb:93EF:-7:3"
 ;
ODS1 ;; @TEST template for ODS data
 ;;utest-ods
 ;;  collections: utestods
 ;;  ref: from[]>items[].uid
 ;;zzzzz
 N TLT,RSLT
 D BLDTLT("ODS1","VPRJTCT1",.TLT)
 S HTTPREQ("store")="data"
 D RELTLTD^VPRJCT1("RSLT","urn:va:utestods:1",.TLT)
 K HTTPREQ("store")
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,RSLT(1)[$P($T(ODS1A),";;",2,99))
 Q
ODS1A ;;{"from":[{"name":"beta","updated": "201110201857","color":"red","uid":"urn:va:test:2"},{"name":"gamma",
 ;
REV1 ;; @TEST reverse template with uid's
 N TEMPLATE,RSLT
 S TEMPLATE="rev;utest-multiple;uid"
 D LOADSPEC^VPRJCT1(.TEMPLATE)
 D REVTLTP^VPRJCT1("RSLT","urn:va:utesta:93EF:-7:1",.TEMPLATE,VPRJTPID)
 D ASSERT(1,RSLT(1)[$P($T(REV1A),";;",2,99))
 Q
REV1A ;;,"testItems":[{"uid":"urn:va:utestc:93EF:-7:23"},{"uid":"urn:va:utestc:93EF:-7:42"}]
 ;
REV2 ;; @TEST reverse template with uid's replaced by summary objects
 N TEMPLATE,RSLT
 S TEMPLATE="rev;utest-multiple;unit-test-summary"
 D LOADSPEC^VPRJCT1(.TEMPLATE)
 D REVTLTP^VPRJCT1("RSLT","urn:va:utesta:93EF:-7:1",.TEMPLATE,VPRJTPID)
 D ASSERT(1,RSLT(1)[$P($T(REV2A),";;",2,99))
 Q
REV2A ;;,"testItems":[{"name":"testRels","uid":"urn:va:utestc:93EF:-7:23"},{"name":"testRelsB","uid":"urn:va:utestc:93EF:-7:42"}]
 ;
REV3 ;; @TEST full reverse template for odc
 N TEMPLATE,RSLT,HTTPREQ
 S HTTPREQ("store")="data"
 S TEMPLATE="rev;utest-ods"
 D LOADSPEC^VPRJCT1(.TEMPLATE)
 D REVTLTD^VPRJCT1("RSLT","urn:va:test:2",.TEMPLATE)
 D ASSERT(1,RSLT(1)[$P($T(REV3A),";;",2,99))
 N ERR,OBJ
 D DECODE^VPRJSON("RSLT","OBJ","ERR")
 D ASSERT(0,$D(ERR))
 Q
REV3A ;;"testFroms":[{"name":"container1","uid":"urn:va:utestods:1",
 ;
1 ; one test 
 D STARTUP,REV2,SHUTDOWN
 Q

VPRJTD01^INT^1^63435;39516^0
VPRJTD01 ;SLC/KCM -- Sample non-patient data for save and query
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
DATA   ; Sample data
TEST1 ;;
 ;;{"name":"alpha","updated":"201210200457","color":"blue","type":"animal","uid":"urn:va:test:1"}
 ;;zzzzz
TEST2 ;;
 ;;{"name":"beta","updated": "201110201857","color":"red","uid":"urn:va:test:2"}
 ;;zzzzz
TEST3 ;;
 ;;{"name":"gamma","updated":"201110210831","color":"orange","type":"mineral","uid":"urn:va:test:3"}
 ;;zzzzz
TEST4 ;;
 ;;{"name":"delta","updated":"201210211922","color":"green","type":"","uid":"urn:va:test:4"}
 ;;zzzzz
TEST5 ;;
 ;;{"name":"epsilon","updated":"201210220722","color":"orange","type":"","uid":"urn:va:test:5"}
 ;;zzzzz
TEST6 ;;
 ;;{"name":"delta","updated":"201210221922","color":"purple","type":"vegatable","uid":"urn:va:test:6"}
 ;;zzzzz
TEST7 ;;
 ;;{"name":"omega","updated":"201210231755","color":"yellow","uid":"urn:va:test:7"}
 ;;zzzzz
OTHER ;;
 ;;{"name":"different item","updated":"201010231755","color":"white","uid":"urn:va:testb:29"}
 ;;zzzzz
NOUID1 ;;
 ;;{"name":"newItem1","updated":"201010241755","color":"white","fruit":"pomegranite"}
 ;;zzzzz
NOUID2 ;;
 ;;{"name":"newItem2","updated":"201110251622","color":"red","fruit":"apple"}
 ;;zzzzz
HASUID ;;
 ;;{"name":"newItem3","updated":"201210261342","color":"brown","fruit":"banana","uid":"urn:va:testb:42"}
 ;;zzzzz
 ;
LINK1 ;;
 ;;{"name":"container1","uid":"urn:va:utestods:1","items":[{"uid":"urn:va:test:2"},{"uid":"urn:va:test:3"}]}
 ;;zzzzz
SYS1 ;;
 ;;{"name":"alpha","updated":"201210200457","color":"blue","type":"animal","uid":"urn:va:test:F000:1"}
 ;;zzzzz
SYS2 ;;
 ;;{"name":"beta","updated": "201110201857","color":"red","uid":"urn:va:test:F000:2"}
 ;;zzzzz
SYS3 ;;
 ;;{"name":"gamma","updated":"201110210831","color":"orange","type":"mineral","uid":"urn:va:test:F000:3"}
 ;;zzzzz
SYS4 ;;
 ;;{"name":"delta","updated":"201210211922","color":"green","type":"","uid":"urn:va:test:F111:4"}
 ;;zzzzz
LONGIDX ;;
 ;;{"name":"nametoolongforsubscript,over255characters,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz
 ;;,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz
 ;;,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz
 ;;,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz
 ;;,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz",
 ;;"updated":"201409041550","color":"any","uid":"urn:va:test:9"}
 ;;zzzzz

VPRJTDM^INT^1^63294;58829^0
VPRJTDM ;SLC/KCM -- Integration tests for ODC management tools
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:6 S TAGS(I)="TEST"_I_"^VPRJTD01"
 S TAGS(7)="OTHER^VPRJTD01"
 D ODSBLD^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D ODSCLR^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
OBJCTN ;; @TEST count objects in collection
 N COUNT
 S COUNT=$$OBJCTN^VPRJ2D("test")
 D ASSERT(6,COUNT)
 Q

VPRJTDR^INT^1^63400;42551^0
VPRJTDR ;SLC/KCM -- Integration tests for ODC RESTful queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:6 S TAGS(I)="TEST"_I_"^VPRJTD01"
 D ODSBLD^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D ODSCLR^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
INDEX ;; @TEST query using an index
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/index/test-name?range=alpha..delta")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(4,JSON("data","totalItems"))
 D ASSERT(201110201857,JSON("data","items",4,"updated")) ; sorted reverse updated date
 Q
LAST ;; @TEST query for last instance of items in list
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/last/test-name?range=alpha..delta")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(3,JSON("data","totalItems"))
 D ASSERT("urn:va:test:6",JSON("data","items",1,"uid"))
 Q
ORDASC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/index/test-name?order=name asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("gamma",JSON("data","items",6,"name"))
 Q
ORDDESC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/index/test-name?order=name DESC")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("gamma",JSON("data","items",1,"name"))
 Q
ORDEMPTY ;; @TEST query where 'order by' field contains empty string
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/index/test-name?order=type DESC")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("vegatable",JSON("data","items",1,"type"))
 Q
FILTER ;; @TEST filter to return based on criteria
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/index/test-name?filter=eq(""color"",""orange"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("epsilon",JSON("data","items",1,"name"))
 Q
GETUID ;; @TEST getting an object by UID only
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/urn:va:test:5")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("epsilon",JSON("data","items",1,"name"))
 Q
GETNONE ;; @TEST getting an object that does not exist
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/urn:test:bogus:54321")
 D RESPOND^VPRJRSP
 D ASSERT(1,$G(HTTPERR)>0)
 D ASSERT(404,$G(^TMP("HTTPERR",$J,1,"error","code")))
 K ^TMP("HTTPERR",$J)
 Q
EVERY ;; TEST retrieving every object in a collection
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/every")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 D ASSERT(0,$D(^TMP($J,$J)))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 K JSON
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/every?start=3&limit=3")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(3,JSON("data","currentItemCount"))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 Q
FINDALL ;; @TEST finding every object in collection
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/find/test")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 Q
FINDPAR ;; @TEST finding with parameters
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/data/find/test?filter=eq(""color"",""orange"")&order=name")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("urn:va:test:5",JSON("data","items",1,"uid"))
 Q
FINDTLT ;; @TEST finding with template (applyOnSave)
 N JSON,ERR,HTTPERR
 D ASSERT(10,$D(^VPRJDJ("TEMPLATE","urn:va:test:5","unit-test-ods-summary")))
 D SETGET^VPRJTX("/data/find/test/unit-test-ods-summary")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 D ASSERT("epsilon",JSON("data","items",5,"name"))
 D ASSERT("urn:va:test:5",JSON("data","items",5,"uid"))
 D ASSERT(0,$D(JSON("data","items",5,"color")))
 Q
ADDOBJ ;; @TEST adding object to store
 N HTTPERR
 D SETPUT^VPRJTX("/data","TEST7","VPRJTD01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/data/urn:va:test:7",HTTPREQ("location"))
 D ASSERT(10,$D(^VPRJD("urn:va:test:7")))
 D ASSERT(7,$G(^VPRJDX("count","collection","test")))
 D ASSERT(1,$D(^VPRJDX("attr","test-name","omega ","798789768244=","urn:va:test:7",1)))
 Q
DELOBJ ;; @TEST remove object from store
 N HTTPERR
 D SETDEL^VPRJTX("/data/urn:va:test:7")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(0,$D(^VPRJD("urn:va:test:7")))
 D ASSERT(6,$G(^VPRJDX("count","collection","test")))
 D ASSERT(0,$D(^VPRJDX("attr","test-name","omega ","798789768244=","urn:va:test:7",0)))
 Q
 ;
NEWOBJ ;; @TEST add a new object, returning a new UID
 N HTTPERR,LASTID
 S LASTID=$G(^VPRJD("COLLECTION","testb"))
 D SETPUT^VPRJTX("/data/testb","NOUID1","VPRJTD01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/data/urn:va:testb:"_$G(^VPRMETA("system"))_":"_(LASTID+1),HTTPREQ("location"))
 D SETPUT^VPRJTX("/data/testb","NOUID2","VPRJTD01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/data/urn:va:testb:"_$G(^VPRMETA("system"))_":"_(LASTID+2),HTTPREQ("location"))
 D SETPUT^VPRJTX("/data/testb","HASUID","VPRJTD01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/data/urn:va:testb:42",HTTPREQ("location"))
 Q
DELCTN ;; @TEST delete collection
 N HTTPERR
 D SETPUT^VPRJTX("/data","OTHER","VPRJTD01") ; add something from another collection
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(4,$G(^VPRJDX("count","collection","testb")))
 D ASSERT(6,$G(^VPRJDX("count","collection","test")))
 D SETDEL^VPRJTX("/data/collection/test")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(4,$G(^VPRJDX("count","collection","testb")))
 D ASSERT(10,$D(^VPRJD("urn:va:testb:29")))
 D ASSERT(0,+$G(^VPRJDX("count","collection","test")))
 Q
1 ; run just one test
 D STARTUP,SETUP,GETNONE,TEARDOWN,SHUTDOWN
 Q

VPRJTDR2^INT^1^63294;58829^0
VPRJTDR2 ;SLC/KCM -- Integration tests for ODC RESTful templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:6 S TAGS(I)="TEST"_I_"^VPRJTD01"
 S TAGS(7)="LINK1^VPRJTD01"
 D ODSBLD^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D ODSCLR^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
RELMULT ;; @TEST loading objects with REL template - multiple values
 N RSP
 D SETGET^VPRJTX("/data/index/utest-name/rel;utest-ods")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("beta",RSP("data","items",3,"from",1,"name"))
 D ASSERT("gamma",RSP("data","items",3,"from",2,"name"))
 Q
REVUID ;; @TEST loading using the REV template
 N RSP
 D SETGET^VPRJTX("/data/index/test-name/rev;utest-ods?order=uid asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT(0,$D(RSP("data","items",1,"testFroms")))
 D ASSERT("urn:va:test:2",RSP("data","items",2,"uid"))
 D ASSERT("urn:va:utestods:1",RSP("data","items",2,"testFroms",1,"uid"))
 D ASSERT("urn:va:test:3",RSP("data","items",3,"uid"))
 D ASSERT("urn:va:utestods:1",RSP("data","items",3,"testFroms",1,"uid"))
 Q
EXPTLT ;; @TEST loading object with expanded uid
 N RSP
 D ASSERT(0,$D(^VPRJDJ("TEMPLATE","urn:va:utestods:1","unit-test-ods-expand")))
 D SETGET^VPRJTX("/data/find/utestods/unit-test-ods-expand")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("beta",RSP("data","items",1,"fullItems",1,"name"))
 D ASSERT("gamma",RSP("data","items",1,"fullItems",2,"name"))
 Q
BADIDX ;; @TEST bad index name
 N RSP
 D SETGET^VPRJTX("/data/index/bad-index")
 D RESPOND^VPRJRSP
 D ASSERT(1,$G(HTTPERR)>0)
 K ^TMP("HTTPERR",$J)
 Q

VPRJTDS^INT^1^63435;39516^0
VPRJTDS ;SLC/KCM -- Integration tests for saving objects to ODC
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 D ODSCLR^VPRJTX
 Q
SHUTDOWN ; Run once after all tests
 D ODSCLR^VPRJTX
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
ADDOBJ ;; @TEST adding an object
 N DATA,LOC
 D GETDATA^VPRJTX("TEST1","VPRJTD01",.DATA)
 S LOC=$$SAVE^VPRJDS(.DATA)
 D ASSERT(10,$D(^VPRJD("urn:va:test:1")))
 D ASSERT("blue",^VPRJD("urn:va:test:1","color"))
 D ASSERT(1,$D(^VPRJDJ("JSON","urn:va:test:1",1)))
 ; TODO: add test for summary json
 Q
CHKIDX ;; @TEST indexes that were built after adding object
 D ASSERT(1,$D(^VPRJDX("attr","test-name","alpha ","798789799542=","urn:va:test:1",1)))
 D ASSERT(1,^VPRJDX("tally","test-name-count","alpha"))
 D ASSERT(1,^VPRJDX("count","collection","test"))
 Q
GETOBJ ;; @TEST getting an object
 D QKEY^VPRJDQ("urn:va:test:1")
 D ASSERT(1,$D(^TMP($J,"data",0,"urn:va:test:1",0)))
 D ASSERT(1,$G(^TMP($J,"total")))
 Q
DELOBJ ;; @TEST deletion of object
 D DELETE^VPRJDS("urn:va:test:1")
 D ASSERT(0,$D(^VPRJD("urn:va:test:1")))
 D ASSERT(0,$D(^VPRJDJ("JSON","urn:va:test:1")))
 D ASSERT(0,$D(^VPRJDX("attr","test-name","alpha")))
 D ASSERT(0,$G(^VPRJDX("count","collection","test")))
 Q
LONGIDX ;; @TEST item with long index
 N DATA,LOC
 D GETDATA^VPRJTX("LONGIDX","VPRJTD01",.DATA)
 S LOC=$$SAVE^VPRJDS(.DATA)
 S NAME="nametoolongforsubscript,over255characters,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,"
 S NAME=NAME_"abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,"
 S NAME=NAME_"abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrstuvwxyz,abcdefghijklmnopqrs "
 D ASSERT(10,$D(^VPRJDX("attr","test-name",NAME)))
 Q
ADDLNK ;; @TEST adding object with links defined
 ; link defined in VPRJPMR, data in VPRJTD01
 N DATA,LOC
 D GETDATA^VPRJTX("LINK1","VPRJTD01",.DATA)
 S LOC=$$SAVE^VPRJDS(.DATA)
 D ASSERT(10,$D(^VPRJD("urn:va:utestods:1")))
 D ASSERT(1,$D(^VPRJDX("rev","urn:va:test:2","utest-ods","urn:va:utestods:1","items#1")))
 D ASSERT(1,$D(^VPRJDX("rev","urn:va:test:3","utest-ods","urn:va:utestods:1","items#2")))
 Q
DELCLTN ;; @TEST deleting a collection from a specific server
 N I,TAGS
 F I=1:1:4 S TAGS(I)="SYS"_I_"^VPRJTD01"
 D ODSBLD^VPRJTX(.TAGS)
 D ASSERT(1,$D(^VPRJD("urn:va:test:F111:4"))>0)
 D DELCTN^VPRJDS("test","F111")
 D ASSERT(0,$D(^VPRJD("urn:va:test:F111:4")))
 D ASSERT(1,$D(^VPRJD("urn:va:test:F000:2"))>0)
 Q

VPRJTP01^INT^1^63396;54290^0
VPRJTP01 ;SLC/KCM -- Sample patient data for indexes/queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PTDATA   ; Sample data for patient, urn:va:patient:93EF:-7
DEMOG7 ;;
 ;;{"addresses":[{"city":"Any Town","postalCode":"99998-0071","stateProvince":"WEST VIRGINIAN"}],"aliases":[{"fullName":"P7"}],"briefId":"U7777","dateOfBirth":19350407,"facilities":[{"code":500,"latestDate":20110613,"name":
 ;;"CAMP MASTER","systemId":"93EF"}],"familyName":"UTESTPATIENT","gender":"M","givenNames":"SEVEN","icn":"-777V123777","ssn":"-77777777","uid":"urn:va:patient:93EF:-7:-7"}
 ;;zzzzz
DEMOG8 ;;
 ;;{"addresses":[{"city":"Any Town","postalCode":"99998-0071","stateProvince":"WEST VIRGINIAN"}],"aliases":[{"fullName":"P8"}],"briefId":"U7777","dateOfBirth":19350408,"facilities":[{"code":500,"latestDate":20110613,"name":
 ;;"CAMP MASTER","systemId":"93EF"}],"familyName":"UTESTPATIENT","gender":"M","givenNames":"EIGHT","icn":"-888V123888","ssn":"-88888888","uid":"urn:va:patient:93EF:-8:-8"}
 ;;zzzzz
DEMOG9 ;;
 ;;{"uid":"urn:va:patient:93EF:-9:-9","summary":"gov.va.cpe.vpr.Patient{pids=[666223456, 93EF;-9]}","dateOfBirth":"19350407","ssn":"666223456","last4":"3456","last5":"Z3456","familyName":"ZZZRETFIVEFIFTYONE",
 ;;"givenNames":"PATIENT","fullName":"ZZZRETFIVEFIFTYONE,PATIENT","displayName":"Zzzretfivefiftyone,Patient","genderCode":"urn:va:pat-gender:M","genderName":"Male","briefId":"Z3456","sensitive":true,"domainTotals":{},
 ;;"syncErrorCount":0,"religionCode":"urn:va:pat-religion:21","maritalStatuses":[{"code":"urn:va:pat-maritalStatus:M","name":"Married"}],"religionName":"NAZARENE","localId":-9}
 ;;zzzzz
NEWICN9 ;;
 ;;{"uid":"urn:va:patient:93EF:-9:-9","summary":"gov.va.cpe.vpr.Patient{pids=[666223456, 93EF;-9]}","dateOfBirth":"19350407","ssn":"666223456","last4":"3456","last5":"Z3456","familyName":"ZZZRETFIVEFIFTYONE",
 ;;"givenNames":"PATIENT","fullName":"ZZZRETFIVEFIFTYONE,PATIENT","displayName":"Zzzretfivefiftyone,Patient","genderCode":"urn:va:pat-gender:M","genderName":"Male","briefId":"Z3456","sensitive":true,"domainTotals":{},
 ;;"syncErrorCount":0,"religionCode":"urn:va:pat-religion:21","maritalStatuses":[{"code":"urn:va:pat-maritalStatus:M","name":"Married"}],"religionName":"NAZARENE","localId":-9,"icn":"-999V123999"}
 ;;zzzzz
DIED9 ;;
 ;;{"uid":"urn:va:patient:93EF:-9:-9","summary":"gov.va.cpe.vpr.Patient{pids=[666223456, 93EF;-9]}","dateOfBirth":"19350407","ssn":"666223456","last4":"3456","last5":"Z3456","familyName":"ZZZRETFIVEFIFTYONE",
 ;;"givenNames":"PATIENT","fullName":"ZZZRETFIVEFIFTYONE,PATIENT","displayName":"Zzzretfivefiftyone,Patient","genderCode":"urn:va:pat-gender:M","genderName":"Male","briefId":"Z3456","sensitive":true,"domainTotals":{},
 ;;"syncErrorCount":0,"religionCode":"urn:va:pat-religion:21","maritalStatuses":[{"code":"urn:va:pat-maritalStatus:M","name":"Married"}],"religionName":"UNKNOWN","localId":-9,"dateOfDeath":"20120524"}
 ;;zzzzz
NUMFAC ;;
 ;;{"addresses":[{"city":"Any Town","postalCode":"99998-0071","stateProvince":"WEST VIRGINIAN"}],"aliases":[{"fullName":"P1"}],"briefId":"U1111","dateOfBirth":19350401,"facilities":[{"code":500,"latestDate":"20110613","name":
 ;;"CAMP MASTER","systemId":"4321"}],"familyName":"UTESTPATIENT","gender":"M","givenNames":"SEVEN","icn":"-111V123111","ssn":"-111111111","uid":"urn:va:patient:4321:-1:-1"}
 ;;zzzzz
D7BAD ;; Data for patient -7 from different site with bad icn
 ;;{"addresses":[{"city":"Another Town","postalCode":"99778-0071","stateProvince":"SOUTH DAKOTA"}],"aliases":[{"fullName":"P7"}],"briefId":"U7777","dateOfBirth":19350407,"facilities":[{"code":700,"latestDate":20120613,"name":
 ;;"CAMP MASTER","systemId":"93CC"}],"familyName":"UTESTPATIENT","gender":"M","givenNames":"SEVEN","icn":"-787V123787","ssn":"-77777777","uid":"urn:va:patient:93CC:-7:-7"}
 ;;zzzzz
D7GOOD ;; Data for patient -7 from different site with good icn
 ;;{"addresses":[{"city":"Diff Town","postalCode":"99988-0071","stateProvince":"NORTH DAKOTA"}],"aliases":[{"fullName":"P7"}],"briefId":"U7777","dateOfBirth":19350407,"facilities":[{"code":600,"latestDate":20100613,"name":
 ;;"CAMP MASTER","systemId":"93DD"}],"familyName":"UTESTPATIENT","gender":"M","givenNames":"SEVEN","icn":"-777V123777","ssn":"-77777777","uid":"urn:va:patient:93DD:-7:-7"}
 ;;zzzzz
TIU1 ; Sample TIU document
 ;;{"uid":"urn:va:document:93EF:8:1090","summary":"BLEEDING DISORDER","pid":"3","kind":"","facilityCode":"500D","facilityName":"SLC-FO HMP DEV","localId":"1090","encounterUid":"urn:va:visit:93EF:8:1218","encounterName":"GEN MED
 ;; Jul 18, 1995","referenceDateTime":"19990513131520","documentTypeCode":"CR","documentTypeName":"","documentClass":"PROGRESS NOTES","localTitle":"BLEEDING DISORDER","status":"completed","content":" LOCAL TITLE: BLEEDING 
 ;;DISORDER                                  \r\n   DICT DATE: MAY 13, 1999@10:11     ENTRY DATE: MAY 13, 1999@13:15:20      \r\n DICTATED BY: PROVIDER,TWOHUNDRED  EXP COSIGNER:                           \r\n     URGENCY:
 ;;                            STATUS: COMPLETED                     \r\n\r\n nblkve\r\nv kldh\r\nPatient is a 46-year-old male here for evaluation of his bilateral knee \r\nblood tests done, because he was unaware that he
 ;; needed to be fasting.  \r\nStates that he recently started a new job as a Physiology Professor at \r\na local college and was concerned about missing too much work (needed \r\nto take time from work two days in a row o
 ;;f these exams).  \r\n \r\n@###\r\n \r\n/es/ \r\n\r\nSigned: 05/13/1999 13:15","clinicians":[{"uid":"urn:va:user:93EF:11712","summary":"gov.va.cpe.vpr.DocumentClinician@388c3949","role":"A","name":"PROVIDER,TWOHUNDREDNIN
 ;;ETYSEVEN"},{"uid":"urn:va:user:93EF:11712","summary":"gov.va.cpe.vpr.DocumentClinician@7e05049f","role":"S","signedDateTime":"19990513131536","signature":"TWOHUNDREDNINETYSEVEN PROVIDER COMPUTER SPECIALIST","name":"PROV
 ;;IDER,TWOHUNDREDNINETYSEVEN"}],"text":" LOCAL TITLE: BLEEDING DISORDER                                  \r\n   DICT DATE: MAY 13, 1999@10:11     ENTRY DATE: MAY 13, 1999@13:15:20      \r\n DICTATED BY: PROVIDER,TWOHUNDRE
 ;;D  EXP COSIGNER:                           \r\n     URGENCY:                            STATUS: COMPLETED                     \r\n\r\n nblkve\r\nv kldh\r\nPatient is a 46-year-old male here for evaluation of his bilater
 ;;al knee \r\nblood tests done, because he was unaware that he needed to be fasting.  \r\nStates that he recently started a new job as a Physiology Professor at \r\na local college and was concerned about missing too much
 ;; work (needed \r\nto take time from work two days in a row of these exams).  \r\n \r\n@###\r\n \r\n/es/ \r\n\r\nSigned: 05/13/1999 13:15","idx":[]}
 ;;zzzzz
UTST1 ;; sample object for patient 7
 ;;{"uid":"urn:va:utestc:93EF:-7:1","name":"sample object 1","color":"red","serialNumber":123,"rate":3,"clinical":false,"stay":{"started":"201405071034"},"updated":"201406071034"}
 ;;zzzzz
UTST2 ;; sample object for patient 7
 ;;{"uid":"urn:va:utestc:93EF:-7:2","name":"sample object 2","color":"yellow","serialNumber":223,"rate",1,"clinical":false,"stay":{"started":"201306071034"},"updated":"201307071034"}
 ;;zzzzz
UTST3 ;; sample object for patient 7
 ;;{"uid":"urn:va:utestc:93EF:-7:3","name":"sample object 3","color":"blue","serialNumber":323,"rate":3,"clinical":false,"updated":"201407221034"}
 ;;zzzzz
UTST4 ;; sample object for patient 8
 ;;{"uid":"urn:va:utestc:93EF:-8:4","name":"sample object 4","color":"purple","serialNumber":423,"rate":1,"clinical":false,"stay":{"started":"201405211034"},"updated":"201406211034"}
 ;;zzzzz
UTST5 ;; sample object for patient 8
 ;;{"uid":"urn:va:utestc:93EF:-8:5","name":"sample object 5","color":"orange","serialNumber":523,"rate":3,"clinical":false,"stay":{"started":"201406012330"},"updated":"201407012330"}
 ;;zzzzz

VPRJTP02^INT^1^63363;69627^0
VPRJTP02 ;SLC/KCM -- Sample patient data (meds)
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
MED1 ;;
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:16982","localId":"402786;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:55561003"
 ;;,"medStatusName":"active","medType":"urn:sct
 ;;:73639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20050317","overallStop":"20060318","stopped":"20050317","products":[{"ingredientCode":"urn:vu
 ;;id:4023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 250MG TAB,SA","ingredientRole":"urn
 ;;:sct:410942007"}],"dosages":[{"dose":"250 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":0,"start":"20050317","stop":"20050317"}],"orders":[{"orderId":"","prescriptionId":"500290",
 ;;"quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20050317152443.000","expiration":"2006
 ;;0318","provider":{"uid":"11745","name":"LABTECH,SPECIAL"},"pharmacist":{"uid":"10000000019","name":"TDPHARMACIST,ONE"}}]}
 ;;zzzzz
MED2 ;;
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:17203","localId":"402926;O","productFormName":"TAB","sig":"TAKE ONE TABLET BY BY MOUTH EVERY DAY AT 1 PM","medStatus":"urn:sct:73425007"
 ;;,"medStatusName":"not active","medType":"urn:sc
 ;;t:73639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"WARFARIN","kind":"Medication, Outpatient","overallStart":"20060530","overallStop":"20070602","stopped":"20060604","products":[{"ingredientCode":"urn:vuid
 ;;:4019972","ingredientName":"WARFARIN","drugClassCode":"urn:vadc:BL110","drugClassName":"ANTICOAGULANTS","suppliedCode":"urn:vuid:4013990","suppliedName":"WARFARIN (C0UMADIN) NA 5MG TAB","ingredientRole":"urn:sct:410942007
 ;;"}],"dosages":[{"dose":"5 MG","units":"MG","routeName":"PO","scheduleName":"QD-WARF","relativeStart":0,"relativeStop":5760,"start":"20060531","stop":"20060604"}],"orders":[{"orderId":"","prescriptionId":"500412","quantity
 ;;Ordered":"30","daysSupply":30,"fillsAllowed":5,"fillsRemaining":5,"fillCost":"1.65","location":"VIST CLINIC","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20060531160045.000","expiration":"2
 ;;0070601","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"20144","name":"PHARMACIST,THIRTY"}}]}
 ;;zzzzz
MED3 ;;
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:17266","localId":"402924;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007"
 ;;,"medStatusName":"not active","medType":"urn:sct:7
 ;;3639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20060531","overallStop":"20070601","stopped":"20060604","products":[{"ingredientCode":"urn:vuid:4
 ;;023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 500MG TAB,SA","ingredientRole":"urn:sct
 ;;:410942007"}],"dosages":[{"dose":"500 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":5760,"start":"20060531","stop":"20060604"}],"orders":[{"orderId":"","prescriptionId":"500290A",
 ;;"quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"VIST CLINIC","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20060531161818.000","expira
 ;;tion":"20070601","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"20144","name":"PHARMACIST,THIRTY"}}]}
 ;;zzzzz
MED4 ;;
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:18068","localId":"1N;O","productFormName":"TAB,EC","sig":"TAKE ONE TABLET BY MOUTH EVERY MORNING","medStatus":"urn:sct:55561003"
 ;;,"medStatusName":"active","medType":"urn:sct:329505003","stopped":""
 ;;,"vaType":"N","vaStatus":"ACTIVE","qualifiedName":"ASPIRIN","kind":"Medication, Non-VA","products":[{"ingredientCode":"urn:vuid:4017536","ingredientName":"ASPIRIN TAB","drugClassCode":"urn:vadc:CN103","drugClassName":"NON
 ;;-OPIOID ANALGESICS","suppliedCode":"urn:vuid:4005766","suppliedName":"ASPIRIN 81MG EC TAB","ingredientRole":"urn:sct:410942007"}],"dosages":[{"dose":"81 MG","units":"MG","routeName":"PO","scheduleName":"QAM","relativeStar
 ;;t":0}],"orders":[{"orderId":"","prescriptionId":"","quantityOrdered":"","fillCost":"","location":"GENERAL MEDICINE","vaRouting":"","vaDispensed":false,"vaOrderStatus":"ACTIVE","ordered":"20070411162700.000","provider":{"u
 ;;id":"10000000031","name":"VEHU,ONEHUNDRED"}}]}
 ;;zzzzz
MED5 ;;
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:18069","localId":"403229;O","productFormName":"TAB,SA","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007"
 ;;,"medStatusName":"not active","medType":"urn:sct:7
 ;;3639000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METFORMIN","kind":"Medication, Outpatient","overallStart":"20070411","overallStop":"20080411","stopped":"20080128","products":[{"ingredientCode":"urn:vuid:4
 ;;023979","ingredientName":"METFORMIN","drugClassCode":"urn:vadc:HS502","drugClassName":"ORAL HYPOGLYCEMIC AGENTS,ORAL","suppliedCode":"urn:vuid:4014984","suppliedName":"METFORMIN HCL 500MG TAB,SA","ingredientRole":"urn:sct
 ;;:410942007"}],"dosages":[{"dose":"500 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":420540,"start":"20070411","stop":"20080128"}],"orders":[{"orderId":"","prescriptionId":"500290B
 ;;","quantityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"90","location":"GENERAL MEDICINE","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20070411162837.000",
 ;;"expiration":"20080411","provider":{"uid":"10000000031","name":"VEHU,ONEHUNDRED"},"pharmacist":{"uid":"10000000056","name":"PHARMACIST,ONE"}}]}
 ;;zzzzz
 ;
MED6 ; Sample Med to Add
 ;;{"patient":"-7","facilityName":"Camp Master","uid":"urn:va:med:93EF:-7:15231","localId":"402300;O","productFormName":"TAB","sig":"TAKE ONE TABLET BY BY MOUTH TWICE A DAY","medStatus":"urn:sct:73425007"
 ;;,"medStatusName":"not active","medType":"urn:sct:7363
 ;;9000","vaType":"O","vaStatus":"DISCONTINUED","qualifiedName":"METOPROLOL","kind":"Medication, Outpatient","overallStart":"20040330","overallStop":"20050331","stopped":"20040330","products":[{"ingredientCode":"urn:vuid:4
 ;;019836","ingredientName":"METOPROLOL","drugClassCode":"urn:vadc:CV100","drugClassName":"BETA BLOCKERS/RELATED","suppliedCode":"urn:vuid:4004608","suppliedName":"METOPROLOL TARTRATE 50MG TAB","ingredientRole":"urn:sct:41
 ;;0942007"}],"dosages":[{"dose":"50 MG","units":"MG","routeName":"PO","scheduleName":"BID","relativeStart":0,"relativeStop":0,"start":"20040330","stop":"20040330"}],"orders":[{"orderId":"","prescriptionId":"500046","quant
 ;;ityOrdered":"180","daysSupply":90,"fillsAllowed":3,"fillsRemaining":3,"fillCost":"11.88","location":"","vaRouting":"W","vaDispensed":true,"vaOrderStatus":"DISCONTINUED","ordered":"20040330145422.000","expiration":"20050
 ;;331","provider":{"uid":"11745","name":"LABTECH,SPECIAL"},"pharmacist":{"uid":"11745","name":"LABTECH,SPECIAL"}}]}
 ;;zzzzz

VPRJTP03^INT^1^63400;42551^0
VPRJTP03 ;SLC/KCM -- Sample patient data for links/templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
PTSTUB ;; patient stub, urn:va:patient:93EF:-7
 ;;{"facility":"Camp Master","uid":"urn:va:patient:93EF:-7:-7","localId":"-7","icn":"-777","ssn":"-77777777"}
 ;;zzzzz
DATA1 ;; sample entry #1
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utesta:93EF:-7:1","localId":"a1",
 ;;"summary":"summary for uid utesta:1",
 ;;"authors":[{"provider":{"name":"Welby,Marcus","initials":"MW"}},{"provider":{"name":"John,Trapper","initials":"TJ"}}],
 ;;"dateTime":"20121229103022","qualifiedName":"Miracle Tonic",
 ;;"products":[{"ingredient":"Batwings","drugClass":"Herbal"},{"ingredient":"Dragon Hair","drugClass":"Herbal"}],
 ;;"content":"This is a also a longer field for content that should be filtered out.",
 ;;"dosages":[{"dose":"600ml","start":11,"stop":12},{"dose":"500ml","start":9,"stop":10},{"dose":"700ml","start":13,"stop":14}],
 ;;"fills":[{"fillDate":"201204210930","quantity":20,"mailed":false},{"fillDate":"201207201630","quantity":30,"mailed":true},{"fillDate":"201210201730","quantity":60,"mailed":true}]}
 ;;zzzzz
DATA2 ;; sample entry #2
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utesta:93EF:-7:2","localId":"a2",
 ;;"summary":"summary for uid utesta:2",
 ;;"authors":[{"provider":{"name":"Welby,Marcus","initials":"MW"}},{"provider":{"name":"John,Trapper","initials":"TJ"}}],
 ;;"dateTime":"20111229103022","qualifiedName":"Miracle Tonic",
 ;;"dosages":[{"dose":"400ml","start":7,"stop":8},{"dose":"300ml","start":5,"stop":6}],
 ;;"products":[{"ingredient":"Batwings","drugClass":"Herbal"},{"ingredients":"Dragon Hair","drugClass":"Herbal"}],
 ;;"content":"This is a longer field for content that should be filtered out.",
 ;;"fills":[{"fillDate":"201110201730","quantity":30,"mailed":true},{"fillDate":"201107201630","quantity":30,"mailed":true},{"fillDate":"201104210930","quantity":30,"mailed":false}]}
 ;;zzzzz
DATA3 ;; sample entry #3 (different collection -- utestb)
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utestb:93EF:-7:3","localId":"b3",
 ;;"summary":"summary for uid utestb:3",
 ;;"authors":[{"provider":{"name":"Welby,Marcus","initials":"MW"}},{"provider":{"name":"John,Trapper","initials":"TJ"}}],
 ;;"adminDateTime":"20101229103022","qualifiedName":"Miracle Tonic",
 ;;"dosages":[{"dose":"200ml","start":3,"stop":4},{"dose":"100ml","start":1,"stop":2}],
 ;;"content":"This is yet another longer field for content that should be filtered out.",
 ;;"products":[{"ingredient":"Batwings","drugClass":"Herbal"},{"ingredients":"Dragon Hair","drugClass":"Herbal"}],
 ;;"fills":[{"fillDate":"201010201730","quantity":20,"mailed":true},{"fillDate":"201007201630","quantity":20,"mailed":true},{"fillDate":"201004210930","quantity":10,"mailed":false}]}
 ;;zzzzz
DATA4 ;; sample entry for item that references others (collection utestc)
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utestc:93EF:-7:23","localId":"c1",
 ;;"name":"testRels","text":"test relationship linkages","from":"urn:va:utesta:93EF:-7:2",
 ;;"items":[{"uid":"urn:va:utesta:93EF:-7:1"},{"uid":"urn:va:utestb:93EF:-7:3"}],
 ;;"subs":[{"type":"a","members":[{"uid":"urn:va:utesta:93EF:-7:1"},{"uid":"urn:va:utesta:93EF:-7:2"}]},{"type":"b","members":[{"uid":"urn:va:utestb:93EF:-7:3"}]}]
 ;;}
DATA5 ;; sample entry for item that references others (collection utestc)
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utestc:93EF:-7:42","localId":"c2",
 ;;"name":"testRelsB","text":"test relationship linkages B","from":"urn:va:utesta:93EF:-7:1",
 ;;"items":[{"uid":"urn:va:utesta:93EF:-7:1"}],
 ;;"subs":[{"type":"a","members":[{"uid":"urn:va:utesta:93EF:-7:1"},{"uid":"urn:va:utesta:93EF:-7:2"}]},{"type":"b","members":[{"uid":"urn:va:utestb:93EF:-7:3"}]}]
 ;;}
 ;;zzzzz
 ;
SRV6 ;; sample entry #1
 ;;{"patient":"-7","facility":"Camp Other","uid":"urn:va:utesta:9999:-7:6","localId":"a6"}
 ;;zzzzz
SRV7 ;; sample entry #2
 ;;{"patient":"-7","facility":"Camp Master","uid":"urn:va:utesta:93EF:-7:7","localId":"a7"}
 ;;zzzzz

VPRJTPQ^INT^1^63396;54290^0
VPRJTPQ ;SLC/KCM -- Integration tests for query indexes
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:5 S TAGS(I)="MED"_I_"^VPRJTP02"
 D BLDPT^VPRJTX(.TAGS)
 K TAGS
 F I=1:1:3 S TAGS(I)="UTST"_I_"^VPRJTP01"
 D ADDDATA^VPRJTX(.TAGS,VPRJTPID)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
TMP2ARY(ARY) ; convert JSON object in ^TMP($J) to array
 ; ARY must be passed by reference
 N SIZE,PREAMBLE
 S HTTPREQ("store")="vpr" ; normally this gets set in RESPOND^VPRJRSP
 D PAGE^VPRJRUT("^TMP($J)",0,999,.SIZE,.PREAMBLE)
 N SRC,N,I,J
 S N=0,SRC(N)="{""apiVersion"":""1.0"",""data"":{""totalItems"":"_^TMP($J,"total")_",""items"":["
 S I="" F  S I=$O(^TMP($J,$J,I)) Q:I=""  D
 . I I S SRC(N)=SRC(N)_","
 . S J=0 F  S J=$O(^TMP($J,$J,I,J)) Q:'J  D
 . . S N=N+1,SRC(N)=^TMP($J,$J,I,J)
 S N=N+1,SRC(N)="]}}"
 D DECODE^VPRJSON("SRC","ARY","ERR")
 D ASSERT(0,$G(ERR(0),0),"JSON conversion error")
 Q
PARSERNG ;; @TEST parse range (using information in ^VPRMETA)
 N RANGE,INDEX,START,STOP,DIR
 S INDEX="lab-type"
 M INDEX=^VPRMETA("index",INDEX,"common")
 S RANGE="GLU..GLZ>2012..2013["
 D PARSERNG^VPRJCR
 D ASSERT("glz ",STOP(1))
 D ASSERT("7986=",START(2))
 D ASSERT(1,DIR(2))
 K START,STOP,DIR
 S RANGE="GLUCOSE, SODIUM, POTASSIUM>2012..2013["
 D PARSERNG^VPRJCR
 D ASSERT(1,$D(START(1,"list","sodium ")))
 D ASSERT(0,$D(START(2,"list")))
 D ASSERT($C(255,255,255),STOP(1))
 Q
JSON ;;@TEST json formatting
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*",,,"uid")
 D ASSERT(0,$D(HTTPERR))
 N ARY D TMP2ARY(.ARY)
 ; reverse chronological order, so 16982 is 3rd item in list
 D ASSERT("urn:va:med:93EF:-7:16982",ARY("data","items",3,"uid"))
 D ASSERT(3,ARY("data","totalItems"))
 Q
TIME ;;@TEST time based query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-time","20060101..20061231")
 D ASSERT(0,$D(HTTPERR))
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 D ASSERT(20060531,ARY("data","items",1,"overallStart"))
 D ASSERT(20060318,ARY("data","items",3,"overallStop"))
 D ASSERT("250 MG",ARY("data","items",3,"dosages",1,"dose"))
 Q
TIMEASC ;;@TEST ascending order
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-time","20060101..20061231","asc",4)
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 D ASSERT(20060318,ARY("data","items",1,"overallStop"))
 D ASSERT(20060531,ARY("data","items",3,"overallStart"))
 ; spot check a few values
 D ASSERT("urn:vuid:4023979",ARY("data","items",1,"products",1,"ingredientCode"))
 D ASSERT("VEHU,ONEHUNDRED",ARY("data","items",2,"orders",1,"provider","name"))
 D ASSERT("500 MG",ARY("data","items",3,"dosages",1,"dose"))
 Q
TIMEIF ;; @TEST setif on time index
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"utest-time")
 N ARY,I
 D TMP2ARY(.ARY)
 S I=0 F  S I=$O(ARY("data","items",I)) Q:'I  D ASSERT(1,ARY("data","items",I,"color")'="yellow")
 D ASSERT(3,ARY("data","totalItems"))
 Q
SORTSTOP ;; @TEST sorting by the stop time on time based index
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-time","","overallStop asc")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("20060318",ARY("data","items",1,"overallStop")) ; ascending
 D ASSERT(0,$D(ARY("data","items",5,"overallStop")))      ; last item has no stop date
 D ASSERT("urn:va:med:93EF:-7:18068",ARY("data","items",5,"uid"))
 Q
ATTR ;; @TEST attribute query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(3,ARY("data","totalItems"))
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","[ASPIRIN..METFORMIN]")
 K ARY D TMP2ARY(.ARY)
 D ASSERT(4,ARY("data","totalItems"))
 Q
ATTRLIM ;; @TEST attribute query with bail limits on return
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-ingredient-name","METFOR*",,1)
 N ARY D TMP2ARY(.ARY)
 D ASSERT(1,ARY("data","totalItems"))
 Q
LIST ;; @TEST list based query
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"med-active-outpt")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(2,ARY("data","totalItems"))
 Q
LAST ;; @TEST most recent query
 N HTTPERR
 K ^TMP($J)
 D QLAST^VPRJPQ(VPRJTPID,"med-qualified-name")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("urn:va:med:93EF:-7:18069",ARY("data","items",1,"uid"))
 D ASSERT("urn:va:med:93EF:-7:17203",ARY("data","items",2,"uid"))
 D ASSERT("urn:va:med:93EF:-7:18068",ARY("data","items",3,"uid"))
 K ^TMP($J)
 D QLAST^VPRJPQ(VPRJTPID,"med-class-code","urn:vadc:HS502, urn:vadc:CN103, urn:vadc:XX000")
 K ARY D TMP2ARY(.ARY)
 D ASSERT(2,ARY("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:18069",ARY("data","items",1,"uid"))
 D ASSERT("urn:va:med:93EF:-7:18068",ARY("data","items",2,"uid"))
 Q
MATCH ;; match query (DISABLED for NOW)
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"condition.bleedingrisk")
 N ARY D TMP2ARY(.ARY)
 D ASSERT(1,ARY("data","totalItems"))
 D ASSERT("urn:vadc:BL110",ARY("data","items",1,"products",1,"drugClassCode"))
 Q
TALLY ;; @TEST tally items
 N HTTPERR
 K ^TMP($J)
 D QTALLY^VPRJPQ(VPRJTPID,"kind")
 N ARY
 D DECODE^VPRJSON("^TMP($J)","ARY","ERR")
 D ASSERT(0,$G(ERR(0),0),"JSON conversion error")
 D ASSERT(2,ARY("data","totalItems"))
 D ASSERT(4,ARY("data","items",2,"count"))
 Q
UID ;; @TEST get uid
 N HTTPERR
 K ^TMP($J)
 D QKEY^VPRJPQ(VPRJTPID,"urn:va:med:93EF:-7:17266")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("402924;O",ARY("data","items",1,"localId"))
 D ASSERT("urn:vuid:4023979",ARY("data","items",1,"products",1,"ingredientCode"))
 Q
ORDER ;; @TEST sorting on different field
 N HTTPERR
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"medication","","qualifiedName")
 N ARY D TMP2ARY(.ARY)
 D ASSERT("ASPIRIN",ARY("data","items",1,"qualifiedName"))
 K ^TMP($J)
 D QINDEX^VPRJPQ(VPRJTPID,"medication","","qualifiedName desc")
 K ARY D TMP2ARY(.ARY)
 D ASSERT("WARFARIN",ARY("data","items",1,"qualifiedName"))
 Q
1 ; do one test
 D STARTUP,SORTSTOP,SHUTDOWN
 Q

VPRJTPR^INT^1^63398;51312^0
VPRJTPR ;SLC/KCM -- Integration tests for RESTful queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:5 S TAGS(I)="MED"_I_"^VPRJTP02"
 D BLDPT^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
TIMERNG ;; @TEST query for range of time
 ;;{"apiVersion":"1.0","data":{"updated":20120517174918,"totalItems":3,"items":[{
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/med-time/?range=20060101..20061231")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(3,JSON("data","totalItems"))
 D ASSERT("METFORMIN",JSON("data","items",3,"products",1,"ingredientName"))
 Q
LAST ;; @TEST query for last instance of items in list
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/last/med-ingredient-name?range=Metformin, Aspirin Tab")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(2,JSON("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:18069",JSON("data","items",1,"uid"))
 D ASSERT("urn:va:med:93EF:-7:18068",JSON("data","items",2,"uid"))
 Q
ORDASC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?order=qualifiedName asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("WARFARIN",JSON("data","items",5,"qualifiedName"))
 Q
ORDDESC ;; @TEST query to return in different order
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?order=qualifiedName DESC")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("WARFARIN",JSON("data","items",1,"qualifiedName"))
 Q
ORDEMPTY ;; @TEST "order by" where field includes empty string
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?order=stopped")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("",JSON("data","items",1,"stopped"))
 D ASSERT("20080128",JSON("data","items",5,"stopped"))
 Q
FILTER ;; @TEST filter to return based on criteria
 ;;{"apiVersion":"1.0","data":{"updated":20120517174918,"totalItems":3,"items":[{
 N ROOT,JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication/?filter=gt(""orders[].fillsRemaining"",4)")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:17203",JSON("data","items",1,"uid"))
 ;D SHOWRSP^VPRJTX(ROOT)
 Q
GETUID ;; @TEST getting an object by UID only
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/uid/"_"urn:va:med:93EF:-7:18068")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("ASPIRIN",JSON("data","items",1,"qualifiedName"))
 Q
EVERY ;; @TEST retrieving every object for a patient
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/every")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(6,JSON("data","totalItems"))
 D ASSERT(0,$D(^TMP($J,$J)))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 K JSON
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/every?start=3&limit=3")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(3,JSON("data","currentItemCount"))
 D ASSERT(10,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"))))
 D ASSERT(0,$D(^VPRTMP($$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/every////"),$J)))
 Q
FINDALL ;; @TEST finding every object in collection
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/find/med")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(5,JSON("data","totalItems"))
 Q
FINDPAR ;; @TEST finding with parameters
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/find/med?filter=eq(""products[].ingredientName"",""METFORMIN"") eq(""dosages[].dose"",""250 MG"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:16982",JSON("data","items",1,"uid"))
 Q
FINDLIKE ;; @TEST finding using like()
 N JSON,ERR,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/find/med?filter=like(""products[].ingredientName"",""ASPIRIN%25"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(1,JSON("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:18068",JSON("data","items",1,"uid"))
 Q
ADDOBJ ;; @TEST adding object to store
 N HTTPERR
 D SETPUT^VPRJTX("/vpr/"_VPRJTPID,"MED6","VPRJTP02")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/"_VPRJTPID_"/urn:va:med:93EF:-7:15231",HTTPREQ("location"))
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:med:93EF:-7:15231")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","medication","79949668=","urn:va:med:93EF:-7:15231",1)))
 Q
DELOBJ ;; @TEST remove object from store
 N HTTPERR
 D SETDEL^VPRJTX("/vpr/uid/urn:va:med:93EF:-7:15231")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(0,$D(^VPRPT(VPRJTPID,"urn:va:med:93EF:-7:15231")))
 D ASSERT(0,$D(^VPRPTI(VPRJTPID,"list","medication",20050331,"urn:va:med:93EF:-7:15231")))
 Q
ADDPT ;; @TEST add new patient
 N MYPID,JSON,HTTPERR
 D SETPUT^VPRJTX("/vpr","DEMOG8","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 S MYPID=$G(^VPRPTJ("PID","93EF;-8"))
 D ASSERT("93EF;-8",MYPID)
 D ASSERT("/vpr/"_MYPID_"/urn:va:patient:93EF:-8:-8",HTTPREQ("location"))
 ; do it again, make sure we get the same PID
 D SETPUT^VPRJTX("/vpr","DEMOG8","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/"_MYPID_"/urn:va:patient:93EF:-8:-8",HTTPREQ("location"))
 ; now get the patient demographics
 D SETGET^VPRJTX("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(-88888888,JSON("data","items",1,"ssn"))
 D SETDEL^VPRJTX("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(0,$D(^VPRPT(MYPID)))
 D ASSERT(0,$D(^VPRPTJ("JSON",MYPID)))
 D ASSERT(0,$D(^VPRPTI(MYPID)))
 Q
NOICN ;; @TEST add patient without ICN
 N HTTPERR,JSON
 D SETPUT^VPRJTX("/vpr","DEMOG9","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/93EF;-9/urn:va:patient:93EF:-9:-9",HTTPREQ("location"))
 ; do it again for same pid
 D SETPUT^VPRJTX("/vpr","DEMOG9","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/93EF;-9/urn:va:patient:93EF:-9:-9",HTTPREQ("location"))
 D ASSERT(1,$D(^VPRPT("93EF;-9"))>0)
 ; one more time for date of death
 D SETPUT^VPRJTX("/vpr","DIED9","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/93EF;-9/urn:va:patient:93EF:-9:-9",HTTPREQ("location"))
 D ASSERT(1,$D(^VPRPT("93EF;-9"))>0)
 D SETGET^VPRJTX("/vpr/93EF;-9")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("666223456",JSON("data","items",1,"ssn"))
 D ASSERT("20120524",JSON("data","items",1,"dateOfDeath"))
 D ASSERT("93EF;-9",JSON("data","items",1,"pid"))
 D SETDEL^VPRJTX("/vpr/93EF;-9")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(0,$D(^VPRPT("93EF;-9")))
 D ASSERT(0,$D(^VPRPTJ("JSON","93EF;-9")))
 D ASSERT(0,$D(^VPRPTI("93EF;-9")))
 Q
ADDICN ;; @TEST add an ICN where the patient did not previously have one
 N HTTPERR,JSON
 D SETPUT^VPRJTX("/vpr","DEMOG9","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/93EF;-9/urn:va:patient:93EF:-9:-9",HTTPREQ("location"))
 D SETPUT^VPRJTX("/vpr","NEWICN9","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/93EF;-9/urn:va:patient:93EF:-9:-9",HTTPREQ("location"))
 D ASSERT(1,$D(^VPRPT("93EF;-9"))>0)
 D SETGET^VPRJTX("/vpr/93EF;-9")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("666223456",JSON("data","items",1,"ssn"))
 D ASSERT("-999V123999",JSON("data","items",1,"icn"))
 D ASSERT("93EF;-9",JSON("data","items",1,"pid"))
 Q
NSITE ;; @TEST multiple sites for patient demographics
 N HTTPREQ,HTTPERR,JSON
 D SETPUT^VPRJTX("/vpr/"_VPRJTPID,"D7BAD","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(1,$G(HTTPERR)>0)  ; should have bad ICN error
 D ASSERT(0,$D(^VPRPTJ("PID","93CC;-7"))>1)
 D ASSERT(0,$D(^VPRPTJ("PID","-787"))>1)
 K HTTPREQ,HTTPERR
 D SETPUT^VPRJTX("/vpr/"_VPRJTPID,"D7GOOD","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("93EF;-7",$G(^VPRPTJ("PID","-777")))
 D ASSERT(1,$D(^VPRPTJ("PID","93EF;-7",-777))>0)
 Q
FULLICN ;; @TEST get patient info using full ICN
 N HTTPREQ,HTTPERR,JSON
 D SETGET^VPRJTX("/vpr/-777V123777")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("urn:va:patient:93DD:-7:-7",JSON("data","items",1,"uid"))
 D ASSERT("93EF;-7",^VPRPTJ("PID","93EF;-7"))
 D ASSERT("93EF;-7",^VPRPTJ("PID","-777V123777"))
 D ASSERT(1,$D(^VPRPTJ("PID","93EF;-7","-777V123777")))
 Q
NUMFAC ;; @TEST fully numeric facility id
 N MYPID,JSON,HTTPERR
 D SETPUT^VPRJTX("/vpr","NUMFAC","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 S MYPID=$G(^VPRPTJ("PID","-111"))
 D ASSERT("4321;-1",MYPID)
 D ASSERT("/vpr/"_MYPID_"/urn:va:patient:4321:-1:-1",HTTPREQ("location"))
 ; do it again, make sure we get the same PID
 D SETPUT^VPRJTX("/vpr","NUMFAC","VPRJTP01")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/"_MYPID_"/urn:va:patient:4321:-1:-1",HTTPREQ("location"))
 ; now get the patient demographics
 D SETGET^VPRJTX("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(-111111111,JSON("data","items",1,"ssn"))
 D ASSERT("4321;-1",JSON("data","items",1,"pid"))
 D SETDEL^VPRJTX("/vpr/"_MYPID)
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT(0,$D(^VPRPT(MYPID)))
 D ASSERT(0,$D(^VPRPTJ("JSON",MYPID)))
 D ASSERT(0,$D(^VPRPTI(MYPID)))
 Q
DELCLTN ;; @TEST delete collection via REST
 N HTTPERR,X
 S X=$O(^VPRPT(VPRJTPID,"urn:va:med:")) D ASSERT(1,+(X["med"))
 D SETDEL^VPRJTX("/vpr/"_VPRJTPID_"/collection/med")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 S X=$O(^VPRPT(VPRJTPID,"urn:va:med:")) D ASSERT(0,+(X["med"))
 Q

VPRJTPR1^INT^1^63294;58829^0
VPRJTPR1 ;SLC/KCM -- Integration tests for RESTful paging
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,TAGS
 F I=1:1:5 S TAGS(I)="MED"_I_"^VPRJTP02"
 D BLDPT^VPRJTX(.TAGS)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
SETUP    ; Run before each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
TEARDOWN ; Run after each test
 K HTTPREQ,HTTPERR,HTTPRSP
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
PAGE1 ;; @TEST query for first page
 N JSON,HTTPERR,HASH
 S HASH=$$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/medication////")
 D ASSERT(0,$D(^VPRTMP(HASH)))
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?start=0&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(2,JSON("data","currentItemCount"))
 D ASSERT(5,JSON("data","totalItems"))
 D ASSERT("urn:va:med:93EF:-7:17203",JSON("data","items",2,"uid"))
 D ASSERT(10,$D(^VPRTMP(HASH)))
 Q
PAGE3 ;; @TEST query for last page
 N JSON,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?start=4&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(1,JSON("data","currentItemCount"))
 D ASSERT(5,JSON("data","totalItems"))
 D ASSERT(4,JSON("data","startIndex"))
 D ASSERT("urn:va:med:93EF:-7:18068",JSON("data","items",1,"uid"))
 Q
PAGECHG ;; @TEST query when page changed
 W "(pause 1 sec)" H 1 ; wait long enough for the second to change
 N JSON,HTTPERR,HASH
 S HASH=$$HASH^VPRJRUT("vpr/index/"_VPRJTPID_"/medication////")
 D ASSERT(5,^VPRTMP(HASH,"total"))
 D SETPUT^VPRJTX("/vpr/"_VPRJTPID,"MED6","VPRJTP02")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D ASSERT("/vpr/"_VPRJTPID_"/urn:va:med:93EF:-7:15231",HTTPREQ("location"))
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?start=0&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(6,^VPRTMP(HASH,"total"))
 Q
LIMIT1 ;; @TEST query when order changed and want only 1 item
 N JSON,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication?order=overallStart asc&limit=1")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT(1,JSON("data","currentItemCount"))
 D ASSERT(0,JSON("data","startIndex"))
 D ASSERT("urn:va:med:93EF:-7:18068",JSON("data","items",1,"uid"))
 Q
TEMPLATE ;; @TEST query using template
 N JSON,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication/uid?start=2&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("uid",$O(JSON("data","items",1,"")))
 D ASSERT("uid",$O(JSON("data","items",2,"")))
 D ASSERT(2,JSON("data","currentItemCount"))
 D ASSERT(1,JSON("data","pageIndex"))
 Q
SUMMTLT ;; @TEST query using summary template
 N JSON,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication/summary?start=2&limit=2")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("Camp Master",JSON("data","items",1,"facilityName"))
 D ASSERT("not active",JSON("data","items",1,"medStatusName"))
 D ASSERT(2,JSON("data","currentItemCount"))
 D ASSERT(1,JSON("data","pageIndex"))
 Q
NOLIMIT ;; @TEST query when no paging is requested
 N JSON,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/medication/uid")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.JSON)
 D ASSERT("uid",$O(JSON("data","items",1,"")))
 D ASSERT("uid",$O(JSON("data","items",2,"")))
 D ASSERT(6,JSON("data","currentItemCount"))
 D ASSERT(0,$D(JSON("data","pageIndex")))
 Q

VPRJTPR2^INT^1^63396;54290^0
VPRJTPR2 ;SLC/KCM -- Integration tests for RESTful templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N I,DATALST
 F I=1:1:5 S DATALST(I)="DATA"_I_"^VPRJTP03"
 D BLDPT^VPRJTX(.DATALST)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
RELSING ;; @TEST loading patient with REL template - single value
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest-c/rel;utest-single")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 ;D SENDATA^VPRJRSP
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("a2",RSP("data","items",1,"from","localId"))
 D ASSERT(10,$D(RSP("data","items",1,"from","dosages")))
 D ASSERT(10,$D(RSP("data","items",1,"from","fills")))
 Q
RELMULT ;; @TEST loading patient with REL template - multiple values
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest-c/rel;utest-multiple")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("a1",RSP("data","items",1,"dest",1,"obj","localId"))
 D ASSERT("b3",RSP("data","items",1,"dest",2,"obj","localId"))
 Q
RELSUMM ;; @TEST loading patient with REL template -- summary
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest-c/rel;utest-multiple;unit-test-summary")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT(20121229103022,RSP("data","items",1,"dest",1,"obj","dateTime"))
 D ASSERT(20101229103022,RSP("data","items",1,"dest",2,"obj","dateTime"))
 D ASSERT(0,$D(RSP("data","items",1,"dest",1,"obj","localId")))
 D ASSERT(0,$D(RSP("data","items",1,"dest",2,"obj","localId")))
 Q
REVUID ;; @TEST loading UID only using the REV template
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest/rev;utest-multiple;uid?order=uid asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("urn:va:utestc:93EF:-7:23",RSP("data","items",1,"testItems",1,"uid"))
 D ASSERT("urn:va:utestc:93EF:-7:42",RSP("data","items",1,"testItems",2,"uid"))
 D ASSERT("urn:va:utestc:93EF:-7:23",RSP("data","items",3,"testItems",1,"uid"))
 D ASSERT(0,$D(RSP("data","items",1,"testItems",1,"localId")))
 D ASSERT(0,$D(RSP("data","items",2,"testItems")))
 Q
REVFULL ;; @TEST loading using the REV template
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest/rev;utest-multiple?order=uid asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("urn:va:utestc:93EF:-7:23",RSP("data","items",1,"testItems",1,"uid"))
 D ASSERT("urn:va:utestc:93EF:-7:42",RSP("data","items",1,"testItems",2,"uid"))
 D ASSERT("urn:va:utestc:93EF:-7:23",RSP("data","items",3,"testItems",1,"uid"))
 D ASSERT("c1",RSP("data","items",1,"testItems",1,"localId"))
 D ASSERT("urn:va:utesta:93EF:-7:2",RSP("data","items",3,"testItems",1,"from"))
 D ASSERT(0,$D(RSP("data","items",2,"testItems")))
 Q
REVSUMM ;; @TEST loading using the REV template -- summary
 N RSP
 D SETGET^VPRJTX("/vpr/"_VPRJTPID_"/index/utest/rev;utest-multiple;unit-test-summary?order=uid asc")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.RSP)
 D ASSERT("testRels",RSP("data","items",1,"testItems",1,"name"))
 D ASSERT("testRelsB",RSP("data","items",1,"testItems",2,"name"))
 D ASSERT("testRels",RSP("data","items",3,"testItems",1,"name"))
 D ASSERT(0,$D(RSP("data","items",2,"testItems")))
 Q
RELTEST ;; add the link spec below to test this
 ;;team-category-link
 ;;  collections: team
 ;;  ref: categoriesDeux[]>categories[].uid
 N RSP
 D SETGET^VPRJTX("/data/find/team/rel;team-category-link")
 D RESPOND^VPRJRSP
 D SENDATA^VPRJRSP
 Q
1 ; do one test
 D STARTUP,RELSUMM,SHUTDOWN
 Q

VPRJTPR3^INT^1^63294;58829^0
VPRJTPR3 ;SLC/KCM -- Integration tests for multi-patient RESTful queries
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N TAGS,I
 S VPRPID7=$$ADDPT^VPRJTX("DEMOG7^VPRJTP01")
 F I=1:1:3 S TAGS(I)="UTST"_I_"^VPRJTP01"
 D ADDDATA^VPRJTX(.TAGS,VPRPID7)
 K TAGS
 S VPRPID8=$$ADDPT^VPRJTX("DEMOG8^VPRJTP01")
 F I=4:1:5 S TAGS(I)="UTST"_I_"^VPRJTP01"
 D ADDDATA^VPRJTX(.TAGS,VPRPID8)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 K VPRPID7,VPRPID8
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
INDEX ;; @TEST index query for multiple patients
 N OBJ,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRPID7_","_VPRPID8_"/index/utest-c")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.OBJ)
 D ASSERT(5,OBJ("data","totalItems"))
 D ASSERT(VPRPID7,OBJ("data","items",1,"pid"))
 D ASSERT(VPRPID8,OBJ("data","items",4,"pid"))
 Q
LAST ;; @TEST last query for multiple patients
 N OBJ,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRPID7_","_VPRPID8_"/last/utest-c")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.OBJ)
 D ASSERT(2,OBJ("data","totalItems"))
 D ASSERT(VPRPID7,OBJ("data","items",1,"pid"))
 D ASSERT(VPRPID8,OBJ("data","items",2,"pid"))
 Q
FIND1 ;; @TEST find query with multiple patients (one match)
 N OBJ,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRPID7_","_VPRPID8_"/find/utestc?filter=eq(""color"",""purple"")")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.OBJ)
 D ASSERT(1,OBJ("data","totalItems"))
 D ASSERT(VPRPID8,OBJ("data","items",1,"pid"))
 Q
FIND2 ;; @TEST find query with multiple patients (multiple matches)
 N OBJ,HTTPERR
 D SETGET^VPRJTX("/vpr/"_VPRPID7_","_VPRPID8_"/find/utestc?filter=eq(rate,3)")
 D RESPOND^VPRJRSP
 D ASSERT(0,$G(HTTPERR))
 D DATA2ARY^VPRJTX(.OBJ)
 D ASSERT(3,OBJ("data","totalItems"))
 D ASSERT(VPRPID7,OBJ("data","items",2,"pid"))
 D ASSERT(VPRPID8,OBJ("data","items",3,"pid"))
 D ASSERT("urn:va:utestc:93EF:-7:1",OBJ("data","items",1,"uid"))
 D ASSERT("urn:va:utestc:93EF:-7:3",OBJ("data","items",2,"uid"))
 D ASSERT("urn:va:utestc:93EF:-8:5",OBJ("data","items",3,"uid"))
 Q

VPRJTPS^INT^1^63400;42551^0
VPRJTPS ;SLC/KCM -- Integration tests for saving patient objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 N DATA
 S VPRJTPID=$G(^VPRPTJ("PID","93EF:-7"))
 I VPRJTPID D CLEARPT^VPRJPS(VPRJTPID)
 Q
SHUTDOWN ; Run once after all tests
 D CLRPT^VPRJTX
 Q
ASSERT(EXPECT,ACTUAL,MSG) ; for convenience
 D EQ^VPRJT(EXPECT,ACTUAL,$G(MSG))
 Q
 ;
ADDPT ;; @TEST adding a patient
 N DATA
 D GETDATA^VPRJTX("DEMOG7","VPRJTP01",.DATA)
 S VPRJTPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 D ASSERT(1,$L(VPRJTPID)>0)
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:patient:93EF:-7:-7")))
 D ASSERT(-77777777,^VPRPT(VPRJTPID,"urn:va:patient:93EF:-7:-7","ssn"))
 D ASSERT("93EF;-7",VPRJTPID)
 D ASSERT("93EF;-7",^VPRPTJ("PID",VPRJTPID))
 D ASSERT("93EF;-7",^VPRPTJ("PID","93EF;-7"))
 D ASSERT(1,$D(^VPRPTJ("JSON",VPRJTPID,"urn:va:patient:93EF:-7:-7",1)))
 Q
ADDOBJ ;; @TEST adding an object
 N DATA,LOC
 D GETDATA^VPRJTX("MED1","VPRJTP02",.DATA)
 S LOC=$$SAVE^VPRJPS(VPRJTPID,.DATA)
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:med:93EF:-7:16982")))
 D ASSERT("urn:vuid:4023979",^VPRPT(VPRJTPID,"urn:va:med:93EF:-7:16982","products",1,"ingredientCode"))
 D ASSERT(1,$D(^VPRPTJ("JSON",VPRJTPID,"urn:va:med:93EF:-7:16982",1)))
 D ASSERT(19350407,+$P(^VPRPTJ("TEMPLATE",VPRJTPID,"urn:va:patient:93EF:-7:-7","summary",1),":",2))
 D ASSERT(1,^VPRPTI(VPRJTPID,"tally","collection","med"))
 Q
CHKIDX ;; @TEST indexes that were built after adding object
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-class-code","urn:vadc:hs502 ","79939681=","urn:va:med:93EF:-7:16982","products#1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-provider","labtech,special ","79939681=","urn:va:med:93EF:-7:16982","orders#1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-qualified-name","metformin ","79939681=","urn:va:med:93EF:-7:16982",1)))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","medication","79939681=","urn:va:med:93EF:-7:16982",1)))
 D ASSERT("79939681=",^VPRPTI(VPRJTPID,"time","med-time","79949682=","urn:va:med:93EF:-7:16982",1))
 D ASSERT("79949682=",^VPRPTI(VPRJTPID,"stop","med-time","79939681=","urn:va:med:93EF:-7:16982",1))
 D ASSERT(1,^VPRPTI(VPRJTPID,"tally","kind","medication, outpatient"))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"attr","med-active-outpt","79939681=","urn:va:med:93EF:-7:16982",1)))
 Q
ADDLNK ;; @TEST adding object with links defined
 N I,TAGS
 F I=1:1:5 S TAGS(I)="DATA"_I_"^VPRJTP03"
 D ADDDATA^VPRJTX(.TAGS,VPRJTPID)
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"rev","urn:va:utesta:93EF:-7:1","utest-multiple","urn:va:utestc:93EF:-7:23","items#1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"rev","urn:va:utestb:93EF:-7:3","utest-multiple","urn:va:utestc:93EF:-7:23","items#2")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"rev","urn:va:utesta:93EF:-7:2","utest-single","urn:va:utestc:93EF:-7:23",1)))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"rev","urn:va:utesta:93EF:-7:1","utest-multiple","urn:va:utestc:93EF:-7:42","items#1")))
 D ASSERT(1,$D(^VPRPTI(VPRJTPID,"rev","urn:va:utesta:93EF:-7:1","utest-single","urn:va:utestc:93EF:-7:42",1)))
 Q
DELCLTN ;; @TEST delete a collection for a patient
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:utestc:93EF:-7:23")))
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:utestc:93EF:-7:42")))
 D DELCLTN^VPRJPS(VPRJTPID,"utestc")
 D ASSERT(0,$D(^VPRPT(VPRJTPID,"urn:va:utestc:93EF:-7:23")))
 D ASSERT(0,$D(^VPRPT(VPRJTPID,"urn:va:utestc:93EF:-7:42")))
 D ASSERT(0,$D(^VPRPTI(VPRJTPID,"attr","utest-c","testrels ","urn:va:utestc:93EF:-7:23",1)))
 D ASSERT(0,$G(^VPRPTI("93EF;-7","tally","collection","utestc"),0))
 Q
DELCSRV ;; @TEST delete a collection for a specific server
 N I,TAGS
 F I=6:1:7 S TAGS(I)="SRV"_I_"^VPRJTP03"
 D ADDDATA^VPRJTX(.TAGS,VPRJTPID)
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:utesta:93EF:-7:1")))
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:utesta:9999:-7:6")))
 D DELCLTN^VPRJPS(VPRJTPID,"utesta","9999")
 D ASSERT(0,$D(^VPRPT(VPRJTPID,"urn:va:utesta:9999:-7:6")))
 D ASSERT(10,$D(^VPRPT(VPRJTPID,"urn:va:utesta:93EF:-7:7")))
 Q

VPRJTX^INT^1^63294;58829^0
VPRJTX ;SLC/KCM -- Utilities for unit tests
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
BLDPT(TAGS) ; Build test patient for integration tests with data in TAGS
 ; TAGS(n)=TAG^RTN  ; entry point for each JSON object, zzzzz terminated
 N DATA
 S VPRJTPID=$G(^VPRPTJ("PID","93EF;-7"))
 I $L(VPRJTPID) D CLEARPT^VPRJPS(VPRJTPID)
 S VPRJTPID=$$ADDPT("DEMOG7^VPRJTP01")
 I $D(TAGS) D ADDDATA(.TAGS,VPRJTPID)
 Q
ADDPT(TAG) ; Build a test patient and return the PID
 N VPRPID,DATA
 D GETDATA($P(TAG,"^"),$P(TAG,"^",2),.DATA)
 S VPRPID=$P($$PUTPT^VPRJPR("",.DATA),"/",3)
 Q VPRPID
 ;
ADDDATA(TAGS,VPRPID) ; Add data for the patient identified in VPRJTPID
 N I,JSON,OBJ,LOC
 Q:'$D(TAGS)
 S I="" F  S I=$O(TAGS(I)) Q:'I  D
 . N JSON,OBJ
 . D GETDATA($P(TAGS(I),"^"),$P(TAGS(I),"^",2),.JSON)
 . D DECODE^VPRJSON("JSON","OBJ")
 . K JSON
 . S OBJ("pid")=VPRPID
 . D ENCODE^VPRJSON("OBJ","JSON")
 . S LOC=$$SAVE^VPRJPS(VPRPID,.JSON)
 Q
CLRPT ; Clear test patients
 N DFN,VPRPID
 S DFN="93EF;-" F  S DFN=$O(^VPRPTJ("PID",DFN)) Q:$E(DFN,1,6)'="93EF;-"  D
 . S VPRPID=^VPRPTJ("PID",DFN)
 . ; W !,"Clearing: "_DFN_"  pid="_VPRPID
 . D CLEARPT^VPRJPS(VPRPID)
 K VPRJTPID
 K HTTPREQ,HTTPERR,HTTPRSP
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
ODSBLD(TAGS) ; Build sample data in non-patient data store
 ; TAGS(n)=TAG^RTN  ; entry point for each JSON object, zzzzz terminated
 N DATA,I,LOC,HTTPREQ
 S HTTPREQ("store")="data"
 D ODSCLR
 S I="" F  S I=$O(TAGS(I)) Q:'I  D
 . D GETDATA($P(TAGS(I),"^"),$P(TAGS(I),"^",2),.DATA)
 . S LOC=$$SAVE^VPRJDS(.DATA)
 . K DATA
 Q
ODSCLR ; Clear sample data from non-patient data store
 D DELCTN^VPRJDS("test")
 D DELCTN^VPRJDS("testb")
 D DELCTN^VPRJDS("utestods")
 K ^TMP($J),^TMP("HTTPERR",$J)
 Q
GETDATA(TAG,RTN,DATA) ; load data from TAG^RTN into .DATA until zzzzz
 N I,L,X
 F I=1:1 S L=$T(@TAG+I^@RTN) Q:'$L(L)  S X=$P(L,";;",2,999) Q:X="zzzzz"  S DATA(I)=X
 Q
DATA2ARY(ARY) ; call SENDATA to write out response and read back into ARY
 ; cause TCP data to be written to file
 D WR4HTTP^VPRJRUT
 D SENDATA^VPRJRSP
 D C4HTTP^VPRJRUT
 ;
 ; read TCP data from file into variable and delete file
 N X,ERR
 S X=$$RD4HTTP^VPRJRUT
 D DECODE^VPRJSON("X","ARY","ERR")
 D EQ^VPRJT(0,$D(ERR))
 Q
SETGET(URL) ; set up a request (to emulate HTTP call)
 S HTTPERR=0
 S HTTPREQ("method")="GET"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SETPUT(URL,TAG,RTN) ; set up a PUT request based on data in TAG^RTN
 N DATA
 S HTTPERR=0
 S HTTPREQ("method")="PUT"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 D GETDATA(TAG,RTN,.DATA)
 M HTTPREQ("body")=DATA
 Q
SETDEL(URL) ; set up a delete request
 S HTTPERR=0
 S HTTPREQ("method")="DELETE"
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
SHOWRSP(ROOT) ; write out response
 N I
 I $D(@ROOT)#2 W !,@ROOT
 S I=0 F  S I=$O(@ROOT@(I)) Q:'I  W !,@ROOT@(I)
 Q
 ;
QCNT(REF) ; return count of nodes in a variable
 N X,CNT,ROOT
 S CNT=0
 S ROOT=$S($E($RE(REF))=")":$E(REF,1,$L(REF)-1),1:REF)
 I $D(@REF)=1 S CNT=CNT+1
 S X=REF F  S X=$Q(@X) Q:$E(X,1,$L(ROOT))'=ROOT  S CNT=CNT+1
 Q CNT
 ;
WO(TAG,RTN) ; Write out JSON as single line
 W !
 N I,X
 F I=1:1 S X=$P($T(@TAG+I^@RTN),";;",2,999) Q:X="zzzzz"  W X
 Q

VPRJTZ^INT^1^63294;58829^0
VPRJTZ ;SLC/KCM -- Miscellaneous Experiments
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
C2D ; Compare collections to domains
 N PID,UID,CLTN,CNT
 S CNT=0
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S UID="" F  S UID=$O(^VPRPT(PID,UID)) Q:'$L(UID)  D
 . . S CLTN=$P(UID,":",3)
 . . Q:$D(^VPRMETA("collection",CLTN,"domain"))
 . . W !,PID,?20,CLTN S CNT=CNT+1
 W !!,CNT
 Q
SUBINDIR ; Compare subscript indirection
 N PID,KEY,UID,START
 S START=$ZH
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D
 . . S UID=$G(^VPRPT(PID,KEY,"uid"))
 W !,"Direct:",$ZH-START
 ;
 S START=$ZH
 S PID="" F  S PID=$O(^VPRPT(PID)) Q:'$L(PID)  D
 . S KEY="" F  S KEY=$O(^VPRPT(PID,KEY)) Q:KEY=""  D
 . . S REF=$NA(^VPRPT(PID,KEY)),UID=$G(@REF@("uid"))
 W !,"Indirect:",$ZH-START
 Q
BLDSPEC(FIELDS,SPEC) ; Build spec then set values given FIELDS
 N CLTNS,ATTR,FULLSPEC
 S CLTNS("utesta")="",ATTR("metatype")="index",ATTR("style")="attr"
 D IDXSPEC^VPRJCD1(.CLTNS,.FIELDS,.ATTR,.FULLSPEC)
 M SPEC=FULLSPEC("collection","utesta")
 Q
IDXVALS ; Compare amount of time for indexing values for indexes .721 -> .815
 N OBJECT,VALUES,FIELDS,SPEC
 S OBJECT("top")="top value"
 S OBJECT("when")="201208121030"
 S OBJECT("how")="miracle"
 S OBJECT("mult",1,"sub")="sub1 value"
 S OBJECT("mult",2,"sub")="sub2 value"
 S OBJECT("mult",2,"provider","name")="Welby"
 S OBJECT("products",1,"drugClassCode")="urn:vadc:HS502"
 S OBJECT("ary1",4,"ary2",47,"val")="4-47"
 S OBJECT("ary1",15,"ary2",103,"val")="15-103"
 S OBJECT("list",1)="list 1"
 S OBJECT("list",2)="list 2"
 S OBJECT("list",3)="list 3"
 ;fields: ary1[].ary2[].val/P, mult[].sub/s
 S FIELDS(0,1)="ary1[].ary2[].val/P",FIELDS(0,2)="mult[].sub/s"
 D BLDSPEC(.FIELDS,.SPEC)
 ;
 N START,I
 S START=$ZH
 F I=1:1:10000 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.SPEC)
 W !,$ZH-START
 Q
URLMAP ;
 N I,J,X,SEG,SUBS,MAP,CNT,PTRN,PTRNS,PTRNVAL
 S CNT=0,PTRNS=0
 F I=1:1 S X=$P($T(URLMAP+I^VPRJRSP),";;",2,99) Q:X="zzzzz"  D
 . S PATH=$P(X," ",2),MTHD=$P(X," "),SUBS="MAP("""_MTHD_"""",PTRNVAL=""
 . F J=1:1:$L(PATH,"/") D
 . . S SEG=$P(PATH,"/",J),PTRN=$S($E(SEG)="{":$P(SEG,"?",2),1:"")
 . . I $L(PTRN),'$D(PTRNS(PTRN)) S PTRNS=PTRNS+1,PTRNS(PTRN)=PTRNS
 . . I $L(PTRN) S $P(PTRNVAL,":",J)=PTRNS(PTRN)
 . . S SUBS=SUBS_","_$S($E(SEG)="{":"""?""",+SEG=SEG:SEG,1:""""_SEG_"""")
 . S CNT=CNT+1,SUBS=SUBS_",""/"","_CNT_")",@SUBS=PTRNVAL
 W ! ZW MAP
 W ! ZW PTRNS
 Q
MATCH(METHOD,PATH,ROUTINE,ARGS) ; Given method and path return routine and arguments
 N ISEG,SEG,URLSIG,TRYSIG,FAIL
 S URLSIG="MAP("_METHOD,FAIL=0
 F ISEG=1:1:$L(PATH,"/") D  Q:FAIL
 . S SEG=$$LOW^XLFSTR($P(PATH,"/",ISEG))
 . S TRYSIG=URLSIG_","_SEG
 . I $D(@(TRYSIG_")")) S URLSIG=TRYSIG Q
 . S TRYSIG=URLSIG_","_"""?"""
 . I $D(@(TRYSIG_")")) S URLSIG=TRYSIG Q
 . S FAIL=1
 ; now loop thru @URLSIG@("/",ID) and execute the pattern matches
 ; for the first one that is true, grab the routine and set the arguments
 I 'FAIL W !,URLSIG
 Q
SRCHLOG ; Search VPRHTTP log
 N D,S,I
 S D=0 F  S D=$O(^VPRHTTP("log",D)) Q:'D  D
 . S S=0 F  S S=$O(^VPRHTTP("log",D,S)) Q:'S  D
 . . S I=0 F  S I=$O(^VPRHTTP("log",D,S,I)) Q:'I  D
 . . . S X=$G(^VPRHTTP("log",D,S,I,"line1"))
 . . . I X'["\vpr" Q
 . . . W !,X
 Q
POSTVPR ; test a post to VPR
 ;;{"uid":"urn:va:patient:F484:8:8","summary":"gov.va.cpe.vpr.PatientDemographics{pids=[10110V004877, 500;8, 666000010, F484;8]}","dateOfBirth":"19450407","ssn":"666000010","last4":"0010","last5":"H0010","icn":"10110V004877","familyName":"HMP-PATIENT","g
 ;;ivenNames":"THIRTY","fullName":"HMP-PATIENT,THIRTY","displayName":"Hmp-Patient,Thirty","genderCode":"urn:va:pat-gender:M","genderName":"Male","briefId":"H0010","sensitive":false,"loading":true,"domainTotals":{},"syncErrorCount":0,"religionCode":"urn:v
 ;;a:pat-religion:24","religionName":"PROTESTANT","veteran":{"summary":"gov.va.cpe.vpr.Veteran@54b057d5","lrdfn":24,"serviceConnected":"true","serviceConnectionPercent":"20"},"lastUpdated":"20131112205833.202","addresses":[{"city":"Any Town","postalCode"
 ;;:"99998-0071","stateProvince":"WEST VIRGINIA","streetLine1":"Any Street"}],"facilities":[{"summary":"CAMP MASTER","code":"500","name":"CAMP MASTER","systemId":"F484","localPatientId":"8","latestDate":"20131011","homeSite":false}],"flags":[{"summary":"
 ;;BEHAVIORAL","name":"BEHAVIORAL","text":"Patient has threatened violence in the past.  You must have at least one other staff member with you to ensure safety."}],"telecoms":[{"telecom":"(222)555-7720","usageCode":"WP","usageName":"work place"},{"telec
 ;;om":"(222)555-8235","usageCode":"H","usageName":"home address"}],"ethnicities":[{"summary":"gov.va.cpe.vpr.PatientEthnicity@569b1e0f","ethnicity":"9999-4"}],"races":[{"summary":"gov.va.cpe.vpr.PatientRace@722f6194","race":"2106-3"}],"maritalStatuses":
 ;;[{"summary":"Never Married","code":"urn:va:pat-maritalStatus:S","name":"Never Married"}],"exposures":[{"uid":"urn:va:combat-vet:N","name":"No"},{"uid":"urn:va:agent-orange:N","name":"No"},{"uid":"urn:va:mst:U","name":"Unknown"},{"uid":"urn:va:head-nec
 ;;k-cancer:U","name":"Unknown"},{"uid":"urn:va:ionizing-radiation:N","name":"No"},{"uid":"urn:va:sw-asia:N","name":"No"}],"supports":[{"summary":"VETERAN,BROTHER","name":"VETERAN,BROTHER","contactTypeCode":"urn:va:pat-contact:NOK","contactTypeName":"Nex
 ;;t of Kin"}],"pcTeamUid":"urn:va:team:F484:5","disability":["AUDITORY CANAL DISEASE^10^1","SUPRAVENTRICULAR ARRHYTHMIAS^30^1"],"localId":8,"pcTeamName":"PRIMARY CARE TEAM2"}
 ;;zzzzz
 ;
 N HTTPREQ,HTTPERR,JSON
 D SETPUT^VPRJTX("/vpr","POSTVPR","VPRJTZ")
 D RESPOND^VPRJRSP
 D SENDATA^VPRJRSP
 Q
CLRPOST ;
 D CLEARPT^VPRJPS(10110)
 Q

VPRJUCD^INT^1^63396;54290^0
VPRJUCD ;SLC/KCM -- Unit tests for building meta-data
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
LASTARY ;; @TEST finding last array node
 D ASSERT(0,$$LASTARY^VPRJCD("one.two.three"))
 D ASSERT(2,$$LASTARY^VPRJCD("one[].two[].three"))
 D ASSERT(3,$$LASTARY^VPRJCD("one.two.three[]"))
 D ASSERT(3,$$LASTARY^VPRJCD("one[].two.three[].four.five"))
 D ASSERT(2,$$LASTARY^VPRJCD("one[].two[#].three[].four","#"))
 Q
 ;
ARYCLCT ;; @TEST parsing for collection array modifier
 D ASSERT("",$$ARYCLCT^VPRJCD("ary[]"))
 D ASSERT(",",$$ARYCLCT^VPRJCD("ary[*]"))
 D ASSERT("",$$ARYCLCT^VPRJCD("ary[#]"))
 D ASSERT(" / ",$$ARYCLCT^VPRJCD("ary[* / ]"))
 Q
ARYDIR ;; @TEST parsing for direction array modifier
 D ASSERT(1,$$ARYDIR^VPRJCD("ary[]"))
 D ASSERT(-1,$$ARYDIR^VPRJCD("ary[-3]"))
 D ASSERT(1,$$ARYDIR^VPRJCD("ary[3]"))
 D ASSERT(1,$$ARYDIR^VPRJCD("ary[1]"))
 D ASSERT(0,$$ARYDIR^VPRJCD("ary[#]"))
 Q
ARYMAX ;; @TEST parsing for max array modifier
 D ASSERT(999999,$$ARYMAX^VPRJCD("ary[]"))
 D ASSERT(3,$$ARYMAX^VPRJCD("ary[-3]"))
 D ASSERT(1,$$ARYMAX^VPRJCD("ary[1]"))
 D ASSERT(1,$$ARYMAX^VPRJCD("ary[#]"))
 D ASSERT(999999,$$ARYMAX^VPRJCD("ary[*/]"))
 Q
GETTGT ;; @TEST getting a target field from a field spec
 D ASSERT("var",$$GETTGT^VPRJCD("var=othervar"))
 D ASSERT("items[].obj",$$GETTGT^VPRJCD("items[].obj>items[].uid;summary"))
 D ASSERT("ary1[].ary2[]",$$GETTGT^VPRJCD("ary1[].ary2[]"))
 D ASSERT("ary1[].field",$$GETTGT^VPRJCD("ary1[].field"))
 D ASSERT("ary1[]",$$GETTGT^VPRJCD("ary1[].*"))
 D ASSERT("ary1[].field",$$GETTGT^VPRJCD("ary1[#].field"))
 D ASSERT("ary1[].field",$$GETTGT^VPRJCD("ary1[*,].field"))
 D ASSERT("ary1[].ary2[].ary3[]",$$GETTGT^VPRJCD("ary1[#].ary2[-1].ary3[*].*"))
 Q
BLDREF ;; @TEST building a node reference from object notation
 N X
 S X=$$BLDREF^VPRJCD("results[].clinician.name")
 D ASSERT("OBJECT(""results"",I(1),""clinician"",""name"")",X)
 S X=$$BLDREF^VPRJCD("summary")
 D ASSERT("OBJECT(""summary"")",X)
 S X=$$BLDREF^VPRJCD("results[].units")
 D ASSERT("OBJECT(""results"",I(1),""units"")",X)
 S X=$$BLDREF^VPRJCD("clinician.name")
 D ASSERT("OBJECT(""clinician"",""name"")",X)
 S X=$$BLDREF^VPRJCD("clinicians[]")
 D ASSERT("OBJECT(""clinicians"",I(1))",X)
 S X=$$BLDREF^VPRJCD("test[].organism[].antibiotic[]")
 D ASSERT("OBJECT(""test"",I(1),""organism"",I(2),""antibiotic"",I(3))",X)
 S X=$$BLDREF^VPRJCD("test[].organism[].antibiotic[].sensitivity")
 D ASSERT("OBJECT(""test"",I(1),""organism"",I(2),""antibiotic"",I(3),""sensitivity"")",X)
 Q
BLDIPATH ;; @TEST building an instance path reference
 D ASSERT("one",$$BLDIPATH^VPRJCD("one[]"))
 D ASSERT("test.one.two",$$BLDIPATH^VPRJCD("test.one[].two[]"))
 D ASSERT("one.two.three",$$BLDIPATH^VPRJCD("one[].two[].three[]"))
 D ASSERT("one.two",$$BLDIPATH^VPRJCD("one.two[]"))
 D ASSERT("top.list.next.list",$$BLDIPATH^VPRJCD("top.list[].next.list[]"))
 Q
FLDSPEC ;; @TEST building a field spec
 N SPEC
 D FLDSPEC^VPRJCD("uid",.SPEC,"src")
 D ASSERT("uid",SPEC("srcPath",1))
 D ASSERT(0,$D(SPEC("srcArrays")))
 D ASSERT(6,$$QCNT^VPRJTX("SPEC"))
 K SPEC
 D FLDSPEC^VPRJCD("clinicians[].name",.SPEC,"src")
 D ASSERT("clinicians",SPEC("srcPath",1))
 D ASSERT("OBJECT(""clinicians"",I(1))",SPEC("srcArrays",1,"ref"))
 D ASSERT(1,SPEC("srcArrays"))
 D ASSERT("OBJECT(""clinicians"",I(1),""name"")",SPEC("srcRef"))
 D ASSERT(14,$$QCNT^VPRJTX("SPEC"))
 K SPEC
 D FLDSPEC^VPRJCD("top.mult[].person.name",.SPEC,"src")
 D ASSERT(1,SPEC("srcArrays"))
 D ASSERT("OBJECT(""top"",""mult"",I(1))",SPEC("srcArrays",1,"ref"))
 D ASSERT("OBJECT(""top"",""mult"",I(1),""person"",""name"")",SPEC("srcRef"))
 K SPEC
 D FLDSPEC^VPRJCD("top.middle.terminal",.SPEC,"src")
 D ASSERT(0,$D(SPEC("srcArrays")))
 D ASSERT("OBJECT(""top"",""middle"",""terminal"")",SPEC("srcRef"))
 K SPEC
 D FLDSPEC^VPRJCD("top.mult[]",.SPEC,"src")
 D ASSERT("OBJECT(""top"",""mult"",I(1))",SPEC("srcRef"))
 K SPEC
 D FLDSPEC^VPRJCD("top[].middle[].bottom[].field",.SPEC,"tgt")
 D ASSERT(3,SPEC("tgtArrays"))
 D ASSERT("TARGET(""top"",I(1),""middle"",J)",SPEC("tgtArrays",2,"ref"))
 D ASSERT("TARGET(""top"",I(1),""middle"",I(2),""bottom"",J,""field"")",SPEC("tgtRef"))
 K SPEC
 D FLDSPEC^VPRJCD("top[].*",.SPEC,"src")
 D ASSERT(1,SPEC("merge"))
 D ASSERT("OBJECT(""top"",I(1))",SPEC("srcRef"))
 Q
FLDERR ;; @TEST field spec with errors
 N SPEC,ERRORS
 D FLDSPEC^VPRJCD("one.[].two",.SPEC,"src") D ASSERT(11,$D(ERRORS)) K ERRORS
 D FLDSPEC^VPRJCD("one[abc].two",.SPEC,"src") D ASSERT(11,$D(ERRORS)) K ERRORS
 D FLDSPEC^VPRJCD("one.",.SPEC,"src") D ASSERT(11,$D(ERRORS)) K ERRORS
 Q
BLDLINK ;; @TEST build linkage metadata
 N LINES,META,COLL
 S LINES=4
 S LINES(1)="test-multiple"
 S LINES(2)="  collections: testa,testb"
 S LINES(3)="  ref: items[].obj>items[].uid;summary"
 S LINES(4)="  rev: testItems"
 D BLDSPEC^VPRJCD("link",.LINES,.META,.COLL)
 D ASSERT(1,META("test-multiple","collection","testa",1,1,"srcMethod"))
 D ASSERT("uid",META("test-multiple","collection","testa",1,1,"srcPath",2))
 D ASSERT("items",META("test-multiple","collection","testa",1,"tgtPath",1))
 D ASSERT("summary",META("test-multiple","collection","testb",1,1,"srcTemplate"))
 D ASSERT("VALS(1,I(1))",META("test-multiple","collection","testb",1,"valRef"))
 D ASSERT("TARGET(""items"",J,""obj"")",META("test-multiple","collection","testb",1,"tgtRef"))
 D ASSERT(1,$D(COLL("testb","link","test-multiple")))
 Q
BLDIDX(TAG,STYLE,IDX) ;; return spec in IDX
 N I,X,LINES,SPEC,CLTN
 S I=0 F  S I=I+1,X=$P($T(@TAG+I),";;",2,99) Q:X="zzzzz"  S LINES(I)=X
 D BLDSPEC^VPRJCD("index:"_STYLE,.LINES,.SPEC,.CLTN)
 S X=$O(SPEC(""))
 M IDX=SPEC(X)
 Q
 ;
ATTR ;; @TEST setting up attribute index meta data
 ;;utest-attributes
 ;;    collections: utesta,utestb
 ;;    fields: products[].ingredientName/s, overallStop/V/0
 ;;    fields.utestb: ingredients[].product.name, current.datetime
 ;;    sort: overallStop desc
 ;;    setif: $$READY^MYFUN
 ;;    review:  $$CALCTM^MYFUN
 ;;zzzzz
 N SPEC
 D BLDIDX("ATTR","attr",.SPEC)
 D ASSERT("attr",SPEC("common","method"))
 D ASSERT(2,SPEC("common","alias","overallStop"))
 D ASSERT(2,SPEC("common","levels"))
 D ASSERT(1,SPEC("collection","utesta",1,1,"srcMethod"))
 D ASSERT(99,SPEC("collection","utestb",1,1,"srcMethod"))
 D ASSERT("ingredientName",SPEC("collection","utesta",1,1,"srcPath",2))
 D ASSERT("name",SPEC("collection","utestb",1,1,"srcPath",3))
 D ASSERT("OBJECT(""ingredients"",I(1))",SPEC("collection","utestb",1,1,"srcArrays",1,"ref"))
 D ASSERT("$$READY^MYFUN",SPEC("collection","utesta","setif"))
 D ASSERT("$$CALCTM^MYFUN",SPEC("collection","utestb","review"))
 D ASSERT("V",SPEC("collection","utestb",2,"collate"))
 Q
LIST ;; @TEST setting up list index meta data
 ;;utest-none
 ;;    collections: utest
 ;;    fields: <none>
 ;;zzzzz
 N SPEC
 D BLDIDX("LIST","attr",.SPEC)
 D ASSERT(0,SPEC("common","levels"))
 D ASSERT(0,$D(SPEC("collection","utest",1)))
 Q
TIME ;; @TEST setting up time index meta data
 ;;utest-time
 ;;    collections: utesta,utestb
 ;;    fields: start/V/0,stop/V/9
 ;;    fields.utesta: observed
 ;;    fields.utestb: overallStart, overallStop
 ;;    sort: observed desc
 ;;zzzzz
 N SPEC
 D BLDIDX("TIME","time",.SPEC)
 D ASSERT(1,SPEC("common","alias","start"))
 D ASSERT(2,SPEC("common","alias","stop"))
 D ASSERT("observed",SPEC("collection","utesta",1,1,"srcPath",1))
 D ASSERT("overallStart",SPEC("collection","utestb",1,1,"srcPath",1))
 D ASSERT(0,$D(SPEC("collection","utesta",2)))
 D ASSERT(10,$D(SPEC("collection","utestb",2)))
 Q
ATTRERR ;; @TEST setting up attribute index with errors
 ;;utest-attributes
 ;;    collections: utesta,utestb
 ;;    fields: products[].ingredientName/s, overallStop/V/0
 ;;    fields.utestb: ingredients[].product.name
 ;;zzzzz
 N SPEC
 D BLDIDX("ATTRERR","attr",.SPEC)
 D ASSERT(11,$D(SPEC("errors",1)))
 D ASSERT(1,SPEC("errors",1)["override")
 Q
BLDTLT(TAG,SPEC) ;; return SPEC for template
 N I,X,LINES,CLTN
 S I=0 F  S I=I+1,X=$P($T(@TAG+I),";;",2,99) Q:X="zzzzz"  S LINES(I)=X
 D BLDSPEC^VPRJCD("template",.LINES,.SPEC,.CLTN)
 Q
TLT1 ;; @TEST building template with instance
 ;;dose
 ;;  collections: med
 ;;  directives: include, applyOnSave
 ;;  fields: uid, qualifiedName, dose=dosages[#].dose, start=dosages[#].start, stop=dosages[#].stop
 ;;zzzzz
 N TLT
 D BLDTLT("TLT1",.TLT)
 D ASSERT(0,$D(TLT("errors")))
 D ASSERT("S",TLT("dose","collection","med",0,"applyOn"))
 D ASSERT(0,TLT("dose","collection","med",0,"exclude"))
 D ASSERT("dosages",TLT("dose","collection","med","start","srcArrayPath"))
 D ASSERT("TARGET(""stop"")",TLT("dose","collection","med","stop","tgtRef"))
 D ASSERT(0,TLT("dose","collection","med","stop","srcArrays",1,"dir"))
 Q
TLT2 ;; @TEST building template with erroneous list assignment
 ;;dose
 ;;  collections: med
 ;;  directives: include, applyOnSave
 ;;  fields: uid, dose=dosages[].dose
 ;;zzzzz
 N TLT
 D BLDTLT("TLT2",.TLT)
 D ASSERT(11,$D(TLT("errors","errors")))
 Q
TLT3 ;; @TEST building template with complex field names
 ;;test
 ;;  collections: testa, testb
 ;;  directives: include, applyOnQuery
 ;;  fields: uid, top.y=a.b[#].c.d, list[].y=a[].b.c, q.r.s[].t.v=a[].b, tree[].*=g[].*
 ;;  fields.testb: top.y=w
 ;;zzzzz
 N TLT
 D BLDTLT("TLT3",.TLT)
 D ASSERT(0,$D(TLT("errors")))
 D ASSERT(0,TLT("test","collection","testa","uid","assign"))
 D ASSERT(99,TLT("test","collection","testa","q.r.s[].t.v","assign"))
 D ASSERT("TARGET(""q"",""r"",""s"",J,""t"",""v"")",TLT("test","collection","testa","q.r.s[].t.v","tgtRef"))
 D ASSERT(21,TLT("test","collection","testa","tree[]","assign"))
 D ASSERT("TARGET(""tree"",J)",TLT("test","collection","testa","tree[]","tgtRef"))
 D ASSERT(0,TLT("test","collection","testa","top.y","srcArrays",1,"dir"))
 D ASSERT("OBJECT(""a"",""b"",I(1),""c"",""d"")",TLT("test","collection","testa","top.y","srcRef"))
 D ASSERT("OBJECT(""w"")",TLT("test","collection","testb","top.y","srcRef"))
 Q
TLT4 ;; @TEST building template with complex field names
 ;;test
 ;;  collections: testa
 ;;  directives: include, applyOnQuery
 ;;  fields: uid, top[].y=a.b[].c.d, a[].b=q.r.s[].t.v, list[]=g[].h.j[].k[].m
 ;;  fields.testb: top.y=w
 ;;zzzzz
 N TLT
 D BLDTLT("TLT4",.TLT)
 D ASSERT(0,$D(TLT("errors")))
 D ASSERT("OBJECT(""a"",""b"",I(1),""c"",""d"")",TLT("test","collection","testa","top[].y","srcRef"))
 D ASSERT("TARGET(""top"",J,""y"")",TLT("test","collection","testa","top[].y","tgtRef"))
 D ASSERT("OBJECT(""q"",""r"",""s"",I(1),""t"",""v"")",TLT("test","collection","testa","a[].b","srcRef"))
 D ASSERT("TARGET(""a"",J,""b"")",TLT("test","collection","testa","a[].b","tgtRef"))
 D ASSERT("OBJECT(""g"",I(1),""h"",""j"",I(2),""k"",I(3),""m"")",TLT("test","collection","testa","list[]","srcRef"))
 D ASSERT("TARGET(""list"",J)",TLT("test","collection","testa","list[]","tgtRef"))
 Q
TLT5 ;; @TEST building template with instances
 ;;test
 ;;  collections: testa
 ;;  directives: include, applyOnQuery
 ;;  fields: x=dosages[#].dose, y=dosages[#].units, a[#].b[#].c[#].d, z=q[#].r[#].s[#], list[]=dosages[].mult[#].fld
 ;;zzzzz
 N TLT
 D BLDTLT("TLT5",.TLT)
 D ASSERT(0,$D(TLT("errors")))
 ;W ! ZW TLT
 Q

VPRJUCD1^INT^1^63396;54290^0
VPRJUCD1 ;SLC/KCM -- Unit tests for building templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
GETPTRN ;; @TEST parse pattern for a field
 D ASSERT("N",$$GETPTRN^VPRJCD1("top"))
 D ASSERT("AN",$$GETPTRN^VPRJCD1("top[].fld"))
 D ASSERT("AAN",$$GETPTRN^VPRJCD1("top[].next[].fld"))
 D ASSERT("AA",$$GETPTRN^VPRJCD1("top[].next[]"))
 D ASSERT("#N",$$GETPTRN^VPRJCD1("top[#].fld"))
 D ASSERT("*N",$$GETPTRN^VPRJCD1("top[*].fld"))
 D ASSERT("NM",$$GETPTRN^VPRJCD1("top.*"))
 D ASSERT("AM",$$GETPTRN^VPRJCD1("top[].*"))
 D ASSERT("NNN",$$GETPTRN^VPRJCD1("top.next.fld"))
 D ASSERT("*N",$$GETPTRN^VPRJCD1("top[* / ].fld"))
 D ASSERT("?N",$$GETPTRN^VPRJCD1("top[junk].fld"))
 D ASSERT("AN",$$GETPTRN^VPRJCD1("dosages[3].dose"))
 D ASSERT("AN",$$GETPTRN^VPRJCD1("dosages[-2].dose"))
 D ASSERT("AM",$$GETPTRN^VPRJCD1("a[-3].*"))
 D ASSERT("A",$$GETPTRN^VPRJCD1("x[]"))
 Q
GETMTHD ;; @TEST calculate assignment method
 D ASSERT(0,$$GETMTHD^VPRJCD1("src","dest"))
 D ASSERT(1,$$GETMTHD^VPRJCD1("src[].fld","dest[].val"))
 D ASSERT(2,$$GETMTHD^VPRJCD1("organism[].antibiotic[].value","dest[].sub[].val"))
 D ASSERT(10,$$GETMTHD^VPRJCD1("src[#].fld","dest"))
 D ASSERT(11,$$GETMTHD^VPRJCD1("src[#].fld","dest[].val"))
 D ASSERT(12,$$GETMTHD^VPRJCD1("src[#].*","dest"))
 D ASSERT(12,$$GETMTHD^VPRJCD1("src[#].*","dest.*"))
 D ASSERT(20,$$GETMTHD^VPRJCD1("src.*","dest"))
 D ASSERT(20,$$GETMTHD^VPRJCD1("src.*","dest.*"))
 D ASSERT(21,$$GETMTHD^VPRJCD1("src[].*","dest[]"))
 D ASSERT(21,$$GETMTHD^VPRJCD1("src[].*","dest[].*"))
 D ASSERT(22,$$GETMTHD^VPRJCD1("src[].sub[].*","dest[].other[]"))
 D ASSERT(50,$$GETMTHD^VPRJCD1("src[* / ].fld","dest"))
 D ASSERT(50,$$GETMTHD^VPRJCD1("src[*].fld","dest"))
 D ASSERT(99,$$GETMTHD^VPRJCD1("src.sub.fld","dest.other.val"))
 Q
COMBINE ;; TEST computation of combining fields
 N USED
 D ASSERT(1,$$COMBINE^VPRJCD1("one",.USED))
 D ASSERT(1,$$COMBINE^VPRJCD1("one.two.three",.USED))
 D ASSERT(1,$$COMBINE^VPRJCD1("one.two",.USED))
 D ASSERT(2,$$COMBINE^VPRJCD1("one.two.five",.USED))
 Q
TLTSPEC ;; @TEST build template information
 N CTNS,FLDS,ATTR,SPEC,ERRORS
 S CTNS("utest")=""
 S ATTR("metatype")="template",ATTR("name")="utest-template"
 S FLDS(0,"uid")="uid"
 S FLDS(0,"dose")="dose=dosages[#].dose"
 S FLDS(0,"fills")="fills=fills[* / ].fillDate"
 S FLDS("utest","qualifiedName")="qualifiedName"
 S FLDS("utest","products")="products[]=drugs[].*"
 D TLTSPEC^VPRJCD1(.CTNS,.FLDS,.ATTR,.SPEC)
 D ASSERT(0,$D(ERRORS))
 D ASSERT(10,SPEC("collection","utest","dose","assign"))
 D ASSERT("dose",SPEC("collection","utest","dose","srcPath",2))
 D ASSERT(50,SPEC("collection","utest","fills","assign"))
 D ASSERT(" / ",SPEC("collection","utest","fills","srcArrays",1,"collect"))
 D ASSERT("TARGET(""fills"")",SPEC("collection","utest","fills","tgtRef"))
 D ASSERT(0,SPEC("collection","utest","fills","addType"))
 D ASSERT(1,SPEC("collection","utest","products","addType"))
 D ASSERT(21,SPEC("collection","utest","products","assign"))
 D ASSERT("drugs",SPEC("collection","utest","products","srcPath",1))
 D ASSERT("products",SPEC("collection","utest","products","tgtPath",1))
 D ASSERT("OBJECT(""drugs"",I(1))",SPEC("collection","utest","products","srcRef"))
 D ASSERT("TARGET(""products"",J)",SPEC("collection","utest","products","tgtRef"))
 D ASSERT(0,SPEC("collection","utest","qualifiedName","assign"))
 D ASSERT("qualifiedName",SPEC("collection","utest","qualifiedName","srcPath"))
 D ASSERT("qualifiedName",SPEC("collection","utest","qualifiedName","tgtPath"))
 D ASSERT(0,+$G(SPEC("collection","utest","uid","tgtArrays")))
 Q
CHKCODE(SRC,TGT,CODE,DIR,MAX,DELIM) ; build SPEC and check assign code
 N CTNS,ATTR,FLDS,SPEC,ERRORS
 S CTNS("utest")="",ATTR("metatype")="template",ATTR("name")="utest-tlt"
 S FLDS(0,TGT)=TGT_"="_SRC
 D TLTSPEC^VPRJCD1(.CTNS,.FLDS,.ATTR,.SPEC)
 D ASSERT(0,$D(ERRORS))
 D ASSERT(CODE,SPEC("collection","utest",TGT,"assign"))
 D ASSERT(DIR,$G(SPEC("collection","utest",TGT,"srcArrays",1,"dir")))
 D ASSERT(MAX,$G(SPEC("collection","utest",TGT,"srcArrays",1,"max")))
 D ASSERT(DELIM,$G(SPEC("collection","utest",TGT,"srcArrays",1,"collect")))
 Q
TLTASSGN ;; @TEST assignment types for fields
 ;B  D CHKCODE("a[].b.c[#].d","x[].y",99,0,999999,"")
 D CHKCODE("overallStart","start",0,"","","")
 D CHKCODE("dosages[#].dose","dose",10,0,1,"")
 D CHKCODE("dosages[1].dose","dose",99,1,1,"")
 D CHKCODE("dosages[-1].dose","dose",99,-1,1,"")
 D CHKCODE("dosages[*].dose","dose",50,1,999999,",")
 D CHKCODE("dosages[].dose","mydoses[].dose",1,1,999999,"")
 D CHKCODE("dosages[3].dose","initial[].dose",1,1,3,"")
 D CHKCODE("dosages[-2].dose","recent[].dose",1,-1,2,"")
 D CHKCODE("dosages[].*","mylist[].*",21,1,999999,"")
 D CHKCODE("dosages[3].*","mylist[].*",21,1,3,"")
 D CHKCODE("a.*","x.*",20,"","","")
 D CHKCODE("dosages[#].*","x",12,0,1,"")
 D CHKCODE("dosages[1].*","x",99,1,1,"")
 D CHKCODE("a.b.dosages[#].dose","x",99,0,1,"")
 D CHKCODE("a.b.c[#].d","x[].y",99,0,1,"")
 Q
CHKERR(SRC,TGT) ; build SPEC and check erroneous assignments
 N CTNS,ATTR,FLDS,SPEC,ERRORS
 S CTNS("utest")="",ATTR("metatype")="template",ATTR("name")="utest-tlt"
 S FLDS(0,TGT)=TGT_"="_SRC
 D TLTSPEC^VPRJCD1(.CTNS,.FLDS,.ATTR,.SPEC)
 D ASSERT(11,$D(ERRORS))
 Q
TLTERRS ;; @TEST assignments with errors
 D CHKERR("dosages[-2].dose","dose")   ; list to value not ok
 D CHKERR("a[].b[].c","w[].x[].y[].z") ; target has too many arrays
 D CHKERR("a[*/].b[].*","x[].*")       ; can't collect and merge
 Q
LINKSPEC ;; @TEST build link information
 N LINK,CTNS,FIELDS,ATTR
 S CTNS("test")=""
 S ATTR("rev")="testItems",ATTR("metatype")="link",ATTR("name")="link-test"
 S FIELDS(0,1)="items[].obj>items[].sub[].uid;summary"
 D LINKSPEC^VPRJCD1(.CTNS,.FIELDS,.ATTR,.LINK)
 D ASSERT(2,LINK("collection","test",1,1,"srcMethod"))
 D ASSERT(99,LINK("collection","test",1,"tgtMethod"))
 D ASSERT("testItems",LINK("common","rev"))
 D ASSERT("summary",LINK("collection","test",1,1,"srcTemplate"))
 D ASSERT("OBJECT(""items"",I(1),""sub"",I(2))",LINK("collection","test",1,1,"srcArrays",2,"ref"))
 D ASSERT("TARGET(""items"",J,""obj"")",LINK("collection","test",1,"tgtRef"))
 D ASSERT("VALS(1,I(1),I(2))",LINK("collection","test",1,"valRef"))
 Q

VPRJUCF^INT^1^63294;58829^0
VPRJUCF ;SLC/KCM -- Unit tests for filter parameter
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
ERRPARS ;; @TEST erroneous input
 N CLAUSES,HTTPERR
 D PARSE^VPRJCF("eq(statusName,""ACTIVE",.CLAUSES) ; missing close quote
 D ASSERT(1,$D(HTTPERR))
 Q
FLDTYP ;; @TEST filter with various field types
 ;;eq("summary", 1) eq(facility.name, 2) eq("products[].ingredient", 3) eq("products[].ingredient.name", 4) eq(noquote, 0)
 ;;NOTE: fields with [] must be quoted
 N FILTER,CLAUSES
 S FILTER=$P($T(FLDTYP+1),";;",2,99)
 D PARSE^VPRJCF(FILTER,.CLAUSES)
 D ASSERT(1,CLAUSES(1,"type"))
 D ASSERT(2,CLAUSES(2,"type"))
 D ASSERT(3,CLAUSES(3,"type"))
 D ASSERT(4,CLAUSES(4,"type"))
 D ASSERT("summary",CLAUSES(1,"field"))
 D ASSERT("ingredient",CLAUSES(3,"field"))
 D ASSERT("products",CLAUSES(4,"mult"))
 D ASSERT("name",CLAUSES(4,"sub"))
 Q
CONJ ;; @TEST nested conjunctions
 ;;or( eq(tobe, 1) eq(notobe, 2) and(eq(unrelated, 3), eq(another, 4)))
 ;;eq(status,7) gt(observed,"2011") in("products[].code",[20,30,40]) or(eq(a,7) eq(b,8) lt(c,500)) and(eq(w,200) gt(x,7) eq(z,50)) eq(milk,"fresh") and(eq(h,1) eq(j,2))
 N FILTER,CLAUSES
 S FILTER=$P($T(CONJ+1),";;",2,99)
 D PARSE^VPRJCF(FILTER,.CLAUSES)
 D ASSERT(0,$D(HTTPERR))
 D ASSERT("tobe",CLAUSES(1,2,"field"))
 D ASSERT("and",CLAUSES(1,4))
 D ASSERT("another",CLAUSES(1,4,2,"field"))
 K CLAUSES
 S FILTER=$P($T(CONJ+2),";;",2,99)
 D PARSE^VPRJCF(FILTER,.CLAUSES)
 D ASSERT(0,$D(HTTPERR))
 D ASSERT(1,$D(CLAUSES(2,"asString")))
 Q
VALUES ;; @TEST types of values
 ;; eq(astr, "this is a string") gt(anum, 123) in(alist, ["alpha","beta","gamma"]) eq(funnyStr, "123")
 N FILTER,CLAUSES
 S FILTER=$P($T(VALUES+1),";;",2,99)
 D PARSE^VPRJCF(FILTER,.CLAUSES)
 D ASSERT("this is a string",CLAUSES(2,"value"))
 D ASSERT(123,+CLAUSES(3,"value"))
 D ASSERT(1,$D(CLAUSES(4,"list","gamma")))
 D ASSERT(1,$D(CLAUSES(5,"asString")))
 Q
MAKEPAT ;; @TEST converting SQL Like statements into M patterns
 N X,TV ; TV = test value -- to get around XINDEX problem
 S X=$$MAKEPAT^VPRJCF("%ing")
 D ASSERT(".E1""ing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(1,TV?@X)
 S X=$$MAKEPAT^VPRJCF("re%ing")
 D ASSERT("1""re"".E1""ing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJCF("re%")
 D ASSERT("1""re"".E",X)
 S X=$$MAKEPAT^VPRJCF("%ING")
 D ASSERT(".E1""ING""",X)
 S TV="reindexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJCF("RE%")
 D ASSERT("1""RE"".E",X)
 S X=$$MAKEPAT^VPRJCF("%ING",1)
 D ASSERT(".E1""ing""",X)
 S X=$$MAKEPAT^VPRJCF("RE%",1)
 D ASSERT("1""re"".E",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 S X=$$MAKEPAT^VPRJCF("%")
 D ASSERT(".E",X)
 S X=$$MAKEPAT^VPRJCF("REINDEXING",1)
 D ASSERT("1""reindexing""",X)
 S TV="reindexing" D ASSERT(1,TV?@X)
 S TV="indexing" D ASSERT(0,TV?@X)
 Q

VPRJUCR^INT^1^63294;58829^0
VPRJUCR ;SLC/KCM -- Unit tests for range parameter parsing
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
ADJNUM   ;; @TEST incrementing and decrementing numbers
 ; use CHKTF, CHKEQ, FAIL, CHKLEAKS to test calls
 N X
 S X=$$ADJNUM^VPRJCR(100)       D ASSERT(101,X)
 S X=$$ADJNUM^VPRJCR(1.009)     D ASSERT(1.01,X)
 S X=$$ADJNUM^VPRJCR(1.001,"-") D ASSERT(1,X)
 S X=$$ADJNUM^VPRJCR(100,"-")   D ASSERT(99,X)
 Q
ADJSTR   ;; @TEST bumping strings up and down in collation
 N X
 S X=$$ADJSTR^VPRJCR("SMILE","-") D ASSERT("SMILD"_$C(255),X)
 S X=$$ADJSTR^VPRJCR("SMI")       D ASSERT("SMI"_$C(255),X)
 Q
TESTRNG(RANGE,START,STOP,CLTN) ; procedure to test RNG2VAL^VPRJCR
 N RANGES
 D XRANGES^VPRJCR(RANGE,.RANGES)               ; extract the range into RANGES(1)
 D RNG2VAL^VPRJCR(.RANGES,1,.START,.STOP,CLTN) ; now get the start/stop info
 Q
RNG2VAL  ;; @TEST converting ranges to START, STOP
 N START,STOP,MAXC
 S MAXC=$C(255)
 ;
 ; default is include endpoints and assume each is "starts with"
 D TESTRNG("201209191045..201210200620",.START,.STOP,"T")
 D ASSERT("201209191045",START),ASSERT("201210200620 ",STOP)
 ; (start:stop) gets the values between start and stop (exclude endpoints)
 D TESTRNG("]201209191045..201210200620[",.START,.STOP,"T")
 D ASSERT("201209191045 ",START),ASSERT("201210200620",STOP)
 ; [start:stop] changes start/stop so that $O will include endpoints
 D TESTRNG("[201209191045..201210200620]",.START,.STOP,"T")
 D ASSERT("201209191045",START),ASSERT("201210200620 ",STOP)
 D TESTRNG("20121101",.START,.STOP,"T")
 D ASSERT("20121101",START),ASSERT("20121101 ",STOP)
 D TESTRNG("201211011045",.START,.STOP,"T")
 D ASSERT("201211011045",START),ASSERT("201211011045 ",STOP)
 ;
 D TESTRNG("ACETAMINOPHEN..ASPIRIN",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN",START),ASSERT("ASPIRIN ",STOP)
 D TESTRNG("]ACETAMINOPHEN..ASPIRIN[",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN ",START),ASSERT("ASPIRIN",STOP)
 D TESTRNG("[ACETAMINOPHEN..ASPIRIN]",.START,.STOP,"S")
 D ASSERT("ACETAMINOPHEN",START),ASSERT("ASPIRIN ",STOP)
 ;
 D TESTRNG("ASPIRIN*",.START,.STOP,"S")
 D ASSERT("ASPIRIN",START),ASSERT("ASPIRIN"_MAXC,STOP)
 D TESTRNG("ASP*",.START,.STOP,"S")
 D ASSERT("ASP",START),ASSERT("ASP"_MAXC,STOP)
 ;
 D TESTRNG("10..20",.START,.STOP,"N")
 D ASSERT(9,START),ASSERT(20,STOP)
 D TESTRNG("[10..20]",.START,.STOP,"N")
 D ASSERT(9,START),ASSERT(20,STOP)
 D TESTRNG("]1.001..3.1416[",.START,.STOP,"N")
 D ASSERT(1.001,START),ASSERT(3.1415,STOP)
 D TESTRNG("[1.001..3.1416]",.START,.STOP,"N")
 D ASSERT(1,START),ASSERT(3.1416,STOP)
 Q
RNG2VAL2 ;; @TEST convert range to start, stop (2nd edition)
 ;; -- string collation, space appended to each entry in index
 ;;SMILE       "SMILE"   Q:X]"SMILE "   []  equals SMILE
 ;;[SMILE]     "SMILE"   Q:X]"SMILE "   []  equals SMILE
 ;;SMI..SOR    "SMI"     Q:X]"SOR "     []  startswith SMI thru startswith SOR
 ;;[SMI..SOR]  "SMI"     Q:X]"SOR "     []  SMI thru SOR (not startswith) 
 ;;]SMI..SOR[  "SMI "    Q:X]"SOR"      ()  SMI thru SOR excluding SMI and SOR
 ;;SMI*        "SMI"     Q:X]"SMI"      [*  startswith SMI
 ;;]SMI*       "SMI "    Q:X]"SMI"      (*  startswith SMI, excluding SMI itself
 ;; 
 ;; -- time collation, space appended to each entry in index
 ;;20121101..20121117    "20121101"       Q:X]"20121117 "      []
 ;;20121101              "20121101"       Q:X]"20121101 "      []
 ;;[20121101..20121117]  "20121101"       Q:X]"20121117 "      []
 ;;]20121101..20121117[  "20121101 "      Q:X]"20121117"       ()
 ;;201211011045          "201211011045"   Q:X]"201211011045 "  []
 ;;201211*               "201211"         Q:X]"201211"         [*
 ;;]201211*              "201211 "        Q:X]"201211"         (*
 ;;
 ;; -- inverse time collation, number inverted and space appended
 ;;20121101..20121117    "79878882:"      Q:X]"79878898="      []
 ;;20121101              "79878898:"      Q:X]"79878898="      []
 ;;[20121101..20121117]  "79878882:"      Q:X]"79878898="      []
 ;;]20121101..20121117[  "79878882="      Q:X]"79878898:"      ()
 ;;201211011045          "798788988954:"  Q:X]"798788988954="  []
 ;;201211*               "798788 "        Q:X]"798788="        [*
 ;;]201211*              "798788 "        Q:X]"798788:"        (*
 ;;
 ;; -- numeric collation, each entry in index is "plused"
 ;;123456.654321..65432.789    123456.654320   Q:X>65432.789   []
 ;;[123456.654321..65432.789]  123456.654320   Q:X>65432.789   []
 ;;]123456.654321..65432.789[  123456.654321   Q:X>65432.788   ()
 ;
 N START,STOP,MAXC
 S MAXC=$C(255)
 D TESTRNG("SMILE",.START,.STOP,"S")      D ASSERT("SMILE",START) D ASSERT("SMILE ",STOP)
 D TESTRNG("[SMILE]",.START,.STOP,"S")    D ASSERT("SMILE",START) D ASSERT("SMILE ",STOP)
 D TESTRNG("SMI..SOR",.START,.STOP,"S")   D ASSERT("SMI",START)   D ASSERT("SOR ",STOP)
 D TESTRNG("[SMI..SOR]",.START,.STOP,"S") D ASSERT("SMI",START)   D ASSERT("SOR ",STOP)
 D TESTRNG("]SMI..SOR[",.START,.STOP,"S") D ASSERT("SMI ",START)  D ASSERT("SOR",STOP)
 D TESTRNG("SMI*",.START,.STOP,"S")       D ASSERT("SMI",START)   D ASSERT("SMI"_MAXC,STOP)
 D TESTRNG("]SMI*",.START,STOP,"S")       D ASSERT("SMI ",START)  D ASSERT("SMI"_MAXC,STOP)
 ;
 D TESTRNG("20121101..20121117",.START,.STOP,"T")   D ASSERT("20121101",START)     D ASSERT("20121117 ",STOP)
 D TESTRNG("20121101",.START,.STOP,"T")             D ASSERT("20121101",START)     D ASSERT("20121101 ",STOP)
 D TESTRNG("[20121101..20121117]",.START,.STOP,"T") D ASSERT("20121101",START)     D ASSERT("20121117 ",STOP)
 D TESTRNG("]20121101..20121117[",.START,.STOP,"T") D ASSERT("20121101 ",START)    D ASSERT("20121117",STOP)
 D TESTRNG("201211011045",.START,.STOP,"T")         D ASSERT("201211011045",START) D ASSERT("201211011045 ",STOP)
 D TESTRNG("201211*",.START,.STOP,"T")              D ASSERT("201211",START)       D ASSERT("201211"_MAXC,STOP)
 D TESTRNG("]201211*",.START,.STOP,"T")             D ASSERT("201211 ",START)      D ASSERT("201211"_MAXC,STOP)
 ;
 D TESTRNG("20121101..20121117",.START,.STOP,"V")   D ASSERT("79878882:",START)     D ASSERT("79878898=",STOP)
 D TESTRNG("20121101",.START,.STOP,"V")             D ASSERT("79878898:",START)     D ASSERT("79878898=",STOP)
 D TESTRNG("[20121101..20121117]",.START,.STOP,"V") D ASSERT("79878882:",START)     D ASSERT("79878898=",STOP)
 D TESTRNG("]20121101..20121117[",.START,.STOP,"V") D ASSERT("79878882=",START)     D ASSERT("79878898:",STOP)
 D TESTRNG("201211011045",.START,.STOP,"V")         D ASSERT("798788988954:",START) D ASSERT("798788988954=",STOP)
 D TESTRNG("201211*",.START,.STOP,"V")              D ASSERT("798788 ",START)       D ASSERT("798788=",STOP)
 D TESTRNG("]201211*",.START,.STOP,"V")             D ASSERT("798788 ",START)       D ASSERT("798788:",STOP)
 ;
 D TESTRNG("12345.654321..65432.789",.START,.STOP,"N")   D ASSERT(12345.65432,START)  D ASSERT(65432.789,STOP)
 D TESTRNG("[12345.654321..65432.789]",.START,.STOP,"N") D ASSERT(12345.65432,START)  D ASSERT(65432.789,STOP)
 D TESTRNG("]12345.654321..65432.789[",.START,.STOP,"N") D ASSERT(12345.654321,START) D ASSERT(65432.788,STOP)
 ;
 D TESTRNG("2014..1999",.START,.STOP,"T") D ASSERT("1999",START) D ASSERT("2014 ",STOP)
 Q
QUOTES ;; @TEST ranges with quotes in them
 ;;"DOE,JOHN".."WELBY,MARCUS"
 ;;'JOHN''S CAR'*
 ;;"JOHN'S CAR"*
 ;;"666"*
 ;;20121101..20121117>3.4..7.9>"AARDVARK,ARTHUR".."RATBURN,RICHARD">'ARTHUR''S DOG'
 N RANGE,INDEX,START,STOP,DIR
 S INDEX("levels")=1,INDEX("collate",1)="s"
 S RANGE=$P($T(QUOTES+1),";;",2,99)
 D PARSERNG^VPRJCR
 D ASSERT("doe,john",START(1)),ASSERT("welby,marcus ",STOP(1))
 S RANGE=$P($T(QUOTES+2),";;",2,99)
 D PARSERNG^VPRJCR
 D ASSERT("john's car",START(1)),ASSERT("john's car"_$C(255),STOP(1))
 S RANGE=$P($T(QUOTES+3),";;",2,99)
 D PARSERNG^VPRJCR
 D ASSERT("john's car",START(1)),ASSERT("john's car"_$C(255),STOP(1))
 S RANGE=$P($T(QUOTES+4),";;",2,99)
 D PARSERNG^VPRJCR
 D ASSERT("665"_$C(255),START(1)),ASSERT("666"_$C(255),STOP(1))
 S INDEX("levels")=4
 S INDEX("collate",1)="T",INDEX("collate",2)="N",INDEX("collate",3)="s",INDEX("collate",4)="s"
 S RANGE=$P($T(QUOTES+5),";;",2,99)
 D PARSERNG^VPRJCR
 D ASSERT("20121101",START(1)),ASSERT("20121117 ",STOP(1))
 D ASSERT(3.3,START(2)),ASSERT(7.9,STOP(2))
 D ASSERT("aardvark,arthur",START(3)),ASSERT("ratburn,richard ",STOP(3))
 D ASSERT("arthur's dog",START(4)),ASSERT("arthur's dog ",STOP(4))
 Q
NULLRNG ;; @TEST when no range entered
 N RANGE,INDEX,START,STOP,DIR
 S INDEX("levels")=1,INDEX("collate",1)="s",RANGE=""
 D PARSERNG^VPRJCR
 D ASSERT("",START(1)),ASSERT($C(255,255,255),STOP(1))
 Q

VPRJUCT^INT^1^63294;58829^0
VPRJUCT ;SLC/KCM -- Unit tests for templates
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 K OBJ,ERRORS
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
SETOBJ(OBJ) ; Setup object
 S OBJ("fld")="f"
 S OBJ("cfld","suba")="fs"
 S OBJ("cfld","subb","subc")="fss"
 S OBJ("mult",1,"flda")="m1f"
 S OBJ("mult",1,"fldb","subc")="m1fs"
 S OBJ("mult",1,"fldc","subd","sube")="m1fss"
 S OBJ("mult",2,"flda")="m2f"
 S OBJ("mult",2,"fldb","subc")="m2fs"
 S OBJ("mult",2,"fldc","subd","sube")="m2fss"
 S OBJ("mult",2,"mult2",1,"sflda")="m2m1f"
 S OBJ("mult",2,"mult2",1,"sfldb","subf")="m2m1fs"
 S OBJ("mult",2,"mult2",1,"sfldc","subg","subh")="m2m1fss"
 S OBJ("mult",3,"mult2",1,"sflda")="m3m1f"
 S OBJ("mult",3,"mult2",2,"sflda")="m3m2f"
 S OBJ("mult",3,"mult2",3,"sflda")="m3m3f"
 S OBJ("mult",3,"mult2",4,"sflda")="m3m4f"
 S OBJ("mult",3,"mult2",5,"sflda")="m3m5f"
 S OBJ("mult",4,"flda")="m4f"
 S OBJ("mult",5,"flda")="m5f"
 S OBJ("more",1,"ma")="ma1"
 S OBJ("more",1,"mb")="mb1"
 S OBJ("more",2,"ma")="ma2"
 Q
BLDTLT(TAG,SPEC,CLTN) ;; return SPEC for template
 N I,X,LINES,FULLSPEC,FULLCLTN,NAME
 S I=0 F  S I=I+1,X=$P($T(@TAG+I),";;",2,99) Q:X="zzzzz"  S LINES(I)=X
 D BLDSPEC^VPRJCD("template",.LINES,.FULLSPEC,.FULLCLTN)
 S NAME=$O(FULLSPEC(""))
 M SPEC=FULLSPEC(NAME,"collection",CLTN)
 Q
 ;
SVAL ;; @TEST single value assignments
 ;;template-test
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: vx=fld, vi=mult[#].flda, vf=mult[1].flda, vl=mult[-1].flda, vc=mult[*].flda
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("SVAL",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(0,TLT("vx","assign"))
 D ASSERT(10,TLT("vi","assign"))
 D ASSERT(99,TLT("vl","assign"))
 D ASSERT(50,TLT("vc","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON,"mult#2")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT("f",TOBJ("vx"))
 D ASSERT("m2f",TOBJ("vi"))
 D ASSERT("m1f",TOBJ("vf"))
 D ASSERT("m5f",TOBJ("vl"))
 D ASSERT("m1f,m2f,m4f,m5f",TOBJ("vc"))
 Q
SLST ;; @TEST list assignments
 ;;template-test
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: la[].val=mult[].flda, lf2[].val=mult[2].flda, ll2[].val=mult[-2].flda, a[].b[].c=mult[].mult2[].sflda
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("SLST",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(1,TLT("la[].val","assign"))
 D ASSERT(1,TLT("ll2[].val","assign"))
 D ASSERT(2,TLT("a[].b[].c","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON)
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT(4,$$QCNT^VPRJTX("TOBJ(""la"")"))
 D ASSERT("m1f",TOBJ("la",1,"val"))
 D ASSERT("m5f",TOBJ("la",4,"val"))
 D ASSERT(2,$$QCNT^VPRJTX("TOBJ(""lf2"")"))
 D ASSERT("m1f",TOBJ("lf2",1,"val"))
 D ASSERT(2,$$QCNT^VPRJTX("TOBJ(""ll2"")"))
 D ASSERT("m4f",TOBJ("ll2",2,"val"))
 D ASSERT(6,$$QCNT^VPRJTX("TOBJ(""a"")"))
 Q
MVAL ;; @TEST merge value assignments
 ;;template-test
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: mv=cfld.*, mi.*=mult[#].*, mf=mult[1].*, ml=mult[-1].*, a[].b=mult[#].flda
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("MVAL",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(20,TLT("mv","assign"))
 D ASSERT(12,TLT("mi","assign"))
 D ASSERT(99,TLT("mf","assign"))
 D ASSERT(11,TLT("a[].b","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON,"mult#2")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT("fss",TOBJ("mv","subb","subc"))
 D ASSERT(1,$D(TOBJ("mv","suba")))
 D ASSERT(10,$D(TOBJ("mv","subb")))
 D ASSERT("m2fs",TOBJ("mi","fldb","subc"))
 D ASSERT("m1fss",TOBJ("mf","fldc","subd","sube"))
 D ASSERT("m5f",TOBJ("ml","flda"))
 D ASSERT(1,$D(TOBJ("ml","flda")))
 D ASSERT("m2f",TOBJ("a",1,"b"))
 Q
MLST ;; @TEST merge list assignments
 ;;template-test
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: mv[]=mult[].*, mf[].*=mult[2].*, ml[]=mult[-2].*, a[].b[]=mult[].mult2[].*, d[].e[].*=mult[].mult2[].*
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("MLST",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(21,TLT("mv[]","assign"))
 D ASSERT(21,TLT("ml[]","assign"))
 D ASSERT(22,TLT("a[].b[]","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON,"mult#2")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D ASSERT("m2m1fss",TOBJ("mv",2,"mult2",1,"sfldc","subg","subh"))
 D ASSERT(9,$$QCNT^VPRJTX("TOBJ(""mf"")"))
 D ASSERT("m2fs",TOBJ("mf",2,"fldb","subc"))
 D ASSERT(2,$$QCNT^VPRJTX("TOBJ(""ml"")"))
 D ASSERT("m4f",TOBJ("ml",2,"flda"))
 D ASSERT("m2m1fss",TOBJ("a",1,"b",1,"sfldc","subg","subh"))
 D ASSERT("m3m5f",TOBJ("a",2,"b",5,"sflda"))
 D ASSERT("m2m1fss",TOBJ("d",1,"e",1,"sfldc","subg","subh"))
 D ASSERT(1,$$QCNT^VPRJTX("TOBJ(""a"")")=$$QCNT^VPRJTX("TOBJ(""d"")"))
 Q
C99 ;; @TEST assignments on complex object references
 ;;template-test
 ;;  collections: test
 ;;  directives: include, applyOnSave
 ;;  fields: myval=cfld.subb.subc, l[].v=mult[#].mult2[].sflda, a[].v=mult[].mult2[].sflda
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("C99",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(99,TLT("myval","assign"))
 D ASSERT(99,TLT("l[].v","assign"))
 D ASSERT(99,TLT("a[].v","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON,"mult#2")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT(0,$D(TEMPLATE("errors")))
 D ASSERT("fss",TOBJ("myval"))
 D ASSERT("m2m1f",TOBJ("l",1,"v"))
 D ASSERT(6,$$QCNT^VPRJTX("TOBJ(""a"")"))
 D ASSERT("m2m1f",TOBJ("a",1,"v"))
 D ASSERT("m3m5f",TOBJ("a",6,"v"))
 K JSON,TOBJ
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON,"mult#3")
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT(5,$$QCNT^VPRJTX("TOBJ(""l"")"))
 D ASSERT("m3m1f",TOBJ("l",1,"v"))
 D ASSERT("m3m5f",TOBJ("l",5,"v"))
 Q
DEL ;; @TEST excluding fields
 ;;template-test
 ;;  collections: test
 ;;  directives: exclude, applyOnSave
 ;;  fields: cfld.subb.subc, mult[].mult2, fld, more[].*
 ;;zzzzz
 N TLT,JSON,OBJ,TOBJ
 D BLDTLT("DEL",.TLT,"test"),SETOBJ(.OBJ)
 D ASSERT(1,$D(OBJ("fld")))
 D ASSERT(1,$D(OBJ("cfld","subb","subc")))
 D ASSERT(10,$D(OBJ("mult",2,"mult2")))
 D ASSERT(10,$D(OBJ("more")))
 D ASSERT(80,TLT("fld","assign"))
 D ASSERT(80,TLT("more[]","assign"))
 D APPLY^VPRJCT(.TLT,.OBJ,.JSON)
 D ASSERT(0,$D(TEMPLATE("errors")))
 D DECODE^VPRJSON("JSON","TOBJ")
 D ASSERT(0,$D(TOBJ("fld")))
 D ASSERT(0,$D(TOBJ("cfld","subb","subc")))
 D ASSERT(0,$D(TOBJ("mult",2,"mult2")))
 D ASSERT(0,$D(TOBJ("more")))
 D ASSERT("fs",TOBJ("cfld","suba"))
 D ASSERT("m2f",TOBJ("mult",2,"flda"))
 Q

VPRJUCU^INT^1^63294;58829^0
VPRJUCU ;SLC/KCM -- Unit tests for common utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
SPACES ;; @TEST returning spaces piece
 D ASSERT("DEF",$$SPC^VPRJCU("ABC   DEF HIJ",2))
 D ASSERT("HIJ",$$SPC^VPRJCU("ABC   DEF HIJ",3))
 D ASSERT("ABC",$$SPC^VPRJCU("ABC   DEF HIJ"))
 Q
SPLIT ;; @TEST split function
 N LST D SPLIT^VPRJCU("one",.LST) D ASSERT(1,$$QCNT^VPRJTX("LST"))
 K LST D SPLIT^VPRJCU("1,2,3,4",.LST) D ASSERT(4,$$QCNT^VPRJTX("LST"))
 K LST D SPLIT^VPRJCU("1,2,3,",.LST) D ASSERT(3,$$QCNT^VPRJTX("LST"))
 K LST D SPLIT^VPRJCU("one/two/three",.LST,"/") D ASSERT(3,$$QCNT^VPRJTX("LST"))
 Q
NXTSTR ;; @TEST parsing quoted strings
 ;;"one","Hamlet said ""To be or not to be""","three"
 ;;'one','Hamlet said "To be or not to be"','three'
 N X,I,RSLT
 S X=$P($T(NXTSTR+1),";;",2,999),I=7 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D ASSERT(43,I)
 D ASSERT("Hamlet said ""To be or not to be""",RSLT)
 D ASSERT(32,$L(RSLT))
 S I=I+1 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D ASSERT("three",RSLT)
 S X=$P($T(NXTSTR+2),";;",2,999),I=7 D NXTSTR^VPRJCU(.X,.I,.RSLT,"'")
 D ASSERT("Hamlet said ""To be or not to be""",RSLT)
 D ASSERT(32,$L(RSLT))
 Q
ERRSTR ;; @TEST parsing quoted strings with errors
 ;;"this is a string without a close quote
 ;;"this is a string with the "wrong number" of quotes"
 N X,I,RSLT,HTTPERR
 S X=$P($T(ERRSTR+1),";;",2,999),I=1
 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D ASSERT(1,$D(HTTPERR))
 K HTTPERR
 S X=$P($T(ERRSTR+2),";;",2,999),I=1
 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D NXTSTR^VPRJCU(.X,.I,.RSLT)
 D ASSERT(1,$D(HTTPERR))
 D ASSERT(0,I)
 Q
NXTVAL ;; @TEST parsing until token
 ;;one..three>low,medium,high>"Doe,John".."Welby,Marcus"
 N X,I,RSLT
 S X=$P($T(NXTVAL+1),";;",2,999),I=1 D NXTVAL^VPRJCU(.X,.I,.RSLT,".,>")
 D ASSERT("one",RSLT)
 S I=6 D NXTVAL^VPRJCU(.X,.I,.RSLT,".,>")
 D ASSERT("three",RSLT)
 S I=28 d NXTVAL^VPRJCU(.X,.I,.RSLT,".,>")
 D ASSERT("""Doe",RSLT)
 D ASSERT(32,I)
 Q

VPRJUCV^INT^1^63396;54290^0
VPRJUCV ;SLC/KCM -- Unit tests for extracting values from objects
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
COLLATE ;; @TEST collation function
 N X
 S X=$$COLLATE^VPRJCV("","S")        D ASSERT(" ",X)
 S X=$$COLLATE^VPRJCV(20120919,"V")  D ASSERT("79879080=",X)
 S X=$$COLLATE^VPRJCV("ASPIRIN","S") D ASSERT("ASPIRIN ",X)
 S X=$$COLLATE^VPRJCV(3.1416,"N")    D ASSERT(3.1416,X)
 S X=$$COLLATE^VPRJCV("DIGOXIN","P") D ASSERT("DIGOXIN",X)
 Q
SETOBJ(OBJECT) ; set up a test object
 S OBJECT("top")="top value"
 S OBJECT("when")="201208121030"
 S OBJECT("how")="miracle"
 S OBJECT("mult",1,"sub")="sub1 value"
 S OBJECT("mult",2,"sub")="sub2 value"
 S OBJECT("mult",2,"provider","name")="Welby"
 S OBJECT("products",1,"drugClassCode")="urn:vadc:HS502"
 S OBJECT("ary1",4,"ary2",47,"val")="4-47"
 S OBJECT("ary1",4,"val")="4val"
 S OBJECT("ary1",5,"val")="5val"
 S OBJECT("ary1",15,"ary2",103,"val")="15-103"
 S OBJECT("ary1",15,"val")="15val"
 S OBJECT("list",1)="list 1"
 S OBJECT("list",2)="list 2"
 S OBJECT("list",3)="list 3"
 Q
BLD4TLT(OBJECT,VALUES,TAG) ; build instance values given lines of template
 N I,X,LINES,CLTN,SPEC
 S I=0 F  S I=I+1,X=$P($T(@TAG+I),";;",2,99) Q:X="zzzzz"  S LINES(I)=X
 D BLDSPEC^VPRJCD("template",.LINES,.SPEC,.CLTN)
 ;W ! ZW SPEC ZW CLTN
 ;D GETVALS^VPRJCV(.OBJECT,.VALUES,.CSPEC)
 Q
TLTVALS ;; TEST set values for templates
 ;;unit-test-instance
 ;;  collections: utesta
 ;;  directives: include, applyOnSave
 ;;  fields: uid, qualifiedName, dose=dosages[#].dose, start=dosages[#].start, stop=dosages[#].stop
 ;;zzzzz
 N OBJECT,VALUES
 D SETOBJ(.OBJECT)
 D BLD4TLT(.OBJECT,.VALUES,"TLTVALS")
 Q
BLD4IDX(OBJECT,VALUES,FIELDS) ; Build spec then set values given FIELDS
 N CLTNS,ATTR,SPEC,FULLSPEC,ERRORS,I
 S CLTNS("utesta")="",ATTR("metatype")="index",ATTR("style")="attr"
 D IDXSPEC^VPRJCD1(.CLTNS,.FIELDS,.ATTR,.FULLSPEC)
 D ASSERT(0,$D(ERRORS))
 M SPEC=FULLSPEC("collection","utesta")
 K VALUES
 D IDXVALS^VPRJCV(.OBJECT,.VALUES,.SPEC)
 Q
IDXVALS ;; @TEST set values procedure
 N OBJECT,VALUES,FIELDS
 D SETOBJ(.OBJECT)
 ;
 ;fields: top/S
 S FIELDS(0,1)="top/S"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("top value ",VALUES(1,1))
 ;fields: top/S, when/V/0
 S FIELDS(0,2)="when/V/0"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("798791878969=",VALUES(1,2))
 ;fields: mult[].sub/S, when/V/0
 S FIELDS(0,1)="mult[].sub/S"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("sub1 value ",VALUES("mult#1",1))
 D ASSERT("sub2 value ",VALUES("mult#2",1))
 D ASSERT("798791878969=",VALUES("mult#1",2))
 D ASSERT("798791878969=",VALUES("mult#2",2))
 ;fields: mult[].sub/S, when/V/0, mult[].provider.name/s
 S FIELDS(0,3)="mult[].provider.name/s"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT(0,$D(VALUES("mult#1")))
 D ASSERT("welby ",VALUES("mult#2",3))
 ;fields: mult[].sub/S, when/V/0, mult[].provider.name/s/? 
 S FIELDS(0,3)="mult[].provider.name/s/?"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("? ",VALUES("mult#1",3))
 ;fields: mult[].sub/S, gone/V/0, mult[].provider.name/s/? 
 S FIELDS(0,2)="gone/V/0"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("9=",VALUES("mult#1",2)) ; reverse time, so 0= becomes 9=
 D ASSERT("9=",VALUES("mult#2",2))
 ;fields: mult[].sub/S, gone/V/0, products[].drugClassCode/S
 S FIELDS(0,3)="products[].drugClassCode/S"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("urn:vadc:HS502 ",VALUES("mult#1|products#1",3))
 D ASSERT("urn:vadc:HS502 ",VALUES("mult#2|products#1",3))
 ;fields: top/s, how/s, when/V
 K FIELDS
 S FIELDS(0,1)="top/s",FIELDS(0,2)="how/s",FIELDS(0,3)="when/V"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("top value ",VALUES(1,1))
 D ASSERT("miracle ",VALUES(1,2))
 D ASSERT("798791878969=",VALUES(1,3))
 ; fields: mult[].sub/s
 K FIELDS
 S FIELDS(0,1)="mult[].sub/s"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 ;fields: ary1[].ary2[].val/P
 K FIELDS
 S FIELDS(0,1)="ary1[].ary2[].val/P"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("15-103",VALUES("ary1#15>ary1.ary2#103",1))
 ;fields: ary1[].ary2[].val/P, mult[].sub/s
 K FIELDS
 S FIELDS(0,1)="ary1[].ary2[].val/P"
 S FIELDS(0,2)="mult[].sub/s"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("15-103",VALUES("ary1#15>ary1.ary2#103|mult#2",1))
 D ASSERT("sub2 value ",VALUES("ary1#4>ary1.ary2#47|mult#2",2))
 D ASSERT(8,$$QCNT^VPRJTX("VALUES"))
 ;fields: list[]
 K FIELDS
 S FIELDS(0,1)="list[]"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("list 3 ",VALUES("list#3",1))
 ;fields: last4 (to test field missing from object)
 K FIELDS
 S FIELDS(0,1)="last4"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT(0,$D(VALUES))
 Q
IDXNEST ;; @TEST indexing values where there are descendent multiples
 N OBJECT,VALUES,FIELDS
 D SETOBJ(.OBJECT)
 ;
 ;fields: ary1[].val, ary1[].ary2[].val
 S FIELDS(0,1)="ary1[].val/P"
 S FIELDS(0,2)="ary1[].ary2[].val/P"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 ;W ! ZW VALUES
 Q
IDXNEST2 ;; @TEST indexing values with various ancestry paths
 N OBJECT,VALUES,FIELDS
 S OBJECT("one",1,"x")="1x"
 S OBJECT("one",1,"two",1,"y")="11y"
 S OBJECT("one",1,"two",1,"three",1,"z")="111z"
 S OBJECT("one",1,"two",1,"three",2,"z")="112z"
 S OBJECT("one",1,"two",1,"five",1,"w")="111w"
 S OBJECT("one",1,"two",2,"y")="12y"
 S OBJECT("one",2,"x")="2x"
 S OBJECT("one",2,"two",1,"y")="21y"
 S OBJECT("one",2,"two",1,"three",1,"z")="211z"
 S OBJECT("one",2,"two",1,"five",1,"w")="211w"
 S OBJECT("one",2,"two",1,"five",2,"w")="212w"
 S OBJECT("one",2,"two",2,"y")="22y"
 S OBJECT("one",2,"two",3,"y")="23y"
 S FIELDS(0,1)="one[].x/P"
 S FIELDS(0,2)="one[].two[].three[].z/P"
 S FIELDS(0,3)="one[].two[].y/P"
 S FIELDS(0,4)="one[].two[].five[].w/P"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 ;W ! ZW VALUES
 Q
SETVALM ;; @TEST set values for deeper hierarchies like microbiology
 N OBJECT,VALUES,FIELDS
 S OBJECT("test")="susceptibility"
 S OBJECT("observed")="201208121030"
 S OBJECT("organisms",1,"name")="e coli"
 S OBJECT("organisms",1,"antibiotics",1,"name")="penicillin"
 S OBJECT("organisms",1,"antibiotics",1,"resistance")="R"
 S OBJECT("organisms",1,"antibiotics",2,"name")="ampicillin"
 S OBJECT("organisms",1,"antibiotics",2,"resistance")="R"
 S OBJECT("organisms",1,"antibiotics",3,"name")="azithromycin"
 S OBJECT("organisms",1,"antibiotics",3,"resistance")="S"
 S OBJECT("organisms",2,"name")="staphylococcus"
 S OBJECT("organisms",2,"antibiotics",1,"name")="penicillin"
 S OBJECT("organisms",2,"antibiotics",1,"resistance")="R"
 S OBJECT("organisms",2,"antibiotics",2,"name")="ampicillin"
 S OBJECT("organisms",2,"antibiotics",2,"resistance")="S"
 S OBJECT("organisms",2,"antibiotics",3,"name")="azithromycin"
 S OBJECT("organisms",2,"antibiotics",3,"resistance")="S"
 S OBJECT("organisms",3,"name")="streptococcus"
 S OBJECT("organisms",3,"antibiotics",1,"name")="penicillin"
 S OBJECT("organisms",3,"antibiotics",1,"resistance")="S"
 S OBJECT("organisms",3,"antibiotics",2,"name")="ampicillin"
 S OBJECT("organisms",3,"antibiotics",2,"resistance")="S"
 S OBJECT("organisms",3,"antibiotics",3,"name")="azithromycin"
 S OBJECT("organisms",3,"antibiotics",3,"resistance")="S"
 ;
 ;fields: organisms[].antibiotics[].name/s
 S FIELDS(0,1)="organisms[].antibiotics[].name/s"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 D ASSERT("azithromycin ",VALUES("organisms#1>organisms.antibiotics#3",1))
 D ASSERT("ampicillin ",VALUES("organisms#2>organisms.antibiotics#2",1))
 D ASSERT("penicillin ",VALUES("organisms#3>organisms.antibiotics#1",1))
 Q
SUBNAME ;; @TEST set values with same subordinate array name
 ;;{"a": [{"b":{"c":[1,2,3]},"d":{"c":[7,8,9]}}]} 
 N OBJECT,VALUES,FIELDS,JSON,ERR
 S JSON=$P($T(SUBNAME+1),";;",2,99)
 D DECODE^VPRJSON("JSON","OBJECT","ERR")
 D ASSERT(0,$D(ERR))
 S FIELDS(0,1)="a[].b.c[]"
 S FIELDS(0,2)="a[].d.c[]"
 D BLD4IDX(.OBJECT,.VALUES,.FIELDS)
 ; combinations returned should be (1,7),(1,8),(1,9),(2,7),(2,8),(2,9),(3,7),(3,8),(3,9)
 D ASSERT(18,$$QCNT^VPRJTX("VALUES"))
 D ASSERT("1 ",VALUES("a#1>a.b.c#1|a#1>a.d.c#1",1))
 D ASSERT("2 ",VALUES("a#1>a.b.c#2|a#1>a.d.c#2",1))
 D ASSERT("9 ",VALUES("a#1>a.b.c#3|a#1>a.d.c#3",2))
 Q

VPRJUFPS^INT^1^63379;82385^0
VPRJUFPS ;SLC/KCM -- Unit tests for index functions
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
CWAD ;; @TEST CWAD index
 N DOC
 S DOC("documentTypeCode")="D",DOC("status")="COMPLETED"
 D ASSERT(1,$$CWAD^VPRJFPS(.DOC))
 S DOC("documentTypeCode")="D",DOC("status")="RETRACTED"
 D ASSERT(0,$$CWAD^VPRJFPS(.DOC))
 S DOC("documentTypeCode")="",DOC("status")="COMPLETED"
 D ASSERT(0,$$CWAD^VPRJFPS(.DOC))
 Q

VPRJUJ01^INT^1^63315;47129^0
VPRJUJ01 ;SLC/KCM -- Sample data for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; --- Data for multi-line tests
 ;
SPLIT ;;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
SPLITC ;;
 ;;{"uid":"urn:va:2C0A:8:task:28","summary":"tast2","facilityCode":"500","taskName":"tast2","assignToName":"SQA,ONE",
 ;;"assignToCode":"urn:va:user:2C0A:1134","ownerName":"SQA,ONE","ownerCode":"urn:va:user:2C0A:1134
 ;;","description":"test","completed":f
 ;;alse,"dueDate":"20121128","kind":"Task"}
 ;;#####
 ;
VALONLY ;;
 ;;{"uid":"urn:va:param:F484:1120:VPR USER PREF:1120","entity":"USR","entityId":"1120","param":"VPR USER PREF","instance":"1120","vals":{"ext.libver":"/lib/ext-4.0.7/ext-all-dev.js","cpe.patientpicker.loc":"north"}}
 ;
NUMERIC ;;
 ;;{"name":"Duck,Donald","hl7Time":"20120919","count":234567,"icd":"722.10"}
BADQUOTE ;;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc: "this string contains \\
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
BADSLASH ;;
 ;;{"name":"value","comments":"here comes some whitespace"     
 ;;    ,  "next"  :  "this is a new line", "wp":"this is a 
 ;;string that goes across two lines", "esc": "this string contains \
 ;;and other escaped characters such as \n  and a few tabs \t\t\t\t and
 ;; a piece of \"quoted text\"", "nextLineQuote":"here is another string
 ;;"} 
 ;;#####
 ;
PSNUM ;; Psudo-neumeric tests
 ;;{
 ;;"0.85,0.01":{"AUDIT":"TEST1","AUDIT CONDITION":"TEST2"},
 ;;"0.85,0.02":{"AUDIT":"TEST3","AUDIT CONDITION":"TEST4"},
 ;;"0.85,0.03":{"AUDIT":"TEST5","AUDIT CONDITION":"TEST6"}
 ;;}
 ;;#####
 ;
NUMLABEL ;;
 ;;{"syncStatusByVistaSystemId":{"9E99":{"patientUid":"urn:va:patient:9E99:46570:46570","dfn":"46570",
 ;;"domainExpectedTotals":{},"syncComplete":false}},"forOperational":true,  "syncOperationalComplete":false,
 ;;"uid":"urn:va:syncstatus:null",  "summary":"gov.va.cpe.vpr.sync.SyncStatus@35e797cf"}
 ;;#####
 ;
PURENUM1 ;; Label as plain number (not exponential number)
 ;;{"uid":"urn:va:syncstatus:OPD","summary":"gov.va.cpe.vpr.sync.SyncStatus@2c1cebdb","syncComplete":true,"syncStarted":true,
 ;;"forOperational":"true","syncStatusByVistaSystemId":{"1234":{"syncComplete":"true","domainExpectedTotals":{"bar":
 ;;{"total":100,"count":50}}}}}
 ;;#####
PURENUM2 ;; same as PURENUM1 but labels are in alpha order to match M subscripting
 ;;{"forOperational":"true","summary":"gov.va.cpe.vpr.sync.SyncStatus@2c1cebdb","syncComplete":true,"syncStarted":true,
 ;;"syncStatusByVistaSystemId":{"1234":{"domainExpectedTotals":{"bar":{"count":50,"total":100}},"syncComplete":"true"}},
 ;;"uid":"urn:va:syncstatus:OPD"}
 ;;#####
STRTYPES ;; strings that may be confused with other types
 ;;{"uid": "urn:va:syncstatus:OPD","syncStatusByVistaSystemId": {"1234": {"syncComplete" : "true"}}}
 ;;#####
 ;
ESTRING ;;
 ;;{"a":"influenza","b":"32E497ABC","c":0.123,"d":"0.321","e":-0.789,"f":"-0.987","g":3e22,"h":"2E8","i":1234}
 ;;#####
 ;
 ; --- SAMPLE JSON strings
 ;
SAM1 ;;
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"value": "New","onclick":"CreateNewDoc()"},
 ;;{"value": "Open","onclick": "OpenDoc()"},{"value": "Close","onclick": "CloseDoc()"}]} ,
 ;;"value":"File"}}
 ;;#####
 ;
SAM2 ;;
 ;;    {
 ;;        "glossary": {
 ;;            "title": "example glossary",
 ;;            "GlossDiv": {
 ;;                "title": "S",
 ;;                "GlossList": {
 ;;                    "GlossEntry": {
 ;;                        "ID": "SGML",
 ;;                        "SortAs": "SGML",
 ;;                        "GlossTerm": "Standard Generalized Markup Language",
 ;;                        "Acronym": "SGML",
 ;;                        "Abbrev": "ISO 8879:1986",
 ;;                        "GlossDef": {
 ;;                            "para": "A meta-markup language, used to create markup languages such as DocBook.",
 ;;                            "GlossSeeAlso": ["GML", "XML"]
 ;;                        },
 ;;                        "GlossSee": "markup"
 ;;                    }
 ;;                }
 ;;            }
 ;;        }
 ;;    }
 ;;#####
 ;    
SAM3 ;;
 ;;    {"widget": {
 ;;        "debug": "on",
 ;;        "window": {
 ;;            "title": "Sample Konfabulator Widget",
 ;;            "name": "main_window",
 ;;            "width": 500,
 ;;            "height": 500
 ;;        },
 ;;        "image": { 
 ;;            "src": "Images/Sun.png",
 ;;            "name": "sun1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 250,
 ;;            "alignment": "center"
 ;;        },
 ;;        "text": {
 ;;            "data": "Click Here",
 ;;            "size": 36,
 ;;            "style": "bold",
 ;;            "name": "text1",
 ;;            "hOffset": 250,
 ;;            "vOffset": 100,
 ;;            "alignment": "center",
 ;;            "onMouseUp": "sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;        }
 ;;    }}    
 ;;#####
 ;
SAM4 ;;
 ;;    {"web-app": {
 ;;      "servlet": [   
 ;;        {
 ;;          "servlet-name": "cofaxCDS",
 ;;          "servlet-class": "org.cofax.cds.CDSServlet",
 ;;          "init-param": {
 ;;            "configGlossary:installationAt": "Philadelphia, PA",
 ;;            "configGlossary:adminEmail": "ksm@pobox.com",
 ;;            "configGlossary:poweredBy": "Cofax",
 ;;            "configGlossary:poweredByIcon": "/images/cofax.gif",
 ;;            "configGlossary:staticPath": "/content/static",
 ;;            "templateProcessorClass": "org.cofax.WysiwygTemplate",
 ;;            "templateLoaderClass": "org.cofax.FilesTemplateLoader",
 ;;            "templatePath": "templates",
 ;;            "templateOverridePath": "",
 ;;            "defaultListTemplate": "listTemplate.htm",
 ;;            "defaultFileTemplate": "articleTemplate.htm",
 ;;            "useJSP": false,
 ;;            "jspListTemplate": "listTemplate.jsp",
 ;;            "jspFileTemplate": "articleTemplate.jsp",
 ;;            "cachePackageTagsTrack": 200,
 ;;            "cachePackageTagsStore": 200,
 ;;            "cachePackageTagsRefresh": 60,
 ;;            "cacheTemplatesTrack": 100,
 ;;            "cacheTemplatesStore": 50,
 ;;            "cacheTemplatesRefresh": 15,
 ;;            "cachePagesTrack": 200,
 ;;            "cachePagesStore": 100,
 ;;            "cachePagesRefresh": 10,
 ;;            "cachePagesDirtyRead": 10,
 ;;            "searchEngineListTemplate": "forSearchEnginesList.htm",
 ;;            "searchEngineFileTemplate": "forSearchEngines.htm",
 ;;            "searchEngineRobotsDb": "WEB-INF/robots.db",
 ;;            "useDataStore": true,
 ;;            "dataStoreClass": "org.cofax.SqlDataStore",
 ;;            "redirectionClass": "org.cofax.SqlRedirection",
 ;;            "dataStoreName": "cofax",
 ;;            "dataStoreDriver": "com.microsoft.jdbc.sqlserver.SQLServerDriver",
 ;;            "dataStoreUrl": "jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon",
 ;;            "dataStoreUser": "sa",
 ;;            "dataStorePassword": "dataStoreTestQuery",
 ;;            "dataStoreTestQuery": "SET NOCOUNT ON;select test='test';",
 ;;            "dataStoreLogFile": "/usr/local/tomcat/logs/datastore.log",
 ;;            "dataStoreInitConns": 10,
 ;;            "dataStoreMaxConns": 100,
 ;;            "dataStoreConnUsageLimit": 100,
 ;;            "dataStoreLogLevel": "debug",
 ;;            "maxUrlLength": 500}},
 ;;        {
 ;;          "servlet-name": "cofaxEmail",
 ;;          "servlet-class": "org.cofax.cds.EmailServlet",
 ;;          "init-param": {
 ;;          "mailHost": "mail1",
 ;;          "mailHostOverride": "mail2"}},
 ;;        {
 ;;          "servlet-name": "cofaxAdmin",
 ;;          "servlet-class": "org.cofax.cds.AdminServlet"},
 ;;     
 ;;        {
 ;;          "servlet-name": "fileServlet",
 ;;          "servlet-class": "org.cofax.cds.FileServlet"},
 ;;        {
 ;;          "servlet-name": "cofaxTools",
 ;;          "servlet-class": "org.cofax.cms.CofaxToolsServlet",
 ;;          "init-param": {
 ;;            "templatePath": "toolstemplates/",
 ;;            "log": 1,
 ;;            "logLocation": "/usr/local/tomcat/logs/CofaxTools.log",
 ;;            "logMaxSize": "",
 ;;            "dataLog": 1,
 ;;            "dataLogLocation": "/usr/local/tomcat/logs/dataLog.log",
 ;;            "dataLogMaxSize": "",
 ;;            "removePageCache": "/content/admin/remove?cache=pages&id=",
 ;;            "removeTemplateCache": "/content/admin/remove?cache=templates&id=",
 ;;            "fileTransferFolder": "/usr/local/tomcat/webapps/content/fileTransferFolder",
 ;;            "lookInContext": 1,
 ;;            "adminGroupID": 4,
 ;;            "betaServer": true}}],
 ;;      "servlet-mapping": {
 ;;        "cofaxCDS": "/",
 ;;        "cofaxEmail": "/cofaxutil/aemail/*",
 ;;        "cofaxAdmin": "/admin/*",
 ;;        "fileServlet": "/static/*",
 ;;        "cofaxTools": "/tools/*"},
 ;;     
 ;;      "taglib": {
 ;;        "taglib-uri": "cofax.tld",
 ;;        "taglib-location": "/WEB-INF/tlds/cofax.tld"}}}
 ;;#####
 ;
SAM5 ;;
 ;;    {"menu": {
 ;;        "header": "SVG Viewer",
 ;;        "items": [
 ;;            {"id": "Open"},
 ;;            {"id": "OpenNew", "label": "Open New"},
 ;;            null,
 ;;            {"id": "ZoomIn", "label": "Zoom In"},
 ;;            {"id": "ZoomOut", "label": "Zoom Out"},
 ;;            {"id": "OriginalView", "label": "Original View"},
 ;;            null,
 ;;            {"id": "Quality"},
 ;;            {"id": "Pause"},
 ;;            {"id": "Mute"},
 ;;            null,
 ;;            {"id": "Find", "label": "Find..."},
 ;;            {"id": "FindAgain", "label": "Find Again"},
 ;;            {"id": "Copy"},
 ;;            {"id": "CopyAgain", "label": "Copy Again"},
 ;;            {"id": "CopySVG", "label": "Copy SVG"},
 ;;            {"id": "ViewSVG", "label": "View SVG"},
 ;;            {"id": "ViewSource", "label": "View Source"},
 ;;            {"id": "SaveAs", "label": "Save As"},
 ;;            null,
 ;;            {"id": "Help"},
 ;;            {"id": "About", "label": "About Adobe CVG Viewer..."}
 ;;        ]
 ;;    }}
 ;;#####
 ;
MAXNUM ;; String that appears to be large number
 ;;{"pid":"33","taskName":"1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678903123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789041234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890512345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789012345678901234567890123456789012345678906123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567
 ;;8901234567890123456789071234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789081234567890123456
 ;;7890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890912345678901234567890123456789012345678901234567890123456
 ;;789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890","description":"this task title is well over 256 characters but they are all numeric<br>","type"
 ;;:"General","dueDate":"20130110000000.000","completed":null,"ownerName":"AVIVAUSER,FORTYTWO","ownerCode":"urn:va:user:2C0A:1136","assignToName":"AVIVAUSER,FORTYTWO","assignToCode":"urn:va:user:2C0A:1136","facilityCode":"500","facilityName":"C
 ;;AMP MASTER"}
 ;;#####
ESCQ ;; String with an escaped quote across lines
 ;;{"uid":"urn:test:47","comments":"This has a line with an escaped quote (\
 ;;") across lines."}
 ;;#####
ESCQ2 ;; String with escaped slash and escaped quote
 ;;{"uid":"urn:va:viewdefdef:F484:232","name":"A big board","bjw":"a long escaped string: [\\\"DIET\\\",\\\"MEAL\
 ;;\\"]","updated":"20130320143825"}
 ;;#####

VPRJUJ02^INT^1^63294;58829^0
VPRJUJ02 ;SLC/KCM -- Sample data for JSON encoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ;
 ; expected return data values
 ;
BASIC ;; Basic object 
 ;;{"myObj":{"array":["one","two","three"],"booleanF":false,"booleanT":true,"nullValue":null,"numeric":3.1416,"subObject":{"fieldA":"hello","fieldB":"world"}}}
VALS ;; Simple values only object
 ;;{"arr":["apple","orange","pear",{"obj":"4th array item is object"}],"bool1":true,"num1":2.1e3,"prop1":"property1"}
LONG ;; Object with continuation nodes
 ;;{"note":"This is the first line of the note.  Here are \"quotes\" and a \\ and a \/.\nAdditional Line #1, this will extend the line out to at least 78 characters.\nAdditional Line #2,
NODES ;; Nodes preformatted as JSON
 ;;{"value": "New", "onclick": "CreateNewDoc()"}
 ;;{"value": "Open", "onclick": "OpenDoc()"}
 ;;{"value": "Close", "onclick": "CloseDoc()"}
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}
PRE ;; Adding already encoded values to object
 ;;{"count":3,"menu":[{"value": "New", "onclick": "CreateNewDoc()"},{"value": "Open", "onclick": "OpenDoc()"},{"value": "Close", "onclick": "CloseDoc()"}],"template":
 ;;{"data":"Click Here","size":36,"style":"bold","name":"text1","hOffset":250,"vOffset":100,"alignment":"center","onMouseUp":"sun1.opacity = (sun1.opacity / 100) * 90;"}}
WPOUT ;; WP field encoded as JSON
 ;;{"dob":"APR 7,1935","gender":"MALE","lastVitals":{"height":{"lastDone":"Aug 24, 2009","value":190},"weight":{"lastDone":"Jul 01, 2011","value":210}},"name":"AVIVAPATIENT,THIRTY","patDemDetails":{"text":"               COORDINATING
 ;; MASTER OF RECORD: ABILENE (CAA)\r\n Address: Any Street                    Temporary: NO TEMPORARY ADDRESS\r\n         Any Town,WV 99998-0071\r\n         \r\n  County: UNSPECIFIED                     From\/To: NOT APPLICABLE\r\n"},
 ;;"uid":"urn:va:F484:8:patient:8"}
LTZERO ;; Leading and trailing zeros
 ;;{"code":".77","count":737,"errors":0,"icd":"626.00","price":0.65,"ssn":"000427930"}
STRINGS ;; strings that look like numbers
 ;;{"count":234567,"hl7Time":"20120919","icd":"722.10","name":"Duck,Donald"}
EX1OUT ;; JSON.org example #1 target
 ;;{"menu":{"id":"file","popup":{"menuitem":[{"onclick":"CreateNewDoc()","value":"New"},{"onclick":"OpenDoc()","value":"Open"},{"onclick":"CloseDoc()","value":"Close"}]},"value":"File"}}
EX2OUT ;; JSON.org example #2 target
 ;;{"glossary":{"GlossDiv":{"GlossList":{"GlossEntry":{"Abbrev":"ISO 8879:1986","Acronym":"SGML","GlossDef":{"GlossSeeAlso":["GML","XML"],"para":"A meta-markup language, used to create markup languages such as DocBook."}
 ;;,"GlossSee":"markup","GlossTerm":"Standard Generalized Markup Language","ID":"SGML","SortAs":"SGML"}},"title":"S"},"title":"example glossary"}}
EX3OUT ;; JSON.org example #3 target
 ;;{"widget":{"debug":"on","image":{"alignment":"center","hOffset":250,"name":"sun1","src":"Images\/Sun.png","vOffset":250},"text":{"alignment":"center","data":"Click Here","hOffset":250,"name":"text1","onMouseUp":
 ;;"sun1.opacity = (sun1.opacity \/ 100) * 90;","size":36,"style":"bold","vOffset":100},"window":{"height":500,"name":"main_window","title":"Sample Konfabulator Widget","width":500}}}
EX4OUT ;; JSON.org example #4 target
 ;;{"web-app":{"servlet":[{"init-param":{"cachePackageTagsRefresh":60,"cachePackageTagsStore":200,"cachePackageTagsTrack":200,"cachePagesDirtyRead":10,"cachePagesRefresh":10,"cachePagesStore":100,"cachePagesTrack":200,
 ;
 ; data values to test long text field input
 ;
WP ;; object with word processing field
 ;;Y("dob")="APR 7,1935"
 ;;Y("gender")="MALE"
 ;;Y("lastVitals","height","lastDone")="Aug 24, 2009"
 ;;Y("lastVitals","height","value")=190
 ;;Y("lastVitals","weight","lastDone")="Jul 01, 2011"
 ;;Y("lastVitals","weight","value")=210
 ;;Y("name")="AVIVAPATIENT,THIRTY"
 ;;Y("patDemDetails","text","\",6)="               COORDINATING MASTER OF RECORD: ABILENE (CAA)"_$C(13,10)
 ;;Y("patDemDetails","text","\",7)=" Address: Any Street                    Temporary: NO TEMPORARY ADDRESS"_$C(13,10)
 ;;Y("patDemDetails","text","\",8)="         Any Town,WV 99998-0071"_$C(13,10)
 ;;Y("patDemDetails","text","\",9)="         "_$C(13,10)
 ;;Y("patDemDetails","text","\",10)="  County: UNSPECIFIED                     From/To: NOT APPLICABLE"_$C(13,10)
 ;;Y("uid")="urn:va:F484:8:patient:8"
 ;;zzzzz
 ;
 ; data values for JSON.ORG examples rendered as M arrays
 ;
EX1IN ;; JSON.org example #1
 ;;Y("menu","id")="file"
 ;;Y("menu","popup","menuitem",1,"onclick")="CreateNewDoc()"
 ;;Y("menu","popup","menuitem",1,"value")="New"
 ;;Y("menu","popup","menuitem",2,"onclick")="OpenDoc()"
 ;;Y("menu","popup","menuitem",2,"value")="Open"
 ;;Y("menu","popup","menuitem",3,"onclick")="CloseDoc()"
 ;;Y("menu","popup","menuitem",3,"value")="Close"
 ;;Y("menu","value")="File"
 ;;zzzzz
EX2IN ;; JSON.org example #2
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Abbrev")="ISO 8879:1986"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","Acronym")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",1)="GML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)="XML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","para")="A meta-markup language, used to create markup languages such as DocBook."
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossSee")="markup"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","GlossTerm")="Standard Generalized Markup Language"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","ID")="SGML"
 ;;Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")="SGML"
 ;;Y("glossary","GlossDiv","title")="S"
 ;;Y("glossary","title")="example glossary"
 ;;zzzzz
EX3IN ;; JSON.org example #3
 ;;Y("widget","debug")="on"
 ;;Y("widget","image","alignment")="center"
 ;;Y("widget","image","hOffset")=250
 ;;Y("widget","image","name")="sun1"
 ;;Y("widget","image","src")="Images/Sun.png"
 ;;Y("widget","image","vOffset")=250
 ;;Y("widget","text","alignment")="center"
 ;;Y("widget","text","data")="Click Here"
 ;;Y("widget","text","hOffset")=250
 ;;Y("widget","text","name")="text1"
 ;;Y("widget","text","onMouseUp")="sun1.opacity = (sun1.opacity / 100) * 90;"
 ;;Y("widget","text","size")=36
 ;;Y("widget","text","style")="bold"
 ;;Y("widget","text","vOffset")=100
 ;;Y("widget","window","height")=500
 ;;Y("widget","window","name")="main_window"
 ;;Y("widget","window","title")="Sample Konfabulator Widget"
 ;;Y("widget","window","width")=500
 ;;zzzzz
EX4IN ;; JSON.org example #4
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsRefresh")=60
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsStore")=200
 ;;Y("web-app","servlet",1,"init-param","cachePackageTagsTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cachePagesDirtyRead")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesRefresh")=10
 ;;Y("web-app","servlet",1,"init-param","cachePagesStore")=100
 ;;Y("web-app","servlet",1,"init-param","cachePagesTrack")=200
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesRefresh")=15
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesStore")=50
 ;;Y("web-app","servlet",1,"init-param","cacheTemplatesTrack")=100
 ;;Y("web-app","servlet",1,"init-param","configGlossary:adminEmail")="ksm@pobox.com"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:installationAt")="Philadelphia, PA"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredBy")="Cofax"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:poweredByIcon")="/images/cofax.gif"
 ;;Y("web-app","servlet",1,"init-param","configGlossary:staticPath")="/content/static"
 ;;Y("web-app","servlet",1,"init-param","dataStoreClass")="org.cofax.SqlDataStore"
 ;;Y("web-app","servlet",1,"init-param","dataStoreConnUsageLimit")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreDriver")="com.microsoft.jdbc.sqlserver.SQLServerDriver"
 ;;Y("web-app","servlet",1,"init-param","dataStoreInitConns")=10
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogFile")="/usr/local/tomcat/logs/datastore.log"
 ;;Y("web-app","servlet",1,"init-param","dataStoreLogLevel")="debug"
 ;;Y("web-app","servlet",1,"init-param","dataStoreMaxConns")=100
 ;;Y("web-app","servlet",1,"init-param","dataStoreName")="cofax"
 ;;Y("web-app","servlet",1,"init-param","dataStorePassword")="dataStoreTestQuery"
 ;;Y("web-app","servlet",1,"init-param","dataStoreTestQuery")="SET NOCOUNT ON;select test='test';"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUrl")="jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon"
 ;;Y("web-app","servlet",1,"init-param","dataStoreUser")="sa"
 ;;Y("web-app","servlet",1,"init-param","defaultFileTemplate")="articleTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","defaultListTemplate")="listTemplate.htm"
 ;;Y("web-app","servlet",1,"init-param","jspFileTemplate")="articleTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","jspListTemplate")="listTemplate.jsp"
 ;;Y("web-app","servlet",1,"init-param","maxUrlLength")=500
 ;;Y("web-app","servlet",1,"init-param","redirectionClass")="org.cofax.SqlRedirection"
 ;;Y("web-app","servlet",1,"init-param","searchEngineFileTemplate")="forSearchEngines.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineListTemplate")="forSearchEnginesList.htm"
 ;;Y("web-app","servlet",1,"init-param","searchEngineRobotsDb")="WEB-INF/robots.db"
 ;;Y("web-app","servlet",1,"init-param","templateLoaderClass")="org.cofax.FilesTemplateLoader"
 ;;Y("web-app","servlet",1,"init-param","templateOverridePath")=""
 ;;Y("web-app","servlet",1,"init-param","templatePath")="templates"
 ;;Y("web-app","servlet",1,"init-param","templateProcessorClass")="org.cofax.WysiwygTemplate"
 ;;Y("web-app","servlet",1,"init-param","useDataStore")="true"
 ;;Y("web-app","servlet",1,"init-param","useJSP")="false"
 ;;Y("web-app","servlet",1,"servlet-class")="org.cofax.cds.CDSServlet"
 ;;Y("web-app","servlet",1,"servlet-name")="cofaxCDS"
 ;;Y("web-app","servlet",2,"init-param","mailHost")="mail1"
 ;;Y("web-app","servlet",2,"init-param","mailHostOverride")="mail2"
 ;;Y("web-app","servlet",2,"servlet-class")="org.cofax.cds.EmailServlet"
 ;;Y("web-app","servlet",2,"servlet-name")="cofaxEmail"
 ;;Y("web-app","servlet",3,"servlet-class")="org.cofax.cds.AdminServlet"
 ;;Y("web-app","servlet",3,"servlet-name")="cofaxAdmin"
 ;;Y("web-app","servlet",4,"servlet-class")="org.cofax.cds.FileServlet"
 ;;Y("web-app","servlet",4,"servlet-name")="fileServlet"
 ;;Y("web-app","servlet",5,"init-param","adminGroupID")=4
 ;;Y("web-app","servlet",5,"init-param","betaServer")="true"
 ;;Y("web-app","servlet",5,"init-param","dataLog")=1
 ;;Y("web-app","servlet",5,"init-param","dataLogLocation")="/usr/local/tomcat/logs/dataLog.log"
 ;;Y("web-app","servlet",5,"init-param","dataLogMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","fileTransferFolder")="/usr/local/tomcat/webapps/content/fileTransferFolder"
 ;;Y("web-app","servlet",5,"init-param","log")=1
 ;;Y("web-app","servlet",5,"init-param","logLocation")="/usr/local/tomcat/logs/CofaxTools.log"
 ;;Y("web-app","servlet",5,"init-param","logMaxSize")=""
 ;;Y("web-app","servlet",5,"init-param","lookInContext")=1
 ;;Y("web-app","servlet",5,"init-param","removePageCache")="/content/admin/remove?cache=pages&id="
 ;;Y("web-app","servlet",5,"init-param","removeTemplateCache")="/content/admin/remove?cache=templates&id="
 ;;Y("web-app","servlet",5,"init-param","templatePath")="toolstemplates/"
 ;;Y("web-app","servlet",5,"servlet-class")="org.cofax.cms.CofaxToolsServlet"
 ;;Y("web-app","servlet",5,"servlet-name")="cofaxTools"
 ;;Y("web-app","servlet-mapping","cofaxAdmin")="/admin/*"
 ;;Y("web-app","servlet-mapping","cofaxCDS")="/"
 ;;Y("web-app","servlet-mapping","cofaxEmail")="/cofaxutil/aemail/*"
 ;;Y("web-app","servlet-mapping","cofaxTools")="/tools/*"
 ;;Y("web-app","servlet-mapping","fileServlet")="/static/*"
 ;;Y("web-app","taglib","taglib-location")="/WEB-INF/tlds/cofax.tld"
 ;;Y("web-app","taglib","taglib-uri")="cofax.tld"
 ;;zzzzz

VPRJUJD^INT^1^63315;47129^0
VPRJUJD ;SLC/KCM -- Unit tests for JSON decoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
JSONUES ;; @TEST unescape JSON encoded string
 N X
 S X=$$UES^VPRJSON("String with \\ in the middle")
 D ASSERT("String with \ in the middle",X)
 S X=$$UES^VPRJSON("\\ is the first character of this string")
 D ASSERT("\ is the first character of this string",X)
 S X=$$UES^VPRJSON("The last character of this string is \\")
 D ASSERT("The last character of this string is \",X)
 S X=$$UES^VPRJSON("\\one\\two\\three\\")
 D ASSERT("\one\two\three\",X)
 S X=$$UES^VPRJSON("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f")
 D ASSERT("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12),X)
 S X=$$UES^VPRJSON("\""This text is quoted\""")
 D ASSERT("""This text is quoted""",X)
 S X=$$UES^VPRJSON("This text contains an embedded\u001A control character")
 D ASSERT("This text contains an embedded"_$C(26)_" control character",X)
 S X=$$UES^VPRJSON("This contains tab\t and control\u0016 characters")
 D ASSERT("This contains tab"_$C(9)_" and control"_$C(22)_" characters",X)
 Q
SPLITA ;; @TEST JSON input with escaped characters on single line (uses BUILD)
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILD("SPLIT",.JSON)
 D ASSERT(0,$D(JSON(2)))
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITB ;; @TEST multiple line JSON input with lines split across tokens (uses BUILDA)
 N JSON,Y,ERR,ESC
 S ESC="this string contains \and other escaped characters such as "_$c(10)
 S ESC=ESC_"  and a few tabs "_$c(9,9,9,9)_" and a piece of ""quoted text"""
 D BUILDA("SPLIT",.JSON)
 D ASSERT(1,$D(JSON(2)))
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(ESC,$G(Y("esc")))
 D ASSERT("this is a new line",$G(Y("next")))
 D ASSERT("this is a string that goes across two lines",$G(Y("wp")))
 D ASSERT("here is another string",$G(Y("nextLineQuote")))
 Q
SPLITC ;; @TEST multiple line JSON input with lines split inside boolean value
 N JSON,Y,ERR,ESC
 D BUILDA("SPLITC",.JSON)
 D ASSERT(1,$D(JSON(4)))
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("false",$G(Y("completed")))
 D ASSERT("urn:va:user:2C0A:1134",$G(Y("ownerCode")))
 D ASSERT("SQA,ONE",$G(Y("assignToName")))
 D ASSERT("urn:va:user:2C0A:1134",$G(Y("assignToCode")))
 Q
LONG ;; @TEST long document that must be saved across extension nodes
 N JSON,Y,ERR,I,LINE,CCNT1,CCNT2
 S JSON(1)="{""title"":""long document"",""size"":""rather large"",""document"":"""
 S LINE="This is a line of text intended to test longer documents.\r\n  It will be repeated so that there are several nodes that must be longer than 4000 kilobytes."
 F I=2:1:100 S JSON(I)=LINE
 S JSON(101)="\r\nThis line ends with a control character split over to the next line.\u0"
 S JSON(102)="016The last line has a control character.\u001A"
 S JSON(103)=""",""author"":""WINDED,LONG""}"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 S CCNT1=0 F I=2:1:102  S CCNT1=CCNT1+$L(JSON(I))
 S CCNT2=$L(Y("document")) F I=1:1:3 S CCNT2=CCNT2+$L(Y("document","\",I))
 D ASSERT(210,CCNT1-CCNT2) ; 100 \r\n->$C(13,10), 1 \u001a->$C(26), 1 \u0016->$C(22) = 210 less chars
 D ASSERT(3978,$L(Y("document")))
 D ASSERT(3323,$L(Y("document","\",3)))
 D ASSERT(1,Y("document","\",3)[$C(22))
 D ASSERT($C(26),$E(Y("document","\",3),$L(Y("document","\",3))))
 D ASSERT(0,$D(Y("document",4)))
 D ASSERT("WINDED,LONG",Y("author"))
 D ASSERT("rather large",Y("size"))
 Q
FRAC ;; @TEST multiple lines with fractional array elements
 ;; {"title":"my array of stuff", "count":3, "items": [
 ;; {"name":"red", "rating":"ok"},
 ;; {"name":"blue", "rating":"good"},
 ;; {"name":"purple", "rating":"outstanding"}
 ;; ]}
 N JSON,Y,ERR
 S JSON(0)=$P($T(FRAC+1),";;",2,99)
 S JSON(.5)=$P($T(FRAC+2),";;",2,99)
 S JSON(1)=$P($T(FRAC+3),";;",2,99)
 S JSON(1.1)=$P($T(FRAC+4),";;",2,99)
 S JSON(1.2)=$P($T(FRAC+5),";;",2,99)
 S JSON("JUNK")="Junk non-numeric node -- this should be ignored"
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("purple",Y("items",3,"name"))
 Q
VALONLY ;; @TEST passing in value only -- not array
 N JSON,Y,ERR
 S JSON=$P($T(VALONLY+1^VPRJUJ01),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("urn:va:param:F484:1120:VPR USER PREF:1120",Y("uid"))
 D ASSERT("north",Y("vals","cpe.patientpicker.loc"))
 Q
NUMERIC ;; @TEST passing in numeric types and strings
 N JSON,Y,ERR
 S JSON=$P($T(NUMERIC+1^VPRJUJ01),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(234567,+Y("count")) ; make sure it's numeric
 D ASSERT(20120919,Y("hl7Time"))
 D ASSERT(1,$D(Y("hl7Time","\s")))
 D ASSERT("722.10",Y("icd"))
 D ASSERT(0,+Y("icd")="722.10") ; make sure it's a string
 Q
NEARZERO ;; @TEST decoding numbers near 0
 ;; {"x":0.42, "y":-0.44, "s":"0.5", "t":"-0.6"}
 N JSON,JSON2,Y,ERR
 S JSON=$P($T(NEARZERO+1),";;",2,999)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(Y("x","\n")))
 D ASSERT(1,$D(Y("y","\n")))
 D ASSERT(.42,Y("x"))
 D ASSERT(-.44,Y("y"))
 D ASSERT(0,Y("s")=.5)
 D ASSERT(0,Y("t")=-.6)
 Q
BADQUOTE ;; @TEST poorly formed JSON (missing close quote on LABEL)
 N JSON,Y,ERR
 D BUILD("BADQUOTE",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
BADSLASH ;; @TEST poorly formed JSON (non-escaped backslash)
 N JSON,Y,ERR
 D BUILD("BADSLASH",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(1,$D(ERR)>0)
 Q
PSNUM ;; @TEST subjects that look like a numbers shouldn't be encoded as numbers
 N JSON,Y,ERR
 D BUILD("PSNUM",.JSON)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(Y("0.85,0.01","AUDIT"),"TEST1")
 D ASSERT(Y("0.85,0.02","AUDIT"),"TEST3")
 D ASSERT(Y("0.85,0.03","AUDIT"),"TEST5")
 Q
NUMLABEL ;; @TEST label that begins with numeric
 N JSON,Y,ERR
 D BUILD("NUMLABEL",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(46570,Y("syncStatusByVistaSystemId","9E99","dfn"))
 Q
PURENUM ;; @TEST label that is purely numeric
 N JSON1,JSON2,Y,RSLT,ERR
 D BUILD("PURENUM1",.JSON1)
 D DECODE^VPRJSON("JSON1","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(100,Y("syncStatusByVistaSystemId","""1234","domainExpectedTotals","bar","total"))
 D ASSERT(1,$D(Y("forOperational","\s"))) ; appears boolean but really a string
 D ENCODE^VPRJSON("Y","JSON2","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,($L(JSON1(1))=$L(JSON2(1))))
 D ASSERT(1,(JSON2(1)[":{""1234"":{"))
 D BUILD("PURENUM2",.RSLT)
 D ASSERT(RSLT(1),JSON2(1))
 Q
STRTYPES ;; @TEST strings that may be confused with other types
 N JSON,Y,ERR
 D BUILD("STRTYPES",.JSON)
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,$D(Y("syncStatusByVistaSystemId","""1234","syncComplete","\s")))
 Q
ESTRING ;; @TEST a value that looks like an exponents, other numerics
 N JSON,Y,JSON2,ERR
 D BUILD("ESTRING",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("32E497ABC",Y("b"))
 D ASSERT(.123,Y("c"))
 D ASSERT(3E22,Y("g"))
 D ASSERT(1,$D(Y("g","\n")))
 D ASSERT(0,Y("h")=2E8)
 D ENCODE^VPRJSON("Y","JSON2","ERR")
 D ASSERT(1,JSON(1)=JSON2(1))
 Q
SAM1 ;; @TEST decode sample 1 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM1",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("file",$G(Y("menu","id")))
 D ASSERT("OpenDoc()",$G(Y("menu","popup","menuitem",2,"onclick")))
 Q
SAM2 ;; @TEST decode sample 2 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM2",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT("XML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","GlossDef","GlossSeeAlso",2)))
 D ASSERT("SGML",$G(Y("glossary","GlossDiv","GlossList","GlossEntry","SortAs")))
 Q
SAM3 ;; @TEST decode sample 3 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM3",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(500,$G(Y("widget","window","width")))
 D ASSERT("sun1.opacity = (sun1.opacity / 100) * 90;",$G(Y("widget","text","onMouseUp")))
 D ASSERT("Sample Konfabulator Widget",$G(Y("widget","window","title")))
 Q
SAM4 ;; @TEST decode sample 4 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM4",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("web-app","servlet",6)))  ; should only be 5 servlets
 D ASSERT(1,$G(Y("web-app","servlet",5,"init-param","log")))
 D ASSERT("/usr/local/tomcat/logs/CofaxTools.log",$G(Y("web-app","servlet",5,"init-param","logLocation")))
 D ASSERT("/",$G(Y("web-app","servlet-mapping","cofaxCDS")))
 D ASSERT("/WEB-INF/tlds/cofax.tld",$G(Y("web-app","taglib","taglib-location")))
 Q
SAM5 ;; @TEST decode sample 5 from JSON.ORG
 N JSON,Y,ERR
 D BUILD("SAM5",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(0,$D(Y("menu","items",23)))  ; should only be 22 items
 D ASSERT("About Adobe CVG Viewer...",$G(Y("menu","items",22,"label")))
 D ASSERT("null",$G(Y("menu","items",3)))
 Q
 ;
MAXNUM ;; @TEST encode large string that looks like number
 N I,X,Y,JSON,ERR,OUT
 F I=0:1 S X=$P($T(MAXNUM+(I+1)^VPRJUJ01),";;",2,999) Q:X="#####"  S JSON(I)=X
 D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1807,$L(Y("taskName")))
 D ENCODE^VPRJSON("Y","OUT","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(1,$L(OUT(1))>2000)
 D ASSERT(1,OUT(1)["""taskName"":""123")
 Q
ESCQ ;; @TEST escaped quote across lines
 N JSON,Y,ERR
 D BUILDA("ESCQ",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(55,$L(Y("comments")))
 K JSON,Y,ERR
 D BUILDA("ESCQ2",.JSON) D DECODE^VPRJSON("JSON","Y","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT(42,$L(Y("bjw")))
 Q
BUILD(TAG,JSON) ; Build array of strings in JSON for TAG
 N X,I,LINE
 S LINE=1,JSON(LINE)=""
 F I=1:1 S X=$E($T(@TAG+I^VPRJUJ01),4,999) Q:X="#####"  D
 . I $L(JSON(LINE))+$L(X)>4000 S LINE=LINE+1,JSON(LINE)=""
 . S JSON(LINE)=JSON(LINE)_X
 Q
BUILDA(TAG,JSON) ; Build array of string in JSON with splits preserved
 N X,I
 F I=1:1 S X=$E($T(@TAG+I^VPRJUJ01),4,999) Q:X="#####"  S JSON(I)=X
 Q

VPRJUJE^INT^1^63315;47129^0
VPRJUJE ;SLC/KCM -- Unit tests for JSON encoding
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
NUMERIC ;; @TEST is numeric function
 D ASSERT(0,$$NUMERIC^VPRJSONE("2COWS"))
 D ASSERT(0,$$NUMERIC^VPRJSONE("007"))
 D ASSERT(0,$$NUMERIC^VPRJSONE(".4"))
 D ASSERT(1,$$NUMERIC^VPRJSONE("0.4"))
 D ASSERT(0,$$NUMERIC^VPRJSONE("-.4"))
 D ASSERT(1,$$NUMERIC^VPRJSONE("-0.4"))
 D ASSERT(1,$$NUMERIC^VPRJSONE(0))
 D ASSERT(0,$$NUMERIC^VPRJSONE(".0"))
 D ASSERT(1,$$NUMERIC^VPRJSONE(3.1416))
 D ASSERT(1,$$NUMERIC^VPRJSONE("2.3E-2"))
 D ASSERT(1,$$NUMERIC^VPRJSONE(0.4E12))
 D ASSERT(0,$$NUMERIC^VPRJSONE(".4E-12"))
 Q
NEARZERO ;; @TEST encode of numbers near 0
 ;;{"s":"0.5","t":"-0.6","x":0.42,"y":-0.44}
 N X,JSON,ERR
 S X("s")="0.5",X("s","\s")=""
 S X("t")="-0.6",X("t","\s")=""
 S X("x")=0.42
 S X("y")=-0.44
 D ENCODE^VPRJSON("X","JSON","ERR")
 D ASSERT($P($T(NEARZERO+1),";;",2,99),JSON(1))
 Q
JSONESC ;; @TEST create JSON escaped string
 N X
 S X=$$ESC^VPRJSON("String with \ in the middle")
 D ASSERT("String with \\ in the middle",X)
 S X=$$ESC^VPRJSON("\ is the first character of this string")
 D ASSERT("\\ is the first character of this string",X)
 S X=$$ESC^VPRJSON("The last character of this string is \")
 D ASSERT("The last character of this string is \\",X)
 S X=$$ESC^VPRJSON("\one\two\three\")
 D ASSERT("\\one\\two\\three\\",X)
 S X=$$ESC^VPRJSON("A vee shape: \/"_$C(9)_"TABBED"_$C(9)_"and line endings."_$C(10,13,12))
 D ASSERT("A vee shape: \\\/\tTABBED\tand line endings.\n\r\f",X)
 S X=$$ESC^VPRJSON("""This text is quoted""")
 D ASSERT("\""This text is quoted\""",X)
 S X=$$ESC^VPRJSON("This text contains an embedded"_$C(26)_" control character")
 D ASSERT("This text contains an embedded\u001A control character",X)
 S X=$$ESC^VPRJSON("This contains tab"_$C(9)_" and control"_$C(22)_" characters")
 D ASSERT("This contains tab\t and control\u0016 characters",X)
 S X=$$ESC^VPRJSON("This has embedded NUL"_$C(0)_" character.")
 D ASSERT("This has embedded NUL character.",X)
 Q
BASIC ;; @TEST encode basic object as JSON
 N X,JSON
 S X("myObj","booleanT")="true"
 S X("myObj","booleanF")="false"
 S X("myObj","numeric")=3.1416
 S X("myObj","nullValue")="null"
 S X("myObj","array",1)="one"
 S X("myObj","array",2)="two"
 S X("myObj","array",3)="three"
 S X("myObj","subObject","fieldA")="hello"
 S X("myObj","subObject","fieldB")="world"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("BASIC"),JSON(1))
 Q
VALS ;; @TEST encode simple values only object as JSON
 N X,JSON
 S X("prop1")="property1"
 S X("bool1")="true"
 S X("num1")="2.1e3",X("num1","\n")=""
 S X("arr",1)="apple"
 S X("arr",2)="orange"
 S X("arr",3)="pear"
 S X("arr",4,"obj")="4th array item is object"
 D ENCODE^VPRJSON("X","JSON")
 D ASSERT($$TARGET("VALS"),JSON(1))
 Q
LONG ;; @TEST encode object with continuation nodes for value
 N X,I,JSON,FILLER,TARGET
 S FILLER=", this will extend the line out to at least 78 characters."_$C(10)
 S X("title")="My note test title"
 S X("note")="This is the first line of the note.  Here are ""quotes"" and a \ and a /."_$C(10)
 F I=1:1:60 S X("note","\",I)="Additional Line #"_I_FILLER
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("LONG")
 D ASSERT(TARGET,$E(JSON(1),1,$L(TARGET)))
 D ASSERT(1,$D(JSON(2)))
 D ASSERT(0,$D(JSON(3)))
 S TARGET="s.\n"",""title"":""My note test title""}"
 D ASSERT(TARGET,$E(JSON(2),$L(JSON(2))-$L(TARGET)+1,$L(JSON(2))))
 Q
PRE ;; @TEST encode object where parts are already JSON encoded
 N X,JSON,TARGET
 S X("count")=3
 S X("menu",1,":",1)=$$TARGET("NODES",1)
 S X("menu",2,":",1)=$$TARGET("NODES",2)
 S X("menu",3,":",1)=$$TARGET("NODES",3)
 S X("template",":")=$$TARGET("NODES",4)
 D ENCODE^VPRJSON("X","JSON")
 S TARGET=$$TARGET("PRE",1)_$$TARGET("PRE",2)
 D ASSERT(TARGET,JSON(1))
 Q
WP ;; @TEST word processing nodes inside object
 N Y,JSON,TARGET,ERR
 D BUILDY("WP")
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 S TARGET=$$TARGET("WPOUT")_$$TARGET("WPOUT",2)_$$TARGET("WPOUT",3)
 D ASSERT(TARGET,JSON(1))
 Q
LTZERO ;; @TEST leading / trailing zeros get preserved
 N Y,JSON,TARGET
 S Y("count")=737
 S Y("ssn")="000427930"
 S Y("icd")="626.00"
 S Y("price")=".65" ;M still treats this as a number, so in JSON it's 0.65
 S Y("code")=".77",Y("code","\s")=""
 S Y("errors")=0
 D ENCODE^VPRJSON("Y","JSON")
 D ASSERT($$TARGET("LTZERO"),JSON(1))
 Q
STRINGS ;; @TEST force encoding as string
 N Y,JSON,TARGET,ERR
 S Y("count")=234567
 S Y("hl7Time")="20120919"
 S Y("hl7Time","\s")=""
 S Y("icd")="722.10"
 S Y("name")="Duck,Donald"
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($$TARGET("STRINGS"),JSON(1))
 Q
LABELS ;; @TEST unusual labels
 ;;{"top":[{"10":"number 10",",":"comma",":":"colon","\":"backslash","a":"normal letter"}]}
 ;
 ; NOTE: we don't allow a label to contain a quote (")
 N Y,JSON,ERR,Y2
 S Y("top",1,":")="colon"
 S Y("top",1,"\")="backslash"
 S Y("top",1,",")="comma"
 S Y("top",1,"a")="normal letter"
 S Y("top",1,"""10")="number 10"
 D ENCODE^VPRJSON("Y","JSON","ERR")
 D ASSERT(0,$D(ERR))
 D ASSERT($P($T(LABELS+1),";;",2,99),JSON(1))
 Q
EXAMPLE ;; @TEST encode samples that are on JSON.ORG
 N Y,JSON,TARGET
 D BUILDY("EX1IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX1OUT")
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX2IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX2OUT")_$$TARGET("EX2OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX3IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX3OUT")_$$TARGET("EX3OUT",2)
 D ASSERT(TARGET,JSON(1))
 D BUILDY("EX4IN")
 D ENCODE^VPRJSON("Y","JSON")
 S TARGET=$$TARGET("EX4OUT")
 D ASSERT(TARGET,$E(JSON(1),1,215))
 D ASSERT(2758,$L(JSON(1)))
 Q
BUILDY(LABEL) ; build Y array based on LABEL
 ; expects Y from EXAMPLE
 N I,X
 K Y
 F I=1:1 S X=$P($T(@LABEL+I^VPRJUJ02),";;",2,999) Q:X="zzzzz"  X "S "_X
 Q
TARGET(ID,OFFSET) ; values to test against
 S OFFSET=$G(OFFSET,1)
 Q $P($T(@ID+OFFSET^VPRJUJ02),";;",2,999)

VPRJUREQ^INT^1^63294;58829^0
VPRJUREQ ;SLC/KCM -- Unit tests for HTTP listener request handling
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
PMATCH ;; @TEST matching path patterns for logging
 D ASSERT(1,$$MATCH^VPRJREQ("/vpr/-7/index/utesta","/vpr/*/index/utesta"))
 D ASSERT(0,$$MATCH^VPRJREQ("/vpr/-7/index/utestb","/vpr/*/index/utesta"))
 D ASSERT(0,$$MATCH^VPRJREQ("/vpr/-7/index/utesta","/vpr/*/index/utesta/summary"))
 D ASSERT(1,$$MATCH^VPRJREQ("/vpr/-7/index/utesta/summary","/vpr/*/index/utesta/..."))
 D ASSERT(1,$$MATCH^VPRJREQ("/vpr/-7/index/utesta","/vpr/*/index/utesta/..."))
 D ASSERT(0,$$MATCH^VPRJREQ("/vpr/-7/index/utesta/...","/vpr/*/index/utesta/summary"))
 D ASSERT(0,$$MATCH^VPRJREQ("/vpr/-7/index/utesta",""))
 D ASSERT(0,$$MATCH^VPRJREQ("/vpr/-7/index/utesta","/vpr"))
 D ASSERT(1,$$MATCH^VPRJREQ("/vpr/-7/index/utesta","/vpr/..."))
 Q

VPRJURSP^INT^1^63294;58829^0
VPRJURSP ;SLC/KCM -- Unit tests for HTTP listener response handling
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
QSPLIT ;; @TEST splitting query parameters
 N QRY,HTTPERR
 S HTTPREQ("query")="range=20060101..20061231"
 D QSPLIT^VPRJRSP(.QRY)
 D ASSERT($D(QRY("range")),1)
 D ASSERT("20060101..20061231",QRY("range"))
 K QRY
 S HTTPREQ("query")="range=20060101..20061231&order=desc&limit=5"
 D QSPLIT^VPRJRSP(.QRY)
 D ASSERT("desc",QRY("order"))
 D ASSERT(5,QRY("limit"))
 Q
 ;
SETREQ(METHOD,URL) ; set up a request (to emulate HTTP call)
 S HTTPREQ("method")=METHOD
 S HTTPREQ("path")=$P(URL,"?")
 S HTTPREQ("query")=$P(URL,"?",2,999)
 Q
MATCH ;; @TEST matching for URLs
 N ROU,ARGS
 D SETREQ("GET","/vpr/48/urn:va:9E3C:229:med:33246") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("GETOBJ^VPRJPR",ROU)
 D ASSERT("urn:va:9E3C:229:med:33246",ARGS("uid"))
 D SETREQ("PUT","/vpr") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("PUTPT^VPRJPR",ROU)
 D ASSERT(0,$D(ARGS))
 D SETREQ("PUT","/vpr/42") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("PUTOBJ^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D SETREQ("GET","/vpr/42/index/med-outpt") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("INDEX^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D ASSERT("med-outpt",ARGS("indexName"))
 D SETREQ("GET","/vpr/42/index/med-outpt/simple") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("INDEX^VPRJPR",ROU)
 D ASSERT(42,ARGS("pid"))
 D ASSERT("med-outpt",ARGS("indexName"))
 D ASSERT("simple",ARGS("template"))
 D SETREQ("GET","/vpr/all/count/med-outpt") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("ALLCOUNT^VPRJPR",ROU)
 D ASSERT("med-outpt",ARGS("countName"))
 D SETREQ("DELETE","/vpr/42") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT("DELPT^VPRJPR",ROU)
 K HTTPREQ,HTTPERR
 Q
NOMATCH ;; @TEST error codes when no match found
 ;;GET vpr/{patient?1.N}/find/{collection} FIND^VPRJPR
 N ROU,ARGS
 D SETREQ("DELETE","/vpr/42/find/med") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT(405,HTTPERR)
 D ASSERT(0,$D(ARGS))
 D ASSERT("",ROU)
 D SETREQ("GET","vpr/42/bogus") D MATCH^VPRJRSP(.ROU,.ARGS)
 D ASSERT(404,HTTPERR)
 D ASSERT(0,$D(ARGS))
 D ASSERT("",ROU)
 K HTTPREQ,HTTPERR
 Q

VPRJURUT^INT^1^63294;58829^0
VPRJURUT ;SLC/KCM -- Unit tests for HTTP listener utilities
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
STARTUP  ; Run once before all tests
 Q
SHUTDOWN ; Run once after all tests
 Q
SETUP    ; Run before each test
 Q
TEARDOWN ; Run after each test
 Q
ASSERT(EXPECT,ACTUAL) ; convenience
 D EQ^VPRJT(EXPECT,ACTUAL)
 Q
 ;
URLENC ;; @TEST test encoding string for use in a URL
 N X
 S X=$$URLENC^VPRJRUT("VALUES=20%&60% + or -")
 D ASSERT("VALUES%3D20%25%2660%25+%2B+or+-",X)
 Q
URLDEC ;; @TEST test decoding URL back into string
 N X
 S X=$$URLDEC^VPRJRUT("VALUES%3D20%25%2660%25+%2B+or+-")
 D ASSERT("VALUES=20%&60% + or -",X)
 S X=$$URLDEC^VPRJRUT("piece+of+path",1) ; '+' may be part of path
 D ASSERT("piece+of+path",X)
 Q

VPRJVER^INT^1^63435;39516^0
VPRJVER ;SLC/KCM -- Version info for this routine set
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
VERSION ;;0.7-S68-SNAPSHOT
BUILD ;;20141104125820

VPRJVUP^INT^1^63412;50872^0
VPRJVUP ;SLC/KCM -- Upgrade database
 ;;1.0;JSON DATA STORE;;Sep 01, 2012
 ;
 ; Steps to do before calling UPGRADE^VPRJVUP:
 ;
 ; I $T(STOPW^VPRJRCL) D STOPW^VPRJRCL             ; -- stop listener
 ; W $system.OBJ.Load(quoted_path_to_jds.ro,"ck")  ; -- load routines
 ;
UPGRADE ; upgrade JDS (assume new routines are loaded)
 N LASTVER,THISVER
 K ^XTMP("VPRJVUP")                          ; -- reset upgrade log for
 S ^XTMP("VPRJVUP","odc")=""                 ;    rebuild status calls
 S ^XTMP("VPRJVUP","vpr")=""
 S ^VPRHTTP(0,"updating")=1                  ; -- set upgrade flag
 D STOPW^VPRJRCL                             ; -- stop listener
 S LASTVER=$G(^VPRMETA("version"))           ; -- last installed version
 S THISVER=$P($T(VERSION^VPRJVER),";;",2,99) ; -- new version
 I $$INTVER(LASTVER)<700460 D TASK1          ; -- previous to 0.7-S46
 I $$INTVER(LASTVER)<700610 D CNVRT61        ; -- previous to 0.7-S61
 J UPGBACK^VPRJVUP                           ; -- do rebuild in background
 W !,"Upgrading from "_LASTVER_" to "_THISVER,!
 Q
UPGBACK ; upgrade as background process
 D FULLRBLD^VPRJ                             ; -- full rebuild of VPR and ODC
 K ^VPRHTTP(0,"updating")                    ; -- clear upgrade flag
 D GO^VPRJRCL                                ; -- start listener
 Q
WATCH ; watch the progress of the upgrade
 N X
 F  H 2 S X=$$RBLDSTS^VPRJ() W !,X Q:X["done"
 Q
UPGVIEW ; perform upgrade and watch progress
 D UPGRADE,WATCH
 Q
INTVER(X) ; Return integer representation of version
 Q (1000000*X+($P(X,"-S",2)*10)) ; main*1000000 + sprint*10
 ;
 ;
TASK1 ; move JSON, template, indexing nodes out of main data global
 ; move the JSON and Templates into ^VPRPTJ global
 I '$D(^VPRPTJ("JSON")),$D(^VPRPT("JSON")) D
 . M ^VPRPTJ("JSON")=^VPRPT("JSON")  ; preserve patient data
 . K ^VPRPT("JSON")
 . K ^VPRPT("TEMPLATE")              ; we'll rebuild the rest
 . K ^VPRPT("KEY")
 . K ^VPRPT("PID")
 ;
 ; move the JSON into the ^VPRJDJ global
 I '$D(^VPRJDJ("JSON")),$D(^VPRJD("JSON")) D
 . M ^VPRJDJ("JSON")=^VPRJD("JSON")  ; preserve operational data
 . K ^VPRJD("JSON")
 . K ^VPRJD("TEMPLATE")
 Q
CNVRT61 ; Convert syncstatus objects for version 0.7-S61
 N ROOT,JSON,UID,LROOT,DFN,SITE,PID,DNM,PITER,PTUID,LOCIDS
 S ROOT="urn:va:syncstatus:",LROOT=$L(ROOT)
 S UID=ROOT F  S UID=$O(^VPRJDJ("JSON",UID)) Q:$E(UID,1,LROOT)'=ROOT  D
 . W UID,!
 . M JSON=^VPRJDJ("JSON",UID)
 . D DECODE^VPRJSON("JSON","OBJ","ERR")
 . S SITE=$P(UID,":",4),DFN=$P(UID,":",5)
 . I SITE'="OPD",$D(DFN) D
 . . S PTUID="urn:va:patient:"_SITE_":"_DFN_":"_DFN
 . . S PID=SITE_";"_DFN
 . . S DNM=^VPRPT(PID,PTUID,"displayName")
 . . S LOCIDS="",PITER=""
 . . F  S PITER=$O(^VPRPT(PID,PTUID,"facilities",PITER)) Q:PITER=""  D
 . . . I $D(^VPRPT(PID,PTUID,"facilities",PITER,"code")),$D(^VPRPT(PID,PTUID,"facilities",PITER,"localPatientId"))  D
 . . . . I LOCIDS'=""  S LOCIDS=LOCIDS_","
 . . . . S LOCIDS=LOCIDS_","_^VPRPT(PID,PTUID,"facilities",PITER,"code")_";"_^VPRPT(PID,PTUID,"facilities",PITER,"localPatientId")
 . . S OBJ("displayName")=DNM,OBJ("localPatientIds")=LOCIDS
 . . K JSON
 . . D ENCODE^VPRJSON("OBJ","JSON","ERR")
 . . M ^VPRJDJ("JSON",UID)=JSON
 Q

VPRZJMC^INT^1^63294;58829^0
VPRZJMC ; My very own test file
 ; 
FIND(VAL) ; Search up to 4 deep for a value and show the global path to it if found.
 S W="",X="",Y="",Z=""
 F  S W=$O(^VPRPT(W)) Q:W=""  D
 . I $D(^VPRPT(W))=1,^VPRPT(W)=VAL W W,!
 . F  S X=$O(^VPRPT(W,X)) Q:X=""  D
 . . I $D(^VPRPT(W,X))=1,^VPRPT(W,X)=VAL W W,",",X,!
 . . F  S Y=$O(^VPRPT(W,X,Y)) Q:Y=""  D
 . . . I $D(^VPRPT(W,X,Y))=1,^VPRPT(W,X,Y)=VAL W W,",",X,",",Y,!
 . . . F  S Z=$O(^VPRPT(X,Y,Z)) Q:Z=""  D
 . . . . I $D(^VPRPT(W,X,Y,Z))=1,^VPRPT(W,X,Y,Z)=VAL W W,",",X,",",Y,",",Z,!
 Q

XLFCRC^INT^1^63294;58829^0
XLFCRC ;ISF/RWF - Library Functions to do CRC ;08/04/2000  09:42
 ;;8.0;KERNEL;**166**;Jul 10, 1995
 ; The code below was approved in document X11/1998-32
 ;From the book "M[UMPS] by example" by Ed de Mole.
 ;
CRC32(string,seed) ;
 ; Polynomial X**32 + X**26 + X**23 + X**22 +
 ;          + X**16 + X**12 + X**11 + X**10 +
 ;          + X**8  + X**7  + X**5  + X**4 +
 ;          + X**2  + X     + 1
 N I,J,R
 I '$D(seed) S R=4294967295
 E  I seed'<0,seed'>4294967295 S R=4294967295-seed
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,3988292384,32)
 . . E  S R=R\2
 . . Q
 . Q
 Q 4294967295-R
 ;
XOR(a,b,w) N I,M,R
 S R=b,M=1
 F I=1:1:w D
 . S:a\M#2 R=R+$S(R\M#2:-M,1:M)
 . S M=M+M
 . Q
 Q R
 ; ===
 ;
 ; The code below was approved in document X11/1998-32
 ;
CRC16(string,seed) ;
 ; Polynomial x**16 + x**15 + x**2 + x**0
 N I,J,R
 I '$D(seed) S R=0
 E  I seed'<0,seed'>65535 S R=seed\1
 E  S $ECODE=",M28,"
 F I=1:1:$L(string) D
 . S R=$$XOR($A(string,I),R,8)
 . F J=0:1:7 D
 . . I R#2 S R=$$XOR(R\2,40961,16)
 . . E  S R=R\2
 . . Q
 . Q
 Q R
 ;
ZXOR(a,b,w) NEW I,M,R
 SET R=b,M=1
 FOR I=1:1:w DO
 . SET:a\M#2 R=R+$SELECT(R\M#2:-M,1:M)
 . SET M=M+M
 . QUIT
 QUIT R
 ;

XLFDT^INT^1^63294;58829^0
XLFDT ;ISC-SF/STAFF - Date/Time Functions ;03/27/2003  14:09
 ;;8.0;KERNEL;**71,120,166,168,179,280**;Jul 10, 1995
 ;VA FileMan uses 2400 as midnight, many other system use 0000.
 ;This is true for $H and HL7, so a conversion has to adjust
 ;the day when converting Midnight.
 ;i.e. 3001225.24 is the same as HL7 '200012260000' and $H '58434,0'
 ;The range of accepted $H dates: "2,0" to "99999,85399".
 ;The range of accepted FM dates: 1410102 to 4141015 (any valid time).
 ;The range of accepted HL7 dates: 18410102 to 21141015 (any valid time).
 ;It is expected that input values are valid dates.
 ;
HTFM(%H,%F) ;$H to FM, %F=1 for date only
 N X,%,%T,%Y,%M,%D S:'$D(%F) %F=0
 I $$HR(%H) Q -1 ;Check Range
 I '%F,%H[",0" S %H=(%H-1)_",86400"
 D YMD S:%T&('%F) X=X_%T
 Q X
 ;
H2F(%H) ;Internal to this routine use
 N X,%,%T,%Y,%M,%D
 D YMD S:%T X=X_%T
 Q X
 ;
YMD ;21608 = 28 feb 1900, 94657 = 28 feb 2100, 141 $H base year
 S %=(%H>21608)+(%H>94657)+%H-.1,%Y=%\365.25+141,%=%#365.25\1
 S %D=%+306#(%Y#4=0+365)#153#61#31+1,%M=%-%D\29+1
 S X=%Y_"00"+%M_"00"+%D,%=$P(%H,",",2)
 S %T=%#60/100+(%#3600\60)/100+(%\3600)/100 S:'%T %T=".0"
 Q
 ;
FMTH(X,%F) ;FM to $H, %F=1 for date only
 N %Y,%H,%A S:'$D(%F) %F=0
 I $$FR(X) Q -1 ;$H range of 1 - 99999
 I '%F,X[".24" S %A=1
 D H S:%F %H=+%H I $D(%A) S %H=(%H+1)_",0"
 Q %H
 ;
F2H(X) ;Internal to this routine use
 N %Y,%H,%A
 D H
 Q %H
 ;
H ;Build %H from FM
 N %,%L,%M,%D,%T I X<1410101 S %H=0,%Y=-1 Q
 S %Y=$E(X,1,3),%M=$E(X,4,5),%D=$E(X,6,7)
 S %T=$E(X_0,9,10)*60+$E(X_"000",11,12)*60+$E(X_"00000",13,14)
 ;%L = (# leap years) - (# leap years before base)
 S %L=%Y+1700 S:%M<3 %L=%L-1 S %L=(%L\4)-(%L\100)+(%L\400)-446
 S %H=$P("^31^59^90^120^151^181^212^243^273^304^334","^",%M)+%D
 S %=('%M)!('%D),%Y=%Y-141,%H=(%H+(%Y*365)+%L+%)_","_%T,%Y=$S(%:-1,1:%H+4#7)
 Q
 ;
HTE(%H,%F) ;$H to external
 Q:$$HR(%H) %H ;Range Check
 N Y,%T,%R
 S %F=$G(%F,1) S Y=$$HTFM(%H,0) G T2
 ;
FMTE(Y,%F) ;FM to external
 Q:(Y<1000000)!(Y>9991231) Y ;Range Check
 N %T,%R S %F=$G(%F,1)
 ;Both HTE and FMTE come here.
T2 S %T="."_$E($P(Y,".",2)_"000000",1,7)
 D FMT^XLFDT1 Q %R
 ;
FR(%V) ;Check FM in valid range
 Q (%V<1410102)!(%V>4141015.235959)
HR(%V) ;Check $H in valid range
 Q (%V<2)!(%V>99999)
 ;
FMTHL7(%P1) ;Convert FM date/time to HL7 format
 N %T Q:'$L(%P1) "" S %P1=+%P1 ;Make sure a cononic number
 I $$FR(%P1) Q -1 ;Check range
 S %T=$P(%P1,".",2),%P1=$P(%P1,".")
 I %T=24 S %P1=$$FMADD($P(%P1,"."),1),%T="0000"
 S:%P1>1 %P1=%P1+17000000
 I $L(%T) S %T=$S($L(%T)>4:$E(%T_"00",1,6),1:$E(%T_"0000",1,4))
 I $L(%T) S %P1=%P1_%T_$$TZ()
 Q %P1
 ;
HL7TFM(%P1,%P2,%P3) ;Convert HL7 D/T to FM.
 ;%P1 is the value to convert
 ;%P2 is if output should be local or UCT time (L,U)
 ;%P3 is 1 if the input just a time value?
 N %TZ,%LTZ,%SN,%U,%H,%M,%T Q:'$L(%P1) ""
 S %T=$E(%P1_"0000",1,8)
 S %P2=$G(%P2),%P3=+$G(%P3),%TZ="",%LTZ=$$TZ()
 I '%P3 Q:(%T<18410102)!(%T>21141015) -1 ;Date Range Check
 F %SN="+","-" I %P1[%SN D  Q  ;Find the timezone
 . S %TZ=$P(%P1,%SN,2),%P1=$P(%P1,%SN) I %TZ'?4N S %TZ="" Q
 . S %TZ=%SN_%TZ
 . Q
 ;FM only supports time to seconds
 S %P1=$P(%P1,".")
 ;See it just a Time value
 I %P3 S %P1="20000104"_%P1 ;Add a date
 Q:($L(%P1)#2)!(%P1'?4.14N) -1 ;Length check
 I $L(%P1)<8 S %P1=$E(%P1_"00000000",1,8) ;Fill out to 8 digits
 I %TZ="" D
 . S:%P2["L" %P2="" ;If no TZ, assume local, don't need L.
 . S:%P2["U" %TZ=%LTZ ;give the local tz
 ;
 S %P1=$S($L(%P1)>8:$E(%P1,1,8)-17000000_"."_$E(%P1,9,14),1:%P1-17000000)
 ;%P1 is now in FM format
 I %P1[".",+$P(%P1,".",2)=0 S %P1=$$FMADD(+%P1,-1)_".24"
 ;If HL7 tz and local tz are the same
 I %P2["L",%TZ=%LTZ S %P2=""
 I (%P2["U")!(%P2["L"),%P1["." D  ;Build UCT from data
 . S %=$TR(%TZ,"+-","-+") ;Reverse the sign
 . S %H=$E(%,1,3),%M=$E(%,1)_$E(%,4,5)
 . S %P1=$$FMADD(%P1,,%H,%M) Q
 ;
 I %P2["L",%P1["." D  ;Build local from UCT
 . S %=$$TZ(),%H=$E(%,1,3),%M=$E(%,1)_$E(%,4,5)
 . S %P1=$$FMADD(%P1,,%H,%M) Q
 Q +$S(%P3:"."_$P(%P1,".",2),1:%P1)
 ;
DOW(X,Y) ;Day of Week
 N %Y,%M,%D,%H,%T D H I $G(Y) Q %Y
 Q $P("Sun^Mon^Tues^Wednes^Thurs^Fri^Satur","^",%Y+1)_"day"
 ;
FMDIFF(X1,X2,X3) ;FM diff in two dates. if X3=1 in days, if X3=2 in seconds.
 N %H,%Y,X
 S X1=$G(X1),X2=$G(X2),X3=$G(X3,1)
 S:$$FR(X1) X1=0 S:$$FR(X2) X2=0 ;Check range, Use 0 for bad values
 S X=X1 D H S X1=+%H,X1(1)=$P(%H,",",2),X=X2 D H
 ;Both FMDIFF and HDIFF come here.
D2 S X=(X1-%H) S:X3>1 X=X*86400+(X1(1)-$P(%H,",",2))
 I X3=3 S %=X,X="" S:%'<86400 X=(%\86400) S:%#86400 X=X_" "_(%#86400\3600)_":"_$E(%#3600\60+100,2,3)_":"_$E(%#60+100,2,3)
 Q X
 ;
HDIFF(X1,X2,X3) ;$H diff in two dates, X3 same as FMDIFF.
 N X,%H,%T
 S:$$HR(X1) X1="1,1" S:$$HR(X2) X2="1,1" ;Check range, use "1,1" for bad values
 S X3=$G(X3,1)
 S X1(1)=$P(X1,",",2),X1=+X1,%H=X2
 G D2
 ;
HADD(X,D,H,M,S) ;Add to $H date
 N %H,%T
 Q:$$HR(X) -1 ;Check Range
 S %H=+X,%T=$P(X,",",2) D A2 Q %H_","_%T
 ;
A2 S %H=%H+$G(D),%T=%T+($G(H)*3600)+($G(M)*60)+$G(S) ;add days and seconds
 ;S:%T'<86400 %H=%H+(%T\86400),%T=%T#86400 S:%T<0 %H=%H+(%T\86400)-1,%T=%T#86400
 S %H=%H+(%T\86400) I %T<0,(%T#86400'=0) S %H=%H-1 ;Adj for sec>day
 S %T=%T#86400
 Q
 ;
FMADD(X,D,H,M,S) ;Add to FM date
 N %H,%T,%P
 Q:$$FR(X) -1 ;Check Range
 S %P=X[".",%H=$$F2H(X),%T=$P(%H,",",2) D A2
 I %P,%T=0 S %H=%H-1,%T=86400
 Q $$H2F(%H_","_%T)
 ;
NOW() ;Current Date/time in FM.
 Q $$HTFM($H)
 ;
DT() ;Current Date in FM.
 Q $$HTFM($H,1)\1
 ;
SCH(SCH,LTM,FF) ;Find the next D/T given a schedule, start time.
 Q $$DECODE^XLFDT2
 ;
WITHIN(XLSCH,XLD) ;See if D/T is within schedule
 G WITHIN^XLFDT4
 ;
SEC(%) ;Convert $H to seconds.
 I %?7.N.".".N S %=$$FMTH(%) ;Check for FM date
 Q 86400*%+$P(%,",",2)
 ;
%H(%) ;Covert from seconds to $H
 Q (%\86400)_","_(%#86400)
 ;
TZ() ;Return current Time Zone from Mailman parameter file
 N %T,%S
 S %T=$P($G(^XMB(4.4,+$P($G(^XMB(1,1,0)),"^",2),0)),"^",3),%S=$S(%T["-":"-",1:"+"),%T=$TR(%T,"-+")
 Q %S_$E(100+%T,2,3)_$S(%T[".5":"30",1:"00")

XLFDT1^INT^1^63294;58829^0
XLFDT1 ;ISC-SF/RWF - Date/Time Functions cont. from VA FileMan %DTC ;02/20/2003  10:05
 ;;8.0;KERNEL;**71,280**;Jul 10, 1995
 ;If y contains a "D" then Date only.
 ;if y contains a "F" then output with leading blanks
 ;If y contains a "P" then output ' HH:MM:SS am/pm'.
 ;If y contains a "S" then force seconds in the output.
 ;if y contains a "M" then stop at minutes i.e. no seconds.
 ;
FMT ;
 N %G S %G=+%F
 G F1:%G=1,F2:%G=2,F3:%G=3,F4:%G=4,F5:%G=5,F6:%G=6,F7:%G=7,F8:%G=8,F9:%G=9,F1
 Q
 ;
F1 ;Apr 10, 2002
 S %R=$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$S($E(Y,6,7):$E(Y,6,7)_", ",1:"")_($E(Y,1,3)+1700)
 ;
TM ;All formats come here to format Time.
 N %,%S Q:%T'>0!(%F["D")
 I %F'["P" S %R=%R_"@"_$E(%T,2,3)_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 I %F["P" D
 . S %R=%R_" "_$S($E(%T,2,3)>12:$E(%T,2,3)-12,+$E(%T,2,3)=0:"12",1:+$E(%T,2,3))_":"_$E(%T,4,5)_$S(%F["M":"",$E(%T,6,7)!(%F["S"):":"_$E(%T,6,7),1:"")
 . S %R=%R_$S($E(%T,2,7)<120000:" am",$E(%T,2,3)=24:" am",1:" pm")
 . Q
 Q
 ;Return Month names
M() Q "  Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec"
 ;
F2 ;4/10/02
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F3 ;10/4/02
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_$E(Y,2,3)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F4 ;02/4/10
 S %R=$E(Y,2,3)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F5 ;4/10/2002
 S %R=$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F6 ;10/4/2002
 S %R=$J(+$E(Y,6,7),2)_"/"_$J(+$E(Y,4,5),2)_"/"_($E(Y,1,3)+1700)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F7 ;2002/4/10
 S %R=($E(Y,1,3)+1700)_"/"_$J(+$E(Y,4,5),2)_"/"_$J(+$E(Y,6,7),2)
 S:%F["Z" %R=$TR(%R," ","0") S:%F'["F" %R=$TR(%R," ")
 G TM
F8 ;10 Apr 02
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_$E(Y,2,3)
 G TM
F9 ;10 Apr 2002
 S %R=$S($E(Y,6,7):$E(Y,6,7)_" ",1:"")_$P($$M()," ",$S($E(Y,4,5):$E(Y,4,5)+2,1:0))_$S($E(Y,4,5):" ",1:"")_($E(Y,1,3)+1700)
 G TM

XLFSTR^INT^1^63294;58829^0
XLFSTR ;ISC-SF/STAFF - String Functions ;12/19/06  09:45
 ;;8.0;KERNEL;**112,120,400,437**;Jul 10, 1995;Build 2
 ;
UP(X) Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
 ;
LOW(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
 ;
STRIP(X,Y) Q $TR(X,$G(Y),"")
 ;
REPEAT(X,Y) ;
 N % Q:'$D(X) "" I $L(X)*$G(Y)>245 Q ""
 S %="",$P(%,X,$G(Y)+1)=""
 Q %
 ;
SPLIT(%SRC,%DLM,%VLIST) ;split a string by delimiter vars in list
 ;returns number of vars in list
 ;usage - s %=$$split(src,dlm,"d1,d2,d3,..")
 N I,V,DV
 S DV=$$DVARS(%VLIST),%DLM=$G(%DLM,",")
 F I=1:1:$L(%VLIST,DV) S V=$P(%VLIST,DV,I) S:V'="" @V=$P(%SRC,%DLM,I)
 Q I
 ;
DVARS(LIST) ;return a delimiter for a list of variables
 Q $S(%VLIST[$C(9):$C(9),%VLIST[";":";",1:",")
 ;
INVERT(X) ;
 N %,%1 S %="" F %1=$L(X):-1:1 S %=%_$E(X,%1)
 Q %
 ;
REPLACE(IN,SPEC) ;See $$REPLACE in MDC minutes.
 Q:'$D(IN) "" Q:$D(SPEC)'>9 IN N %1,%2,%3,%4,%5,%6,%7,%8
 S %1=$L(IN),%7=$J("",%1),%3="",%6=9999 F  S %3=$O(SPEC(%3)) Q:%3=""  S %6(%6)=%3,%6=%6-1
 F %6=0:0 S %6=$O(%6(%6)) Q:%6'>0  S %3=%6(%6) D:$D(SPEC(%3))#2 RE1
 S %8="" F %2=1:1:%1 D RE3
 Q %8
 ;
RE1 S %4=$L(%3),%5=0 F  S %5=$F(IN,%3,%5) Q:%5<1  D RE2
 Q
RE2 Q:$E(%7,%5-%4,%5-1)["X"  S %8(%5-%4)=SPEC(%3)
 F %2=%5-%4:1:%5-1 S %7=$E(%7,1,%2-1)_"X"_$E(%7,%2+1,%1)
 Q
RE3 I $E(%7,%2)=" " S %8=%8_$E(IN,%2) Q
 S:$D(%8(%2)) %8=%8_%8(%2)
 Q
 ;
RJ(%,%1,%2) ;Right justify
 N %3
 S:%1["T" %1=+%1,%=$E(%,1,%1)
 S %3=$J("",%1-$L(%)) S:$D(%2) %3=$TR(%3," ",%2)
 Q %3_%
 ;
LJ(%,%1,%2) ;Left justify
 N %3
 S:%1["T" %1=+%1,%=$E(%,1,%1)
 S %3=$J("",%1-$L(%)) S:$G(%2)]"" %3=$TR(%3," ",%2)
 Q %_%3
 ;
CJ(%,%1,%2) ;Center Justify
 N %3,%4
 S:%1["T" %1=+%1,%=$E(%,1,%1) S %3=%1-$L(%) Q:%3<1 %
 S %3=%3\2,%4=$J("",%3+1) I $G(%2)]"" S %4=$TR(%4," ",%2)
 Q $E(%4,1,%3)_%_$E(%4,1,%1-%3-$L(%))
 ;
QUOTE(%) ;Add quotes to value for concatenation
 S %(%)=0,%=$Q(%)
 Q $P($E(%,1,$L(%)-1),"(",2,999)
 ;
TRIM(%X,%F,%V) ;Trim spaces\char from front(left)/back(right) of string
 N %R,%L
 S %F=$$UP($G(%F,"LR")),%L=1,%R=$L(%X),%V=$G(%V," ")
 I %F["R" F %R=$L(%X):-1:1 Q:$E(%X,%R)'=%V
 I %F["L" F %L=1:1:$L(%X) Q:$E(%X,%L)'=%V
 I (%L>%R)!(%X=%V) Q ""
 Q $E(%X,%L,%R)
 ;
SENTENCE(%X) ;
 ; Converts a string into proper sentence case (first letter of each sentence
 ;  upper case, all the others lower case)
 ; Example Usage:
 ; W $$SENTENCE^XLFSTR("HELLO WORLD!!! THIS IS A CAPITALIZED SENTENCE. (this isn't.)")
 ;  produces
 ; Hello world!!! This is a capitalized sentence. This isn't.
 ;
 ; %S = string during conversion
 ; %P = state flag (1 = next letter should be caps)
 ; I = iteration index
 ; C = current character
 ;
 N %I,%C,%S,%P
 S %S=$$LOW(%X),%P=1
 F %I=1:1:$L(%X) D
 . S %C=$E(%S,%I)
 . I %P,%C?1L S $E(%S,%I)=$$UP(%C),%P=0
 . S:".!?"[%C %P=1
 Q %S
 ;
TITLE(%X) ;
 ; Converts a string into TITLE CASE format (first letter of each word is uppercase)
 ; Example Usage:
 ; W $$TITLE^XLFSTR("THIS IS CAPITALIZED. (this isn't.)")
 ; produces
 ; This Is Capitalized. This Isn't.
 ;
 ; %S = string during conversion
 ; %P = state flag
 ; %I = iteration index
 ; %C = current character
 ;
 N %I,%C,%S,%P
 S %S=$$LOW(%X),%P=1
 F %I=1:1:$L(%S) D
 . S %C=$E(%S,%I)
 . I %P,%C?1L S $E(%S,%I)=$$UP(%C),%P=0
 . S:%C=" " %P=1
 . Q
 Q %S

XLFUTL^INT^1^63294;58829^0
XLFUTL ;SFISC/RWF - Library Function, Check digit ;6/29/94  14:04
 ;;8.0;KERNEL;;Jul 10, 1995
 Q
 ;
CCD(%X) ; Compute check digit and append to number
 ;see Taylor report Computerworld 1975
 ; X= integer, Return X with check digit
 ;
 N %I,%N,%D,%S S %S=0,%D=1,%X=$G(%X) S:+%X'=%X (%X,%S)=""
 F %I=$L(%X):-1:1 S %N=$E(%X,%I),%N=%N*(%D+1),%N=$E(%N)+$E(%N,2),%S=%S+%N,%D='%D
 Q %X_$S(+%X:(-%S#10),1:"")
 ;
VCD(%X) ; -- Verify check digit (last digit)
 ; -- Pass X = integer with check digit appended
 ; -- rtns 0 if check not valid or 1 if valid
 ;
 Q %X=$$CCD($E(%X,1,$L(%X)-1))
 ;
QL(X) ;$QLENGTH OF GLOBAL STRING
 N %,%1
 S %1="" F %=0:1 Q:%1=$NA(@X,%)  S %1=$NA(@X,%)
 Q %-1
 ;
QS(X1,X2) ;$QSUBSCRIPT OF GLOBAL STRING
 N %,%1,Y
 I X2=-1,X1?1"^"1"[".E1"]".E Q $TR($P($P($NA(@X1,0),"]"),"[",2),"""")
 I X2=-1,X1?1"^"1"|".E1"|".E Q $TR($P($NA(@X1,0),"|",2,$L($NA(@X1,0),"|")-1),"""")
 I X2=0,(X1'?1"^"1"[".E)&(X1'?1"^"1"|".E) Q $NA(@X1,X2)
 I X2=0,X1?1"^"1"[".E1"]".E Q "^"_$P($NA(@X1,X2),"]",2,999)
 I X2=0,X1?1"^"1"|".E Q "^"_$P($NA(@X1,X2),"|",$L($NA(@X1,X2),"|"))
 S %1=$NA(@X1,X2-1)
 I $E(%1,$L(%1))=")" S %1=$E(%1,1,$L(%1)-1)
 S Y=$P($NA(@X1,X2),%1,2,999),Y=$E(Y,1,$L(Y)-1)
 I X2=1,$E(Y)="(" S Y=$E(Y,2,999)
 I X2>1,$E(Y)="," S Y=$E(Y,2,999)
 I $A(Y)=34,$A(Y,$L(Y))=34 S Y=$E(Y,2,$L(Y)-1)
 Q Y
BASE(%X1,%X2,%X3) ;Convert %X1 from %X2 base to %X3 base
 I (%X2<2)!(%X2>16)!(%X3<2)!(%X3>16) Q -1
 Q $$CNV($$DEC(%X1,%X2),%X3)
DEC(N,B) ;Cnv N from B to 10
 Q:B=10 N N I,Y S Y=0
 F I=1:1:$L(N) S Y=Y*B+($F("0123456789ABCDEF",$E(N,I))-2)
 Q Y
CNV(N,B) ;Cnv N from 10 to B
 Q:B=10 N N I,Y S Y=""
 F I=1:1 S Y=$E("0123456789ABCDEF",N#B+1)_Y,N=N\B Q:N<1
 Q Y

